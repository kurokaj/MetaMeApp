function vA(r,e){for(var t=0;t<e.length;t++){const n=e[t];if(typeof n!="string"&&!Array.isArray(n)){for(const i in n)if(i!=="default"&&!(i in r)){const s=Object.getOwnPropertyDescriptor(n,i);s&&Object.defineProperty(r,i,s.get?s:{enumerable:!0,get:()=>n[i]})}}}return Object.freeze(Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();function gg(r,e){const t=Object.create(null),n=r.split(",");for(let i=0;i<n.length;i++)t[n[i]]=!0;return e?i=>!!t[i.toLowerCase()]:i=>!!t[i]}function yg(r){if(St(r)){const e={};for(let t=0;t<r.length;t++){const n=r[t],i=jn(n)?EA(n):yg(n);if(i)for(const s in i)e[s]=i[s]}return e}else{if(jn(r))return r;if(Mn(r))return r}}const wA=/;(?![^(]*\))/g,SA=/:([^]+)/,TA=/\/\*.*?\*\//gs;function EA(r){const e={};return r.replace(TA,"").split(wA).forEach(t=>{if(t){const n=t.split(SA);n.length>1&&(e[n[0].trim()]=n[1].trim())}}),e}function _g(r){let e="";if(jn(r))e=r;else if(St(r))for(let t=0;t<r.length;t++){const n=_g(r[t]);n&&(e+=n+" ")}else if(Mn(r))for(const t in r)r[t]&&(e+=t+" ");return e.trim()}const MA="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",AA=gg(MA);function Mv(r){return!!r||r===""}const fn={},yl=[],Oi=()=>{},IA=()=>!1,CA=/^on[^a-z]/,bf=r=>CA.test(r),bg=r=>r.startsWith("onUpdate:"),lr=Object.assign,xg=(r,e)=>{const t=r.indexOf(e);t>-1&&r.splice(t,1)},kA=Object.prototype.hasOwnProperty,Dt=(r,e)=>kA.call(r,e),St=Array.isArray,Hu=r=>xf(r)==="[object Map]",NA=r=>xf(r)==="[object Set]",It=r=>typeof r=="function",jn=r=>typeof r=="string",vg=r=>typeof r=="symbol",Mn=r=>r!==null&&typeof r=="object",Av=r=>Mn(r)&&It(r.then)&&It(r.catch),RA=Object.prototype.toString,xf=r=>RA.call(r),PA=r=>xf(r).slice(8,-1),LA=r=>xf(r)==="[object Object]",wg=r=>jn(r)&&r!=="NaN"&&r[0]!=="-"&&""+parseInt(r,10)===r,Sh=gg(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),vf=r=>{const e=Object.create(null);return t=>e[t]||(e[t]=r(t))},DA=/-(\w)/g,kl=vf(r=>r.replace(DA,(e,t)=>t?t.toUpperCase():"")),OA=/\B([A-Z])/g,eu=vf(r=>r.replace(OA,"-$1").toLowerCase()),Iv=vf(r=>r.charAt(0).toUpperCase()+r.slice(1)),fd=vf(r=>r?`on${Iv(r)}`:""),zh=(r,e)=>!Object.is(r,e),dd=(r,e)=>{for(let t=0;t<r.length;t++)r[t](e)},Bh=(r,e,t)=>{Object.defineProperty(r,e,{configurable:!0,enumerable:!1,value:t})},FA=r=>{const e=parseFloat(r);return isNaN(e)?r:e};let w0;const $A=()=>w0||(w0=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let ki;class zA{constructor(e=!1){this.detached=e,this._active=!0,this.effects=[],this.cleanups=[],this.parent=ki,!e&&ki&&(this.index=(ki.scopes||(ki.scopes=[])).push(this)-1)}get active(){return this._active}run(e){if(this._active){const t=ki;try{return ki=this,e()}finally{ki=t}}}on(){ki=this}off(){ki=this.parent}stop(e){if(this._active){let t,n;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].stop();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this._active=!1}}}function BA(r,e=ki){e&&e.active&&e.effects.push(r)}function UA(){return ki}const Sg=r=>{const e=new Set(r);return e.w=0,e.n=0,e},Cv=r=>(r.w&vo)>0,kv=r=>(r.n&vo)>0,VA=({deps:r})=>{if(r.length)for(let e=0;e<r.length;e++)r[e].w|=vo},WA=r=>{const{deps:e}=r;if(e.length){let t=0;for(let n=0;n<e.length;n++){const i=e[n];Cv(i)&&!kv(i)?i.delete(r):e[t++]=i,i.w&=~vo,i.n&=~vo}e.length=t}},kp=new WeakMap;let Du=0,vo=1;const Np=30;let Pi;const la=Symbol(""),Rp=Symbol("");class Tg{constructor(e,t=null,n){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,BA(this,n)}run(){if(!this.active)return this.fn();let e=Pi,t=ho;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=Pi,Pi=this,ho=!0,vo=1<<++Du,Du<=Np?VA(this):S0(this),this.fn()}finally{Du<=Np&&WA(this),vo=1<<--Du,Pi=this.parent,ho=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){Pi===this?this.deferStop=!0:this.active&&(S0(this),this.onStop&&this.onStop(),this.active=!1)}}function S0(r){const{deps:e}=r;if(e.length){for(let t=0;t<e.length;t++)e[t].delete(r);e.length=0}}let ho=!0;const Nv=[];function tu(){Nv.push(ho),ho=!1}function nu(){const r=Nv.pop();ho=r===void 0?!0:r}function Nr(r,e,t){if(ho&&Pi){let n=kp.get(r);n||kp.set(r,n=new Map);let i=n.get(t);i||n.set(t,i=Sg()),Rv(i)}}function Rv(r,e){let t=!1;Du<=Np?kv(r)||(r.n|=vo,t=!Cv(r)):t=!r.has(Pi),t&&(r.add(Pi),Pi.deps.push(r))}function Ns(r,e,t,n,i,s){const o=kp.get(r);if(!o)return;let a=[];if(e==="clear")a=[...o.values()];else if(t==="length"&&St(r)){const l=Number(n);o.forEach((u,c)=>{(c==="length"||c>=l)&&a.push(u)})}else switch(t!==void 0&&a.push(o.get(t)),e){case"add":St(r)?wg(t)&&a.push(o.get("length")):(a.push(o.get(la)),Hu(r)&&a.push(o.get(Rp)));break;case"delete":St(r)||(a.push(o.get(la)),Hu(r)&&a.push(o.get(Rp)));break;case"set":Hu(r)&&a.push(o.get(la));break}if(a.length===1)a[0]&&Pp(a[0]);else{const l=[];for(const u of a)u&&l.push(...u);Pp(Sg(l))}}function Pp(r,e){const t=St(r)?r:[...r];for(const n of t)n.computed&&T0(n);for(const n of t)n.computed||T0(n)}function T0(r,e){(r!==Pi||r.allowRecurse)&&(r.scheduler?r.scheduler():r.run())}const GA=gg("__proto__,__v_isRef,__isVue"),Pv=new Set(Object.getOwnPropertyNames(Symbol).filter(r=>r!=="arguments"&&r!=="caller").map(r=>Symbol[r]).filter(vg)),HA=Eg(),jA=Eg(!1,!0),qA=Eg(!0),E0=KA();function KA(){const r={};return["includes","indexOf","lastIndexOf"].forEach(e=>{r[e]=function(...t){const n=Bt(this);for(let s=0,o=this.length;s<o;s++)Nr(n,"get",s+"");const i=n[e](...t);return i===-1||i===!1?n[e](...t.map(Bt)):i}}),["push","pop","shift","unshift","splice"].forEach(e=>{r[e]=function(...t){tu();const n=Bt(this)[e].apply(this,t);return nu(),n}}),r}function XA(r){const e=Bt(this);return Nr(e,"has",r),e.hasOwnProperty(r)}function Eg(r=!1,e=!1){return function(n,i,s){if(i==="__v_isReactive")return!r;if(i==="__v_isReadonly")return r;if(i==="__v_isShallow")return e;if(i==="__v_raw"&&s===(r?e?h3:$v:e?Fv:Ov).get(n))return n;const o=St(n);if(!r){if(o&&Dt(E0,i))return Reflect.get(E0,i,s);if(i==="hasOwnProperty")return XA}const a=Reflect.get(n,i,s);return(vg(i)?Pv.has(i):GA(i))||(r||Nr(n,"get",i),e)?a:mr(a)?o&&wg(i)?a:a.value:Mn(a)?r?zv(a):Ig(a):a}}const YA=Lv(),ZA=Lv(!0);function Lv(r=!1){return function(t,n,i,s){let o=t[n];if(nc(o)&&mr(o)&&!mr(i))return!1;if(!r&&(!Lp(i)&&!nc(i)&&(o=Bt(o),i=Bt(i)),!St(t)&&mr(o)&&!mr(i)))return o.value=i,!0;const a=St(t)&&wg(n)?Number(n)<t.length:Dt(t,n),l=Reflect.set(t,n,i,s);return t===Bt(s)&&(a?zh(i,o)&&Ns(t,"set",n,i):Ns(t,"add",n,i)),l}}function QA(r,e){const t=Dt(r,e);r[e];const n=Reflect.deleteProperty(r,e);return n&&t&&Ns(r,"delete",e,void 0),n}function JA(r,e){const t=Reflect.has(r,e);return(!vg(e)||!Pv.has(e))&&Nr(r,"has",e),t}function e3(r){return Nr(r,"iterate",St(r)?"length":la),Reflect.ownKeys(r)}const Dv={get:HA,set:YA,deleteProperty:QA,has:JA,ownKeys:e3},t3={get:qA,set(r,e){return!0},deleteProperty(r,e){return!0}},n3=lr({},Dv,{get:jA,set:ZA}),Mg=r=>r,wf=r=>Reflect.getPrototypeOf(r);function Gc(r,e,t=!1,n=!1){r=r.__v_raw;const i=Bt(r),s=Bt(e);t||(e!==s&&Nr(i,"get",e),Nr(i,"get",s));const{has:o}=wf(i),a=n?Mg:t?Ng:kg;if(o.call(i,e))return a(r.get(e));if(o.call(i,s))return a(r.get(s));r!==i&&r.get(e)}function Hc(r,e=!1){const t=this.__v_raw,n=Bt(t),i=Bt(r);return e||(r!==i&&Nr(n,"has",r),Nr(n,"has",i)),r===i?t.has(r):t.has(r)||t.has(i)}function jc(r,e=!1){return r=r.__v_raw,!e&&Nr(Bt(r),"iterate",la),Reflect.get(r,"size",r)}function M0(r){r=Bt(r);const e=Bt(this);return wf(e).has.call(e,r)||(e.add(r),Ns(e,"add",r,r)),this}function A0(r,e){e=Bt(e);const t=Bt(this),{has:n,get:i}=wf(t);let s=n.call(t,r);s||(r=Bt(r),s=n.call(t,r));const o=i.call(t,r);return t.set(r,e),s?zh(e,o)&&Ns(t,"set",r,e):Ns(t,"add",r,e),this}function I0(r){const e=Bt(this),{has:t,get:n}=wf(e);let i=t.call(e,r);i||(r=Bt(r),i=t.call(e,r)),n&&n.call(e,r);const s=e.delete(r);return i&&Ns(e,"delete",r,void 0),s}function C0(){const r=Bt(this),e=r.size!==0,t=r.clear();return e&&Ns(r,"clear",void 0,void 0),t}function qc(r,e){return function(n,i){const s=this,o=s.__v_raw,a=Bt(o),l=e?Mg:r?Ng:kg;return!r&&Nr(a,"iterate",la),o.forEach((u,c)=>n.call(i,l(u),l(c),s))}}function Kc(r,e,t){return function(...n){const i=this.__v_raw,s=Bt(i),o=Hu(s),a=r==="entries"||r===Symbol.iterator&&o,l=r==="keys"&&o,u=i[r](...n),c=t?Mg:e?Ng:kg;return!e&&Nr(s,"iterate",l?Rp:la),{next(){const{value:h,done:f}=u.next();return f?{value:h,done:f}:{value:a?[c(h[0]),c(h[1])]:c(h),done:f}},[Symbol.iterator](){return this}}}}function Xs(r){return function(...e){return r==="delete"?!1:this}}function r3(){const r={get(s){return Gc(this,s)},get size(){return jc(this)},has:Hc,add:M0,set:A0,delete:I0,clear:C0,forEach:qc(!1,!1)},e={get(s){return Gc(this,s,!1,!0)},get size(){return jc(this)},has:Hc,add:M0,set:A0,delete:I0,clear:C0,forEach:qc(!1,!0)},t={get(s){return Gc(this,s,!0)},get size(){return jc(this,!0)},has(s){return Hc.call(this,s,!0)},add:Xs("add"),set:Xs("set"),delete:Xs("delete"),clear:Xs("clear"),forEach:qc(!0,!1)},n={get(s){return Gc(this,s,!0,!0)},get size(){return jc(this,!0)},has(s){return Hc.call(this,s,!0)},add:Xs("add"),set:Xs("set"),delete:Xs("delete"),clear:Xs("clear"),forEach:qc(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{r[s]=Kc(s,!1,!1),t[s]=Kc(s,!0,!1),e[s]=Kc(s,!1,!0),n[s]=Kc(s,!0,!0)}),[r,t,e,n]}const[i3,s3,o3,a3]=r3();function Ag(r,e){const t=e?r?a3:o3:r?s3:i3;return(n,i,s)=>i==="__v_isReactive"?!r:i==="__v_isReadonly"?r:i==="__v_raw"?n:Reflect.get(Dt(t,i)&&i in n?t:n,i,s)}const l3={get:Ag(!1,!1)},u3={get:Ag(!1,!0)},c3={get:Ag(!0,!1)},Ov=new WeakMap,Fv=new WeakMap,$v=new WeakMap,h3=new WeakMap;function f3(r){switch(r){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function d3(r){return r.__v_skip||!Object.isExtensible(r)?0:f3(PA(r))}function Ig(r){return nc(r)?r:Cg(r,!1,Dv,l3,Ov)}function p3(r){return Cg(r,!1,n3,u3,Fv)}function zv(r){return Cg(r,!0,t3,c3,$v)}function Cg(r,e,t,n,i){if(!Mn(r)||r.__v_raw&&!(e&&r.__v_isReactive))return r;const s=i.get(r);if(s)return s;const o=d3(r);if(o===0)return r;const a=new Proxy(r,o===2?n:t);return i.set(r,a),a}function _l(r){return nc(r)?_l(r.__v_raw):!!(r&&r.__v_isReactive)}function nc(r){return!!(r&&r.__v_isReadonly)}function Lp(r){return!!(r&&r.__v_isShallow)}function Bv(r){return _l(r)||nc(r)}function Bt(r){const e=r&&r.__v_raw;return e?Bt(e):r}function Uv(r){return Bh(r,"__v_skip",!0),r}const kg=r=>Mn(r)?Ig(r):r,Ng=r=>Mn(r)?zv(r):r;function m3(r){ho&&Pi&&(r=Bt(r),Rv(r.dep||(r.dep=Sg())))}function g3(r,e){r=Bt(r);const t=r.dep;t&&Pp(t)}function mr(r){return!!(r&&r.__v_isRef===!0)}function y3(r){return mr(r)?r.value:r}const _3={get:(r,e,t)=>y3(Reflect.get(r,e,t)),set:(r,e,t,n)=>{const i=r[e];return mr(i)&&!mr(t)?(i.value=t,!0):Reflect.set(r,e,t,n)}};function Vv(r){return _l(r)?r:new Proxy(r,_3)}var Wv;class b3{constructor(e,t,n,i){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this[Wv]=!1,this._dirty=!0,this.effect=new Tg(e,()=>{this._dirty||(this._dirty=!0,g3(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!i,this.__v_isReadonly=n}get value(){const e=Bt(this);return m3(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}Wv="__v_isReadonly";function x3(r,e,t=!1){let n,i;const s=It(r);return s?(n=r,i=Oi):(n=r.get,i=r.set),new b3(n,i,s||!i,t)}function fo(r,e,t,n){let i;try{i=n?r(...n):r()}catch(s){Sf(s,e,t)}return i}function bi(r,e,t,n){if(It(r)){const s=fo(r,e,t,n);return s&&Av(s)&&s.catch(o=>{Sf(o,e,t)}),s}const i=[];for(let s=0;s<r.length;s++)i.push(bi(r[s],e,t,n));return i}function Sf(r,e,t,n=!0){const i=e?e.vnode:null;if(e){let s=e.parent;const o=e.proxy,a=t;for(;s;){const u=s.ec;if(u){for(let c=0;c<u.length;c++)if(u[c](r,o,a)===!1)return}s=s.parent}const l=e.appContext.config.errorHandler;if(l){fo(l,null,10,[r,o,a]);return}}v3(r,t,i,n)}function v3(r,e,t,n=!0){console.error(r)}let rc=!1,Dp=!1;const tr=[];let Xi=0;const bl=[];let ps=null,Ko=0;const Gv=Promise.resolve();let Rg=null;function w3(r){const e=Rg||Gv;return r?e.then(this?r.bind(this):r):e}function S3(r){let e=Xi+1,t=tr.length;for(;e<t;){const n=e+t>>>1;ic(tr[n])<r?e=n+1:t=n}return e}function Pg(r){(!tr.length||!tr.includes(r,rc&&r.allowRecurse?Xi+1:Xi))&&(r.id==null?tr.push(r):tr.splice(S3(r.id),0,r),Hv())}function Hv(){!rc&&!Dp&&(Dp=!0,Rg=Gv.then(qv))}function T3(r){const e=tr.indexOf(r);e>Xi&&tr.splice(e,1)}function E3(r){St(r)?bl.push(...r):(!ps||!ps.includes(r,r.allowRecurse?Ko+1:Ko))&&bl.push(r),Hv()}function k0(r,e=rc?Xi+1:0){for(;e<tr.length;e++){const t=tr[e];t&&t.pre&&(tr.splice(e,1),e--,t())}}function jv(r){if(bl.length){const e=[...new Set(bl)];if(bl.length=0,ps){ps.push(...e);return}for(ps=e,ps.sort((t,n)=>ic(t)-ic(n)),Ko=0;Ko<ps.length;Ko++)ps[Ko]();ps=null,Ko=0}}const ic=r=>r.id==null?1/0:r.id,M3=(r,e)=>{const t=ic(r)-ic(e);if(t===0){if(r.pre&&!e.pre)return-1;if(e.pre&&!r.pre)return 1}return t};function qv(r){Dp=!1,rc=!0,tr.sort(M3);const e=Oi;try{for(Xi=0;Xi<tr.length;Xi++){const t=tr[Xi];t&&t.active!==!1&&fo(t,null,14)}}finally{Xi=0,tr.length=0,jv(),rc=!1,Rg=null,(tr.length||bl.length)&&qv()}}function A3(r,e,...t){if(r.isUnmounted)return;const n=r.vnode.props||fn;let i=t;const s=e.startsWith("update:"),o=s&&e.slice(7);if(o&&o in n){const c=`${o==="modelValue"?"model":o}Modifiers`,{number:h,trim:f}=n[c]||fn;f&&(i=t.map(d=>jn(d)?d.trim():d)),h&&(i=t.map(FA))}let a,l=n[a=fd(e)]||n[a=fd(kl(e))];!l&&s&&(l=n[a=fd(eu(e))]),l&&bi(l,r,6,i);const u=n[a+"Once"];if(u){if(!r.emitted)r.emitted={};else if(r.emitted[a])return;r.emitted[a]=!0,bi(u,r,6,i)}}function Kv(r,e,t=!1){const n=e.emitsCache,i=n.get(r);if(i!==void 0)return i;const s=r.emits;let o={},a=!1;if(!It(r)){const l=u=>{const c=Kv(u,e,!0);c&&(a=!0,lr(o,c))};!t&&e.mixins.length&&e.mixins.forEach(l),r.extends&&l(r.extends),r.mixins&&r.mixins.forEach(l)}return!s&&!a?(Mn(r)&&n.set(r,null),null):(St(s)?s.forEach(l=>o[l]=null):lr(o,s),Mn(r)&&n.set(r,o),o)}function Tf(r,e){return!r||!bf(e)?!1:(e=e.slice(2).replace(/Once$/,""),Dt(r,e[0].toLowerCase()+e.slice(1))||Dt(r,eu(e))||Dt(r,e))}let Li=null,Xv=null;function Uh(r){const e=Li;return Li=r,Xv=r&&r.type.__scopeId||null,e}function I3(r,e=Li,t){if(!e||r._n)return r;const n=(...i)=>{n._d&&z0(-1);const s=Uh(e);let o;try{o=r(...i)}finally{Uh(s),n._d&&z0(1)}return o};return n._n=!0,n._c=!0,n._d=!0,n}function pd(r){const{type:e,vnode:t,proxy:n,withProxy:i,props:s,propsOptions:[o],slots:a,attrs:l,emit:u,render:c,renderCache:h,data:f,setupState:d,ctx:g,inheritAttrs:p}=r;let m,_;const v=Uh(r);try{if(t.shapeFlag&4){const x=i||n;m=ji(c.call(x,x,h,s,d,f,g)),_=l}else{const x=e;m=ji(x.length>1?x(s,{attrs:l,slots:a,emit:u}):x(s,null)),_=e.props?l:C3(l)}}catch(x){qu.length=0,Sf(x,r,1),m=po(Ms)}let b=m;if(_&&p!==!1){const x=Object.keys(_),{shapeFlag:T}=b;x.length&&T&7&&(o&&x.some(bg)&&(_=k3(_,o)),b=wo(b,_))}return t.dirs&&(b=wo(b),b.dirs=b.dirs?b.dirs.concat(t.dirs):t.dirs),t.transition&&(b.transition=t.transition),m=b,Uh(v),m}const C3=r=>{let e;for(const t in r)(t==="class"||t==="style"||bf(t))&&((e||(e={}))[t]=r[t]);return e},k3=(r,e)=>{const t={};for(const n in r)(!bg(n)||!(n.slice(9)in e))&&(t[n]=r[n]);return t};function N3(r,e,t){const{props:n,children:i,component:s}=r,{props:o,children:a,patchFlag:l}=e,u=s.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&l>=0){if(l&1024)return!0;if(l&16)return n?N0(n,o,u):!!o;if(l&8){const c=e.dynamicProps;for(let h=0;h<c.length;h++){const f=c[h];if(o[f]!==n[f]&&!Tf(u,f))return!0}}}else return(i||a)&&(!a||!a.$stable)?!0:n===o?!1:n?o?N0(n,o,u):!0:!!o;return!1}function N0(r,e,t){const n=Object.keys(e);if(n.length!==Object.keys(r).length)return!0;for(let i=0;i<n.length;i++){const s=n[i];if(e[s]!==r[s]&&!Tf(t,s))return!0}return!1}function R3({vnode:r,parent:e},t){for(;e&&e.subTree===r;)(r=e.vnode).el=t,e=e.parent}const P3=r=>r.__isSuspense;function L3(r,e){e&&e.pendingBranch?St(r)?e.effects.push(...r):e.effects.push(r):E3(r)}function D3(r,e){if(En){let t=En.provides;const n=En.parent&&En.parent.provides;n===t&&(t=En.provides=Object.create(n)),t[r]=e}}function Th(r,e,t=!1){const n=En||Li;if(n){const i=n.parent==null?n.vnode.appContext&&n.vnode.appContext.provides:n.parent.provides;if(i&&r in i)return i[r];if(arguments.length>1)return t&&It(e)?e.call(n.proxy):e}}const Xc={};function md(r,e,t){return Yv(r,e,t)}function Yv(r,e,{immediate:t,deep:n,flush:i,onTrack:s,onTrigger:o}=fn){const a=UA()===(En==null?void 0:En.scope)?En:null;let l,u=!1,c=!1;if(mr(r)?(l=()=>r.value,u=Lp(r)):_l(r)?(l=()=>r,n=!0):St(r)?(c=!0,u=r.some(b=>_l(b)||Lp(b)),l=()=>r.map(b=>{if(mr(b))return b.value;if(_l(b))return fl(b);if(It(b))return fo(b,a,2)})):It(r)?e?l=()=>fo(r,a,2):l=()=>{if(!(a&&a.isUnmounted))return h&&h(),bi(r,a,3,[f])}:l=Oi,e&&n){const b=l;l=()=>fl(b())}let h,f=b=>{h=_.onStop=()=>{fo(b,a,4)}},d;if(oc)if(f=Oi,e?t&&bi(e,a,3,[l(),c?[]:void 0,f]):l(),i==="sync"){const b=LI();d=b.__watcherHandles||(b.__watcherHandles=[])}else return Oi;let g=c?new Array(r.length).fill(Xc):Xc;const p=()=>{if(_.active)if(e){const b=_.run();(n||u||(c?b.some((x,T)=>zh(x,g[T])):zh(b,g)))&&(h&&h(),bi(e,a,3,[b,g===Xc?void 0:c&&g[0]===Xc?[]:g,f]),g=b)}else _.run()};p.allowRecurse=!!e;let m;i==="sync"?m=p:i==="post"?m=()=>Sr(p,a&&a.suspense):(p.pre=!0,a&&(p.id=a.uid),m=()=>Pg(p));const _=new Tg(l,m);e?t?p():g=_.run():i==="post"?Sr(_.run.bind(_),a&&a.suspense):_.run();const v=()=>{_.stop(),a&&a.scope&&xg(a.scope.effects,_)};return d&&d.push(v),v}function O3(r,e,t){const n=this.proxy,i=jn(r)?r.includes(".")?Zv(n,r):()=>n[r]:r.bind(n,n);let s;It(e)?s=e:(s=e.handler,t=e);const o=En;Nl(this);const a=Yv(i,s.bind(n),t);return o?Nl(o):ua(),a}function Zv(r,e){const t=e.split(".");return()=>{let n=r;for(let i=0;i<t.length&&n;i++)n=n[t[i]];return n}}function fl(r,e){if(!Mn(r)||r.__v_skip||(e=e||new Set,e.has(r)))return r;if(e.add(r),mr(r))fl(r.value,e);else if(St(r))for(let t=0;t<r.length;t++)fl(r[t],e);else if(NA(r)||Hu(r))r.forEach(t=>{fl(t,e)});else if(LA(r))for(const t in r)fl(r[t],e);return r}function F3(){const r={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Lg(()=>{r.isMounted=!0}),tw(()=>{r.isUnmounting=!0}),r}const ni=[Function,Array],$3={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:ni,onEnter:ni,onAfterEnter:ni,onEnterCancelled:ni,onBeforeLeave:ni,onLeave:ni,onAfterLeave:ni,onLeaveCancelled:ni,onBeforeAppear:ni,onAppear:ni,onAfterAppear:ni,onAppearCancelled:ni},setup(r,{slots:e}){const t=MI(),n=F3();let i;return()=>{const s=e.default&&Jv(e.default(),!0);if(!s||!s.length)return;let o=s[0];if(s.length>1){for(const p of s)if(p.type!==Ms){o=p;break}}const a=Bt(r),{mode:l}=a;if(n.isLeaving)return gd(o);const u=R0(o);if(!u)return gd(o);const c=Op(u,a,n,t);Fp(u,c);const h=t.subTree,f=h&&R0(h);let d=!1;const{getTransitionKey:g}=u.type;if(g){const p=g();i===void 0?i=p:p!==i&&(i=p,d=!0)}if(f&&f.type!==Ms&&(!Xo(u,f)||d)){const p=Op(f,a,n,t);if(Fp(f,p),l==="out-in")return n.isLeaving=!0,p.afterLeave=()=>{n.isLeaving=!1,t.update.active!==!1&&t.update()},gd(o);l==="in-out"&&u.type!==Ms&&(p.delayLeave=(m,_,v)=>{const b=Qv(n,f);b[String(f.key)]=f,m._leaveCb=()=>{_(),m._leaveCb=void 0,delete c.delayedLeave},c.delayedLeave=v})}return o}}},z3=$3;function Qv(r,e){const{leavingVNodes:t}=r;let n=t.get(e.type);return n||(n=Object.create(null),t.set(e.type,n)),n}function Op(r,e,t,n){const{appear:i,mode:s,persisted:o=!1,onBeforeEnter:a,onEnter:l,onAfterEnter:u,onEnterCancelled:c,onBeforeLeave:h,onLeave:f,onAfterLeave:d,onLeaveCancelled:g,onBeforeAppear:p,onAppear:m,onAfterAppear:_,onAppearCancelled:v}=e,b=String(r.key),x=Qv(t,r),T=(S,A)=>{S&&bi(S,n,9,A)},I=(S,A)=>{const R=A[1];T(S,A),St(S)?S.every(F=>F.length<=1)&&R():S.length<=1&&R()},C={mode:s,persisted:o,beforeEnter(S){let A=a;if(!t.isMounted)if(i)A=p||a;else return;S._leaveCb&&S._leaveCb(!0);const R=x[b];R&&Xo(r,R)&&R.el._leaveCb&&R.el._leaveCb(),T(A,[S])},enter(S){let A=l,R=u,F=c;if(!t.isMounted)if(i)A=m||l,R=_||u,F=v||c;else return;let q=!1;const O=S._enterCb=z=>{q||(q=!0,z?T(F,[S]):T(R,[S]),C.delayedLeave&&C.delayedLeave(),S._enterCb=void 0)};A?I(A,[S,O]):O()},leave(S,A){const R=String(r.key);if(S._enterCb&&S._enterCb(!0),t.isUnmounting)return A();T(h,[S]);let F=!1;const q=S._leaveCb=O=>{F||(F=!0,A(),O?T(g,[S]):T(d,[S]),S._leaveCb=void 0,x[R]===r&&delete x[R])};x[R]=r,f?I(f,[S,q]):q()},clone(S){return Op(S,e,t,n)}};return C}function gd(r){if(Ef(r))return r=wo(r),r.children=null,r}function R0(r){return Ef(r)?r.children?r.children[0]:void 0:r}function Fp(r,e){r.shapeFlag&6&&r.component?Fp(r.component.subTree,e):r.shapeFlag&128?(r.ssContent.transition=e.clone(r.ssContent),r.ssFallback.transition=e.clone(r.ssFallback)):r.transition=e}function Jv(r,e=!1,t){let n=[],i=0;for(let s=0;s<r.length;s++){let o=r[s];const a=t==null?o.key:String(t)+String(o.key!=null?o.key:s);o.type===Ni?(o.patchFlag&128&&i++,n=n.concat(Jv(o.children,e,a))):(e||o.type!==Ms)&&n.push(a!=null?wo(o,{key:a}):o)}if(i>1)for(let s=0;s<n.length;s++)n[s].patchFlag=-2;return n}const Eh=r=>!!r.type.__asyncLoader,Ef=r=>r.type.__isKeepAlive;function B3(r,e){ew(r,"a",e)}function U3(r,e){ew(r,"da",e)}function ew(r,e,t=En){const n=r.__wdc||(r.__wdc=()=>{let i=t;for(;i;){if(i.isDeactivated)return;i=i.parent}return r()});if(Mf(e,n,t),t){let i=t.parent;for(;i&&i.parent;)Ef(i.parent.vnode)&&V3(n,e,t,i),i=i.parent}}function V3(r,e,t,n){const i=Mf(e,r,n,!0);nw(()=>{xg(n[e],i)},t)}function Mf(r,e,t=En,n=!1){if(t){const i=t[r]||(t[r]=[]),s=e.__weh||(e.__weh=(...o)=>{if(t.isUnmounted)return;tu(),Nl(t);const a=bi(e,t,r,o);return ua(),nu(),a});return n?i.unshift(s):i.push(s),s}}const Bs=r=>(e,t=En)=>(!oc||r==="sp")&&Mf(r,(...n)=>e(...n),t),W3=Bs("bm"),Lg=Bs("m"),G3=Bs("bu"),H3=Bs("u"),tw=Bs("bum"),nw=Bs("um"),j3=Bs("sp"),q3=Bs("rtg"),K3=Bs("rtc");function X3(r,e=En){Mf("ec",r,e)}function Lo(r,e,t,n){const i=r.dirs,s=e&&e.dirs;for(let o=0;o<i.length;o++){const a=i[o];s&&(a.oldValue=s[o].value);let l=a.dir[n];l&&(tu(),bi(l,t,8,[r.el,a,r,e]),nu())}}const Y3=Symbol(),$p=r=>r?pw(r)?$g(r)||r.proxy:$p(r.parent):null,ju=lr(Object.create(null),{$:r=>r,$el:r=>r.vnode.el,$data:r=>r.data,$props:r=>r.props,$attrs:r=>r.attrs,$slots:r=>r.slots,$refs:r=>r.refs,$parent:r=>$p(r.parent),$root:r=>$p(r.root),$emit:r=>r.emit,$options:r=>Dg(r),$forceUpdate:r=>r.f||(r.f=()=>Pg(r.update)),$nextTick:r=>r.n||(r.n=w3.bind(r.proxy)),$watch:r=>O3.bind(r)}),yd=(r,e)=>r!==fn&&!r.__isScriptSetup&&Dt(r,e),Z3={get({_:r},e){const{ctx:t,setupState:n,data:i,props:s,accessCache:o,type:a,appContext:l}=r;let u;if(e[0]!=="$"){const d=o[e];if(d!==void 0)switch(d){case 1:return n[e];case 2:return i[e];case 4:return t[e];case 3:return s[e]}else{if(yd(n,e))return o[e]=1,n[e];if(i!==fn&&Dt(i,e))return o[e]=2,i[e];if((u=r.propsOptions[0])&&Dt(u,e))return o[e]=3,s[e];if(t!==fn&&Dt(t,e))return o[e]=4,t[e];zp&&(o[e]=0)}}const c=ju[e];let h,f;if(c)return e==="$attrs"&&Nr(r,"get",e),c(r);if((h=a.__cssModules)&&(h=h[e]))return h;if(t!==fn&&Dt(t,e))return o[e]=4,t[e];if(f=l.config.globalProperties,Dt(f,e))return f[e]},set({_:r},e,t){const{data:n,setupState:i,ctx:s}=r;return yd(i,e)?(i[e]=t,!0):n!==fn&&Dt(n,e)?(n[e]=t,!0):Dt(r.props,e)||e[0]==="$"&&e.slice(1)in r?!1:(s[e]=t,!0)},has({_:{data:r,setupState:e,accessCache:t,ctx:n,appContext:i,propsOptions:s}},o){let a;return!!t[o]||r!==fn&&Dt(r,o)||yd(e,o)||(a=s[0])&&Dt(a,o)||Dt(n,o)||Dt(ju,o)||Dt(i.config.globalProperties,o)},defineProperty(r,e,t){return t.get!=null?r._.accessCache[e]=0:Dt(t,"value")&&this.set(r,e,t.value,null),Reflect.defineProperty(r,e,t)}};let zp=!0;function Q3(r){const e=Dg(r),t=r.proxy,n=r.ctx;zp=!1,e.beforeCreate&&P0(e.beforeCreate,r,"bc");const{data:i,computed:s,methods:o,watch:a,provide:l,inject:u,created:c,beforeMount:h,mounted:f,beforeUpdate:d,updated:g,activated:p,deactivated:m,beforeDestroy:_,beforeUnmount:v,destroyed:b,unmounted:x,render:T,renderTracked:I,renderTriggered:C,errorCaptured:S,serverPrefetch:A,expose:R,inheritAttrs:F,components:q,directives:O,filters:z}=e;if(u&&J3(u,n,null,r.appContext.config.unwrapInjectedRef),o)for(const Z in o){const Y=o[Z];It(Y)&&(n[Z]=Y.bind(t))}if(i){const Z=i.call(t,t);Mn(Z)&&(r.data=Ig(Z))}if(zp=!0,s)for(const Z in s){const Y=s[Z],fe=It(Y)?Y.bind(t,t):It(Y.get)?Y.get.bind(t,t):Oi,le=!It(Y)&&It(Y.set)?Y.set.bind(t):Oi,ve=RI({get:fe,set:le});Object.defineProperty(n,Z,{enumerable:!0,configurable:!0,get:()=>ve.value,set:ee=>ve.value=ee})}if(a)for(const Z in a)rw(a[Z],n,t,Z);if(l){const Z=It(l)?l.call(t):l;Reflect.ownKeys(Z).forEach(Y=>{D3(Y,Z[Y])})}c&&P0(c,r,"c");function Q(Z,Y){St(Y)?Y.forEach(fe=>Z(fe.bind(t))):Y&&Z(Y.bind(t))}if(Q(W3,h),Q(Lg,f),Q(G3,d),Q(H3,g),Q(B3,p),Q(U3,m),Q(X3,S),Q(K3,I),Q(q3,C),Q(tw,v),Q(nw,x),Q(j3,A),St(R))if(R.length){const Z=r.exposed||(r.exposed={});R.forEach(Y=>{Object.defineProperty(Z,Y,{get:()=>t[Y],set:fe=>t[Y]=fe})})}else r.exposed||(r.exposed={});T&&r.render===Oi&&(r.render=T),F!=null&&(r.inheritAttrs=F),q&&(r.components=q),O&&(r.directives=O)}function J3(r,e,t=Oi,n=!1){St(r)&&(r=Bp(r));for(const i in r){const s=r[i];let o;Mn(s)?"default"in s?o=Th(s.from||i,s.default,!0):o=Th(s.from||i):o=Th(s),mr(o)&&n?Object.defineProperty(e,i,{enumerable:!0,configurable:!0,get:()=>o.value,set:a=>o.value=a}):e[i]=o}}function P0(r,e,t){bi(St(r)?r.map(n=>n.bind(e.proxy)):r.bind(e.proxy),e,t)}function rw(r,e,t,n){const i=n.includes(".")?Zv(t,n):()=>t[n];if(jn(r)){const s=e[r];It(s)&&md(i,s)}else if(It(r))md(i,r.bind(t));else if(Mn(r))if(St(r))r.forEach(s=>rw(s,e,t,n));else{const s=It(r.handler)?r.handler.bind(t):e[r.handler];It(s)&&md(i,s,r)}}function Dg(r){const e=r.type,{mixins:t,extends:n}=e,{mixins:i,optionsCache:s,config:{optionMergeStrategies:o}}=r.appContext,a=s.get(e);let l;return a?l=a:!i.length&&!t&&!n?l=e:(l={},i.length&&i.forEach(u=>Vh(l,u,o,!0)),Vh(l,e,o)),Mn(e)&&s.set(e,l),l}function Vh(r,e,t,n=!1){const{mixins:i,extends:s}=e;s&&Vh(r,s,t,!0),i&&i.forEach(o=>Vh(r,o,t,!0));for(const o in e)if(!(n&&o==="expose")){const a=eI[o]||t&&t[o];r[o]=a?a(r[o],e[o]):e[o]}return r}const eI={data:L0,props:Vo,emits:Vo,methods:Vo,computed:Vo,beforeCreate:hr,created:hr,beforeMount:hr,mounted:hr,beforeUpdate:hr,updated:hr,beforeDestroy:hr,beforeUnmount:hr,destroyed:hr,unmounted:hr,activated:hr,deactivated:hr,errorCaptured:hr,serverPrefetch:hr,components:Vo,directives:Vo,watch:nI,provide:L0,inject:tI};function L0(r,e){return e?r?function(){return lr(It(r)?r.call(this,this):r,It(e)?e.call(this,this):e)}:e:r}function tI(r,e){return Vo(Bp(r),Bp(e))}function Bp(r){if(St(r)){const e={};for(let t=0;t<r.length;t++)e[r[t]]=r[t];return e}return r}function hr(r,e){return r?[...new Set([].concat(r,e))]:e}function Vo(r,e){return r?lr(lr(Object.create(null),r),e):e}function nI(r,e){if(!r)return e;if(!e)return r;const t=lr(Object.create(null),r);for(const n in e)t[n]=hr(r[n],e[n]);return t}function rI(r,e,t,n=!1){const i={},s={};Bh(s,If,1),r.propsDefaults=Object.create(null),iw(r,e,i,s);for(const o in r.propsOptions[0])o in i||(i[o]=void 0);t?r.props=n?i:p3(i):r.type.props?r.props=i:r.props=s,r.attrs=s}function iI(r,e,t,n){const{props:i,attrs:s,vnode:{patchFlag:o}}=r,a=Bt(i),[l]=r.propsOptions;let u=!1;if((n||o>0)&&!(o&16)){if(o&8){const c=r.vnode.dynamicProps;for(let h=0;h<c.length;h++){let f=c[h];if(Tf(r.emitsOptions,f))continue;const d=e[f];if(l)if(Dt(s,f))d!==s[f]&&(s[f]=d,u=!0);else{const g=kl(f);i[g]=Up(l,a,g,d,r,!1)}else d!==s[f]&&(s[f]=d,u=!0)}}}else{iw(r,e,i,s)&&(u=!0);let c;for(const h in a)(!e||!Dt(e,h)&&((c=eu(h))===h||!Dt(e,c)))&&(l?t&&(t[h]!==void 0||t[c]!==void 0)&&(i[h]=Up(l,a,h,void 0,r,!0)):delete i[h]);if(s!==a)for(const h in s)(!e||!Dt(e,h))&&(delete s[h],u=!0)}u&&Ns(r,"set","$attrs")}function iw(r,e,t,n){const[i,s]=r.propsOptions;let o=!1,a;if(e)for(let l in e){if(Sh(l))continue;const u=e[l];let c;i&&Dt(i,c=kl(l))?!s||!s.includes(c)?t[c]=u:(a||(a={}))[c]=u:Tf(r.emitsOptions,l)||(!(l in n)||u!==n[l])&&(n[l]=u,o=!0)}if(s){const l=Bt(t),u=a||fn;for(let c=0;c<s.length;c++){const h=s[c];t[h]=Up(i,l,h,u[h],r,!Dt(u,h))}}return o}function Up(r,e,t,n,i,s){const o=r[t];if(o!=null){const a=Dt(o,"default");if(a&&n===void 0){const l=o.default;if(o.type!==Function&&It(l)){const{propsDefaults:u}=i;t in u?n=u[t]:(Nl(i),n=u[t]=l.call(null,e),ua())}else n=l}o[0]&&(s&&!a?n=!1:o[1]&&(n===""||n===eu(t))&&(n=!0))}return n}function sw(r,e,t=!1){const n=e.propsCache,i=n.get(r);if(i)return i;const s=r.props,o={},a=[];let l=!1;if(!It(r)){const c=h=>{l=!0;const[f,d]=sw(h,e,!0);lr(o,f),d&&a.push(...d)};!t&&e.mixins.length&&e.mixins.forEach(c),r.extends&&c(r.extends),r.mixins&&r.mixins.forEach(c)}if(!s&&!l)return Mn(r)&&n.set(r,yl),yl;if(St(s))for(let c=0;c<s.length;c++){const h=kl(s[c]);D0(h)&&(o[h]=fn)}else if(s)for(const c in s){const h=kl(c);if(D0(h)){const f=s[c],d=o[h]=St(f)||It(f)?{type:f}:Object.assign({},f);if(d){const g=$0(Boolean,d.type),p=$0(String,d.type);d[0]=g>-1,d[1]=p<0||g<p,(g>-1||Dt(d,"default"))&&a.push(h)}}}const u=[o,a];return Mn(r)&&n.set(r,u),u}function D0(r){return r[0]!=="$"}function O0(r){const e=r&&r.toString().match(/^\s*(function|class) (\w+)/);return e?e[2]:r===null?"null":""}function F0(r,e){return O0(r)===O0(e)}function $0(r,e){return St(e)?e.findIndex(t=>F0(t,r)):It(e)&&F0(e,r)?0:-1}const ow=r=>r[0]==="_"||r==="$stable",Og=r=>St(r)?r.map(ji):[ji(r)],sI=(r,e,t)=>{if(e._n)return e;const n=I3((...i)=>Og(e(...i)),t);return n._c=!1,n},aw=(r,e,t)=>{const n=r._ctx;for(const i in r){if(ow(i))continue;const s=r[i];if(It(s))e[i]=sI(i,s,n);else if(s!=null){const o=Og(s);e[i]=()=>o}}},lw=(r,e)=>{const t=Og(e);r.slots.default=()=>t},oI=(r,e)=>{if(r.vnode.shapeFlag&32){const t=e._;t?(r.slots=Bt(e),Bh(e,"_",t)):aw(e,r.slots={})}else r.slots={},e&&lw(r,e);Bh(r.slots,If,1)},aI=(r,e,t)=>{const{vnode:n,slots:i}=r;let s=!0,o=fn;if(n.shapeFlag&32){const a=e._;a?t&&a===1?s=!1:(lr(i,e),!t&&a===1&&delete i._):(s=!e.$stable,aw(e,i)),o=e}else e&&(lw(r,e),o={default:1});if(s)for(const a in i)!ow(a)&&!(a in o)&&delete i[a]};function uw(){return{app:null,config:{isNativeTag:IA,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let lI=0;function uI(r,e){return function(n,i=null){It(n)||(n=Object.assign({},n)),i!=null&&!Mn(i)&&(i=null);const s=uw(),o=new Set;let a=!1;const l=s.app={_uid:lI++,_component:n,_props:i,_container:null,_context:s,_instance:null,version:DI,get config(){return s.config},set config(u){},use(u,...c){return o.has(u)||(u&&It(u.install)?(o.add(u),u.install(l,...c)):It(u)&&(o.add(u),u(l,...c))),l},mixin(u){return s.mixins.includes(u)||s.mixins.push(u),l},component(u,c){return c?(s.components[u]=c,l):s.components[u]},directive(u,c){return c?(s.directives[u]=c,l):s.directives[u]},mount(u,c,h){if(!a){const f=po(n,i);return f.appContext=s,c&&e?e(f,u):r(f,u,h),a=!0,l._container=u,u.__vue_app__=l,$g(f.component)||f.component.proxy}},unmount(){a&&(r(null,l._container),delete l._container.__vue_app__)},provide(u,c){return s.provides[u]=c,l}};return l}}function Vp(r,e,t,n,i=!1){if(St(r)){r.forEach((f,d)=>Vp(f,e&&(St(e)?e[d]:e),t,n,i));return}if(Eh(n)&&!i)return;const s=n.shapeFlag&4?$g(n.component)||n.component.proxy:n.el,o=i?null:s,{i:a,r:l}=r,u=e&&e.r,c=a.refs===fn?a.refs={}:a.refs,h=a.setupState;if(u!=null&&u!==l&&(jn(u)?(c[u]=null,Dt(h,u)&&(h[u]=null)):mr(u)&&(u.value=null)),It(l))fo(l,a,12,[o,c]);else{const f=jn(l),d=mr(l);if(f||d){const g=()=>{if(r.f){const p=f?Dt(h,l)?h[l]:c[l]:l.value;i?St(p)&&xg(p,s):St(p)?p.includes(s)||p.push(s):f?(c[l]=[s],Dt(h,l)&&(h[l]=c[l])):(l.value=[s],r.k&&(c[r.k]=l.value))}else f?(c[l]=o,Dt(h,l)&&(h[l]=o)):d&&(l.value=o,r.k&&(c[r.k]=o))};o?(g.id=-1,Sr(g,t)):g()}}}const Sr=L3;function cI(r){return hI(r)}function hI(r,e){const t=$A();t.__VUE__=!0;const{insert:n,remove:i,patchProp:s,createElement:o,createText:a,createComment:l,setText:u,setElementText:c,parentNode:h,nextSibling:f,setScopeId:d=Oi,insertStaticContent:g}=r,p=(U,j,ae,be=null,de=null,Ee=null,Ae=!1,we=null,ke=!!j.dynamicChildren)=>{if(U===j)return;U&&!Xo(U,j)&&(be=Ve(U),ee(U,de,Ee,!0),U=null),j.patchFlag===-2&&(ke=!1,j.dynamicChildren=null);const{type:Se,ref:L,shapeFlag:N}=j;switch(Se){case Af:m(U,j,ae,be);break;case Ms:_(U,j,ae,be);break;case Mh:U==null&&v(j,ae,be,Ae);break;case Ni:q(U,j,ae,be,de,Ee,Ae,we,ke);break;default:N&1?T(U,j,ae,be,de,Ee,Ae,we,ke):N&6?O(U,j,ae,be,de,Ee,Ae,we,ke):(N&64||N&128)&&Se.process(U,j,ae,be,de,Ee,Ae,we,ke,We)}L!=null&&de&&Vp(L,U&&U.ref,Ee,j||U,!j)},m=(U,j,ae,be)=>{if(U==null)n(j.el=a(j.children),ae,be);else{const de=j.el=U.el;j.children!==U.children&&u(de,j.children)}},_=(U,j,ae,be)=>{U==null?n(j.el=l(j.children||""),ae,be):j.el=U.el},v=(U,j,ae,be)=>{[U.el,U.anchor]=g(U.children,j,ae,be,U.el,U.anchor)},b=({el:U,anchor:j},ae,be)=>{let de;for(;U&&U!==j;)de=f(U),n(U,ae,be),U=de;n(j,ae,be)},x=({el:U,anchor:j})=>{let ae;for(;U&&U!==j;)ae=f(U),i(U),U=ae;i(j)},T=(U,j,ae,be,de,Ee,Ae,we,ke)=>{Ae=Ae||j.type==="svg",U==null?I(j,ae,be,de,Ee,Ae,we,ke):A(U,j,de,Ee,Ae,we,ke)},I=(U,j,ae,be,de,Ee,Ae,we)=>{let ke,Se;const{type:L,props:N,shapeFlag:re,transition:pe,dirs:ge}=U;if(ke=U.el=o(U.type,Ee,N&&N.is,N),re&8?c(ke,U.children):re&16&&S(U.children,ke,null,be,de,Ee&&L!=="foreignObject",Ae,we),ge&&Lo(U,null,be,"created"),C(ke,U,U.scopeId,Ae,be),N){for(const Pe in N)Pe!=="value"&&!Sh(Pe)&&s(ke,Pe,null,N[Pe],Ee,U.children,be,de,Le);"value"in N&&s(ke,"value",null,N.value),(Se=N.onVnodeBeforeMount)&&Vi(Se,be,U)}ge&&Lo(U,null,be,"beforeMount");const Me=(!de||de&&!de.pendingBranch)&&pe&&!pe.persisted;Me&&pe.beforeEnter(ke),n(ke,j,ae),((Se=N&&N.onVnodeMounted)||Me||ge)&&Sr(()=>{Se&&Vi(Se,be,U),Me&&pe.enter(ke),ge&&Lo(U,null,be,"mounted")},de)},C=(U,j,ae,be,de)=>{if(ae&&d(U,ae),be)for(let Ee=0;Ee<be.length;Ee++)d(U,be[Ee]);if(de){let Ee=de.subTree;if(j===Ee){const Ae=de.vnode;C(U,Ae,Ae.scopeId,Ae.slotScopeIds,de.parent)}}},S=(U,j,ae,be,de,Ee,Ae,we,ke=0)=>{for(let Se=ke;Se<U.length;Se++){const L=U[Se]=we?no(U[Se]):ji(U[Se]);p(null,L,j,ae,be,de,Ee,Ae,we)}},A=(U,j,ae,be,de,Ee,Ae)=>{const we=j.el=U.el;let{patchFlag:ke,dynamicChildren:Se,dirs:L}=j;ke|=U.patchFlag&16;const N=U.props||fn,re=j.props||fn;let pe;ae&&Do(ae,!1),(pe=re.onVnodeBeforeUpdate)&&Vi(pe,ae,j,U),L&&Lo(j,U,ae,"beforeUpdate"),ae&&Do(ae,!0);const ge=de&&j.type!=="foreignObject";if(Se?R(U.dynamicChildren,Se,we,ae,be,ge,Ee):Ae||Y(U,j,we,null,ae,be,ge,Ee,!1),ke>0){if(ke&16)F(we,j,N,re,ae,be,de);else if(ke&2&&N.class!==re.class&&s(we,"class",null,re.class,de),ke&4&&s(we,"style",N.style,re.style,de),ke&8){const Me=j.dynamicProps;for(let Pe=0;Pe<Me.length;Pe++){const G=Me[Pe],se=N[G],Be=re[G];(Be!==se||G==="value")&&s(we,G,se,Be,de,U.children,ae,be,Le)}}ke&1&&U.children!==j.children&&c(we,j.children)}else!Ae&&Se==null&&F(we,j,N,re,ae,be,de);((pe=re.onVnodeUpdated)||L)&&Sr(()=>{pe&&Vi(pe,ae,j,U),L&&Lo(j,U,ae,"updated")},be)},R=(U,j,ae,be,de,Ee,Ae)=>{for(let we=0;we<j.length;we++){const ke=U[we],Se=j[we],L=ke.el&&(ke.type===Ni||!Xo(ke,Se)||ke.shapeFlag&70)?h(ke.el):ae;p(ke,Se,L,null,be,de,Ee,Ae,!0)}},F=(U,j,ae,be,de,Ee,Ae)=>{if(ae!==be){if(ae!==fn)for(const we in ae)!Sh(we)&&!(we in be)&&s(U,we,ae[we],null,Ae,j.children,de,Ee,Le);for(const we in be){if(Sh(we))continue;const ke=be[we],Se=ae[we];ke!==Se&&we!=="value"&&s(U,we,Se,ke,Ae,j.children,de,Ee,Le)}"value"in be&&s(U,"value",ae.value,be.value)}},q=(U,j,ae,be,de,Ee,Ae,we,ke)=>{const Se=j.el=U?U.el:a(""),L=j.anchor=U?U.anchor:a("");let{patchFlag:N,dynamicChildren:re,slotScopeIds:pe}=j;pe&&(we=we?we.concat(pe):pe),U==null?(n(Se,ae,be),n(L,ae,be),S(j.children,ae,L,de,Ee,Ae,we,ke)):N>0&&N&64&&re&&U.dynamicChildren?(R(U.dynamicChildren,re,ae,de,Ee,Ae,we),(j.key!=null||de&&j===de.subTree)&&cw(U,j,!0)):Y(U,j,ae,L,de,Ee,Ae,we,ke)},O=(U,j,ae,be,de,Ee,Ae,we,ke)=>{j.slotScopeIds=we,U==null?j.shapeFlag&512?de.ctx.activate(j,ae,be,Ae,ke):z(j,ae,be,de,Ee,Ae,ke):H(U,j,ke)},z=(U,j,ae,be,de,Ee,Ae)=>{const we=U.component=EI(U,be,de);if(Ef(U)&&(we.ctx.renderer=We),AI(we),we.asyncDep){if(de&&de.registerDep(we,Q),!U.el){const ke=we.subTree=po(Ms);_(null,ke,j,ae)}return}Q(we,U,j,ae,de,Ee,Ae)},H=(U,j,ae)=>{const be=j.component=U.component;if(N3(U,j,ae))if(be.asyncDep&&!be.asyncResolved){Z(be,j,ae);return}else be.next=j,T3(be.update),be.update();else j.el=U.el,be.vnode=j},Q=(U,j,ae,be,de,Ee,Ae)=>{const we=()=>{if(U.isMounted){let{next:L,bu:N,u:re,parent:pe,vnode:ge}=U,Me=L,Pe;Do(U,!1),L?(L.el=ge.el,Z(U,L,Ae)):L=ge,N&&dd(N),(Pe=L.props&&L.props.onVnodeBeforeUpdate)&&Vi(Pe,pe,L,ge),Do(U,!0);const G=pd(U),se=U.subTree;U.subTree=G,p(se,G,h(se.el),Ve(se),U,de,Ee),L.el=G.el,Me===null&&R3(U,G.el),re&&Sr(re,de),(Pe=L.props&&L.props.onVnodeUpdated)&&Sr(()=>Vi(Pe,pe,L,ge),de)}else{let L;const{el:N,props:re}=j,{bm:pe,m:ge,parent:Me}=U,Pe=Eh(j);if(Do(U,!1),pe&&dd(pe),!Pe&&(L=re&&re.onVnodeBeforeMount)&&Vi(L,Me,j),Do(U,!0),N&&nt){const G=()=>{U.subTree=pd(U),nt(N,U.subTree,U,de,null)};Pe?j.type.__asyncLoader().then(()=>!U.isUnmounted&&G()):G()}else{const G=U.subTree=pd(U);p(null,G,ae,be,U,de,Ee),j.el=G.el}if(ge&&Sr(ge,de),!Pe&&(L=re&&re.onVnodeMounted)){const G=j;Sr(()=>Vi(L,Me,G),de)}(j.shapeFlag&256||Me&&Eh(Me.vnode)&&Me.vnode.shapeFlag&256)&&U.a&&Sr(U.a,de),U.isMounted=!0,j=ae=be=null}},ke=U.effect=new Tg(we,()=>Pg(Se),U.scope),Se=U.update=()=>ke.run();Se.id=U.uid,Do(U,!0),Se()},Z=(U,j,ae)=>{j.component=U;const be=U.vnode.props;U.vnode=j,U.next=null,iI(U,j.props,be,ae),aI(U,j.children,ae),tu(),k0(),nu()},Y=(U,j,ae,be,de,Ee,Ae,we,ke=!1)=>{const Se=U&&U.children,L=U?U.shapeFlag:0,N=j.children,{patchFlag:re,shapeFlag:pe}=j;if(re>0){if(re&128){le(Se,N,ae,be,de,Ee,Ae,we,ke);return}else if(re&256){fe(Se,N,ae,be,de,Ee,Ae,we,ke);return}}pe&8?(L&16&&Le(Se,de,Ee),N!==Se&&c(ae,N)):L&16?pe&16?le(Se,N,ae,be,de,Ee,Ae,we,ke):Le(Se,de,Ee,!0):(L&8&&c(ae,""),pe&16&&S(N,ae,be,de,Ee,Ae,we,ke))},fe=(U,j,ae,be,de,Ee,Ae,we,ke)=>{U=U||yl,j=j||yl;const Se=U.length,L=j.length,N=Math.min(Se,L);let re;for(re=0;re<N;re++){const pe=j[re]=ke?no(j[re]):ji(j[re]);p(U[re],pe,ae,null,de,Ee,Ae,we,ke)}Se>L?Le(U,de,Ee,!0,!1,N):S(j,ae,be,de,Ee,Ae,we,ke,N)},le=(U,j,ae,be,de,Ee,Ae,we,ke)=>{let Se=0;const L=j.length;let N=U.length-1,re=L-1;for(;Se<=N&&Se<=re;){const pe=U[Se],ge=j[Se]=ke?no(j[Se]):ji(j[Se]);if(Xo(pe,ge))p(pe,ge,ae,null,de,Ee,Ae,we,ke);else break;Se++}for(;Se<=N&&Se<=re;){const pe=U[N],ge=j[re]=ke?no(j[re]):ji(j[re]);if(Xo(pe,ge))p(pe,ge,ae,null,de,Ee,Ae,we,ke);else break;N--,re--}if(Se>N){if(Se<=re){const pe=re+1,ge=pe<L?j[pe].el:be;for(;Se<=re;)p(null,j[Se]=ke?no(j[Se]):ji(j[Se]),ae,ge,de,Ee,Ae,we,ke),Se++}}else if(Se>re)for(;Se<=N;)ee(U[Se],de,Ee,!0),Se++;else{const pe=Se,ge=Se,Me=new Map;for(Se=ge;Se<=re;Se++){const Ue=j[Se]=ke?no(j[Se]):ji(j[Se]);Ue.key!=null&&Me.set(Ue.key,Se)}let Pe,G=0;const se=re-ge+1;let Be=!1,De=0;const je=new Array(se);for(Se=0;Se<se;Se++)je[Se]=0;for(Se=pe;Se<=N;Se++){const Ue=U[Se];if(G>=se){ee(Ue,de,Ee,!0);continue}let ot;if(Ue.key!=null)ot=Me.get(Ue.key);else for(Pe=ge;Pe<=re;Pe++)if(je[Pe-ge]===0&&Xo(Ue,j[Pe])){ot=Pe;break}ot===void 0?ee(Ue,de,Ee,!0):(je[ot-ge]=Se+1,ot>=De?De=ot:Be=!0,p(Ue,j[ot],ae,null,de,Ee,Ae,we,ke),G++)}const Xe=Be?fI(je):yl;for(Pe=Xe.length-1,Se=se-1;Se>=0;Se--){const Ue=ge+Se,ot=j[Ue],xt=Ue+1<L?j[Ue+1].el:be;je[Se]===0?p(null,ot,ae,xt,de,Ee,Ae,we,ke):Be&&(Pe<0||Se!==Xe[Pe]?ve(ot,ae,xt,2):Pe--)}}},ve=(U,j,ae,be,de=null)=>{const{el:Ee,type:Ae,transition:we,children:ke,shapeFlag:Se}=U;if(Se&6){ve(U.component.subTree,j,ae,be);return}if(Se&128){U.suspense.move(j,ae,be);return}if(Se&64){Ae.move(U,j,ae,We);return}if(Ae===Ni){n(Ee,j,ae);for(let N=0;N<ke.length;N++)ve(ke[N],j,ae,be);n(U.anchor,j,ae);return}if(Ae===Mh){b(U,j,ae);return}if(be!==2&&Se&1&&we)if(be===0)we.beforeEnter(Ee),n(Ee,j,ae),Sr(()=>we.enter(Ee),de);else{const{leave:N,delayLeave:re,afterLeave:pe}=we,ge=()=>n(Ee,j,ae),Me=()=>{N(Ee,()=>{ge(),pe&&pe()})};re?re(Ee,ge,Me):Me()}else n(Ee,j,ae)},ee=(U,j,ae,be=!1,de=!1)=>{const{type:Ee,props:Ae,ref:we,children:ke,dynamicChildren:Se,shapeFlag:L,patchFlag:N,dirs:re}=U;if(we!=null&&Vp(we,null,ae,U,!0),L&256){j.ctx.deactivate(U);return}const pe=L&1&&re,ge=!Eh(U);let Me;if(ge&&(Me=Ae&&Ae.onVnodeBeforeUnmount)&&Vi(Me,j,U),L&6)ne(U.component,ae,be);else{if(L&128){U.suspense.unmount(ae,be);return}pe&&Lo(U,null,j,"beforeUnmount"),L&64?U.type.remove(U,j,ae,de,We,be):Se&&(Ee!==Ni||N>0&&N&64)?Le(Se,j,ae,!1,!0):(Ee===Ni&&N&384||!de&&L&16)&&Le(ke,j,ae),be&&_e(U)}(ge&&(Me=Ae&&Ae.onVnodeUnmounted)||pe)&&Sr(()=>{Me&&Vi(Me,j,U),pe&&Lo(U,null,j,"unmounted")},ae)},_e=U=>{const{type:j,el:ae,anchor:be,transition:de}=U;if(j===Ni){Te(ae,be);return}if(j===Mh){x(U);return}const Ee=()=>{i(ae),de&&!de.persisted&&de.afterLeave&&de.afterLeave()};if(U.shapeFlag&1&&de&&!de.persisted){const{leave:Ae,delayLeave:we}=de,ke=()=>Ae(ae,Ee);we?we(U.el,Ee,ke):ke()}else Ee()},Te=(U,j)=>{let ae;for(;U!==j;)ae=f(U),i(U),U=ae;i(j)},ne=(U,j,ae)=>{const{bum:be,scope:de,update:Ee,subTree:Ae,um:we}=U;be&&dd(be),de.stop(),Ee&&(Ee.active=!1,ee(Ae,U,j,ae)),we&&Sr(we,j),Sr(()=>{U.isUnmounted=!0},j),j&&j.pendingBranch&&!j.isUnmounted&&U.asyncDep&&!U.asyncResolved&&U.suspenseId===j.pendingId&&(j.deps--,j.deps===0&&j.resolve())},Le=(U,j,ae,be=!1,de=!1,Ee=0)=>{for(let Ae=Ee;Ae<U.length;Ae++)ee(U[Ae],j,ae,be,de)},Ve=U=>U.shapeFlag&6?Ve(U.component.subTree):U.shapeFlag&128?U.suspense.next():f(U.anchor||U.el),He=(U,j,ae)=>{U==null?j._vnode&&ee(j._vnode,null,null,!0):p(j._vnode||null,U,j,null,null,null,ae),k0(),jv(),j._vnode=U},We={p,um:ee,m:ve,r:_e,mt:z,mc:S,pc:Y,pbc:R,n:Ve,o:r};let Je,nt;return e&&([Je,nt]=e(We)),{render:He,hydrate:Je,createApp:uI(He,Je)}}function Do({effect:r,update:e},t){r.allowRecurse=e.allowRecurse=t}function cw(r,e,t=!1){const n=r.children,i=e.children;if(St(n)&&St(i))for(let s=0;s<n.length;s++){const o=n[s];let a=i[s];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=i[s]=no(i[s]),a.el=o.el),t||cw(o,a)),a.type===Af&&(a.el=o.el)}}function fI(r){const e=r.slice(),t=[0];let n,i,s,o,a;const l=r.length;for(n=0;n<l;n++){const u=r[n];if(u!==0){if(i=t[t.length-1],r[i]<u){e[n]=i,t.push(n);continue}for(s=0,o=t.length-1;s<o;)a=s+o>>1,r[t[a]]<u?s=a+1:o=a;u<r[t[s]]&&(s>0&&(e[n]=t[s-1]),t[s]=n)}}for(s=t.length,o=t[s-1];s-- >0;)t[s]=o,o=e[o];return t}const dI=r=>r.__isTeleport,Ni=Symbol(void 0),Af=Symbol(void 0),Ms=Symbol(void 0),Mh=Symbol(void 0),qu=[];let Di=null;function pI(r=!1){qu.push(Di=r?null:[])}function mI(){qu.pop(),Di=qu[qu.length-1]||null}let sc=1;function z0(r){sc+=r}function gI(r){return r.dynamicChildren=sc>0?Di||yl:null,mI(),sc>0&&Di&&Di.push(r),r}function yI(r,e,t,n,i,s){return gI(fw(r,e,t,n,i,s,!0))}function _I(r){return r?r.__v_isVNode===!0:!1}function Xo(r,e){return r.type===e.type&&r.key===e.key}const If="__vInternal",hw=({key:r})=>r??null,Ah=({ref:r,ref_key:e,ref_for:t})=>r!=null?jn(r)||mr(r)||It(r)?{i:Li,r,k:e,f:!!t}:r:null;function fw(r,e=null,t=null,n=0,i=null,s=r===Ni?0:1,o=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:r,props:e,key:e&&hw(e),ref:e&&Ah(e),scopeId:Xv,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:n,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:Li};return a?(Fg(l,t),s&128&&r.normalize(l)):t&&(l.shapeFlag|=jn(t)?8:16),sc>0&&!o&&Di&&(l.patchFlag>0||s&6)&&l.patchFlag!==32&&Di.push(l),l}const po=bI;function bI(r,e=null,t=null,n=0,i=null,s=!1){if((!r||r===Y3)&&(r=Ms),_I(r)){const a=wo(r,e,!0);return t&&Fg(a,t),sc>0&&!s&&Di&&(a.shapeFlag&6?Di[Di.indexOf(r)]=a:Di.push(a)),a.patchFlag|=-2,a}if(NI(r)&&(r=r.__vccOpts),e){e=xI(e);let{class:a,style:l}=e;a&&!jn(a)&&(e.class=_g(a)),Mn(l)&&(Bv(l)&&!St(l)&&(l=lr({},l)),e.style=yg(l))}const o=jn(r)?1:P3(r)?128:dI(r)?64:Mn(r)?4:It(r)?2:0;return fw(r,e,t,n,i,o,s,!0)}function xI(r){return r?Bv(r)||If in r?lr({},r):r:null}function wo(r,e,t=!1){const{props:n,ref:i,patchFlag:s,children:o}=r,a=e?wI(n||{},e):n;return{__v_isVNode:!0,__v_skip:!0,type:r.type,props:a,key:a&&hw(a),ref:e&&e.ref?t&&i?St(i)?i.concat(Ah(e)):[i,Ah(e)]:Ah(e):i,scopeId:r.scopeId,slotScopeIds:r.slotScopeIds,children:o,target:r.target,targetAnchor:r.targetAnchor,staticCount:r.staticCount,shapeFlag:r.shapeFlag,patchFlag:e&&r.type!==Ni?s===-1?16:s|16:s,dynamicProps:r.dynamicProps,dynamicChildren:r.dynamicChildren,appContext:r.appContext,dirs:r.dirs,transition:r.transition,component:r.component,suspense:r.suspense,ssContent:r.ssContent&&wo(r.ssContent),ssFallback:r.ssFallback&&wo(r.ssFallback),el:r.el,anchor:r.anchor,ctx:r.ctx,ce:r.ce}}function dw(r=" ",e=0){return po(Af,null,r,e)}function vI(r,e){const t=po(Mh,null,r);return t.staticCount=e,t}function ji(r){return r==null||typeof r=="boolean"?po(Ms):St(r)?po(Ni,null,r.slice()):typeof r=="object"?no(r):po(Af,null,String(r))}function no(r){return r.el===null&&r.patchFlag!==-1||r.memo?r:wo(r)}function Fg(r,e){let t=0;const{shapeFlag:n}=r;if(e==null)e=null;else if(St(e))t=16;else if(typeof e=="object")if(n&65){const i=e.default;i&&(i._c&&(i._d=!1),Fg(r,i()),i._c&&(i._d=!0));return}else{t=32;const i=e._;!i&&!(If in e)?e._ctx=Li:i===3&&Li&&(Li.slots._===1?e._=1:(e._=2,r.patchFlag|=1024))}else It(e)?(e={default:e,_ctx:Li},t=32):(e=String(e),n&64?(t=16,e=[dw(e)]):t=8);r.children=e,r.shapeFlag|=t}function wI(...r){const e={};for(let t=0;t<r.length;t++){const n=r[t];for(const i in n)if(i==="class")e.class!==n.class&&(e.class=_g([e.class,n.class]));else if(i==="style")e.style=yg([e.style,n.style]);else if(bf(i)){const s=e[i],o=n[i];o&&s!==o&&!(St(s)&&s.includes(o))&&(e[i]=s?[].concat(s,o):o)}else i!==""&&(e[i]=n[i])}return e}function Vi(r,e,t,n=null){bi(r,e,7,[t,n])}const SI=uw();let TI=0;function EI(r,e,t){const n=r.type,i=(e?e.appContext:r.appContext)||SI,s={uid:TI++,vnode:r,type:n,parent:e,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new zA(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:sw(n,i),emitsOptions:Kv(n,i),emit:null,emitted:null,propsDefaults:fn,inheritAttrs:n.inheritAttrs,ctx:fn,data:fn,props:fn,attrs:fn,slots:fn,refs:fn,setupState:fn,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return s.ctx={_:s},s.root=e?e.root:s,s.emit=A3.bind(null,s),r.ce&&r.ce(s),s}let En=null;const MI=()=>En||Li,Nl=r=>{En=r,r.scope.on()},ua=()=>{En&&En.scope.off(),En=null};function pw(r){return r.vnode.shapeFlag&4}let oc=!1;function AI(r,e=!1){oc=e;const{props:t,children:n}=r.vnode,i=pw(r);rI(r,t,i,e),oI(r,n);const s=i?II(r,e):void 0;return oc=!1,s}function II(r,e){const t=r.type;r.accessCache=Object.create(null),r.proxy=Uv(new Proxy(r.ctx,Z3));const{setup:n}=t;if(n){const i=r.setupContext=n.length>1?kI(r):null;Nl(r),tu();const s=fo(n,r,0,[r.props,i]);if(nu(),ua(),Av(s)){if(s.then(ua,ua),e)return s.then(o=>{B0(r,o,e)}).catch(o=>{Sf(o,r,0)});r.asyncDep=s}else B0(r,s,e)}else mw(r,e)}function B0(r,e,t){It(e)?r.type.__ssrInlineRender?r.ssrRender=e:r.render=e:Mn(e)&&(r.setupState=Vv(e)),mw(r,t)}let U0;function mw(r,e,t){const n=r.type;if(!r.render){if(!e&&U0&&!n.render){const i=n.template||Dg(r).template;if(i){const{isCustomElement:s,compilerOptions:o}=r.appContext.config,{delimiters:a,compilerOptions:l}=n,u=lr(lr({isCustomElement:s,delimiters:a},o),l);n.render=U0(i,u)}}r.render=n.render||Oi}Nl(r),tu(),Q3(r),nu(),ua()}function CI(r){return new Proxy(r.attrs,{get(e,t){return Nr(r,"get","$attrs"),e[t]}})}function kI(r){const e=n=>{r.exposed=n||{}};let t;return{get attrs(){return t||(t=CI(r))},slots:r.slots,emit:r.emit,expose:e}}function $g(r){if(r.exposed)return r.exposeProxy||(r.exposeProxy=new Proxy(Vv(Uv(r.exposed)),{get(e,t){if(t in e)return e[t];if(t in ju)return ju[t](r)},has(e,t){return t in e||t in ju}}))}function NI(r){return It(r)&&"__vccOpts"in r}const RI=(r,e)=>x3(r,e,oc),PI=Symbol(""),LI=()=>Th(PI),DI="3.2.47",OI="http://www.w3.org/2000/svg",Yo=typeof document<"u"?document:null,V0=Yo&&Yo.createElement("template"),FI={insert:(r,e,t)=>{e.insertBefore(r,t||null)},remove:r=>{const e=r.parentNode;e&&e.removeChild(r)},createElement:(r,e,t,n)=>{const i=e?Yo.createElementNS(OI,r):Yo.createElement(r,t?{is:t}:void 0);return r==="select"&&n&&n.multiple!=null&&i.setAttribute("multiple",n.multiple),i},createText:r=>Yo.createTextNode(r),createComment:r=>Yo.createComment(r),setText:(r,e)=>{r.nodeValue=e},setElementText:(r,e)=>{r.textContent=e},parentNode:r=>r.parentNode,nextSibling:r=>r.nextSibling,querySelector:r=>Yo.querySelector(r),setScopeId(r,e){r.setAttribute(e,"")},insertStaticContent(r,e,t,n,i,s){const o=t?t.previousSibling:e.lastChild;if(i&&(i===s||i.nextSibling))for(;e.insertBefore(i.cloneNode(!0),t),!(i===s||!(i=i.nextSibling)););else{V0.innerHTML=n?`<svg>${r}</svg>`:r;const a=V0.content;if(n){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}e.insertBefore(a,t)}return[o?o.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}};function $I(r,e,t){const n=r._vtc;n&&(e=(e?[e,...n]:[...n]).join(" ")),e==null?r.removeAttribute("class"):t?r.setAttribute("class",e):r.className=e}function zI(r,e,t){const n=r.style,i=jn(t);if(t&&!i){if(e&&!jn(e))for(const s in e)t[s]==null&&Wp(n,s,"");for(const s in t)Wp(n,s,t[s])}else{const s=n.display;i?e!==t&&(n.cssText=t):e&&r.removeAttribute("style"),"_vod"in r&&(n.display=s)}}const W0=/\s*!important$/;function Wp(r,e,t){if(St(t))t.forEach(n=>Wp(r,e,n));else if(t==null&&(t=""),e.startsWith("--"))r.setProperty(e,t);else{const n=BI(r,e);W0.test(t)?r.setProperty(eu(n),t.replace(W0,""),"important"):r[n]=t}}const G0=["Webkit","Moz","ms"],_d={};function BI(r,e){const t=_d[e];if(t)return t;let n=kl(e);if(n!=="filter"&&n in r)return _d[e]=n;n=Iv(n);for(let i=0;i<G0.length;i++){const s=G0[i]+n;if(s in r)return _d[e]=s}return e}const H0="http://www.w3.org/1999/xlink";function UI(r,e,t,n,i){if(n&&e.startsWith("xlink:"))t==null?r.removeAttributeNS(H0,e.slice(6,e.length)):r.setAttributeNS(H0,e,t);else{const s=AA(e);t==null||s&&!Mv(t)?r.removeAttribute(e):r.setAttribute(e,s?"":t)}}function VI(r,e,t,n,i,s,o){if(e==="innerHTML"||e==="textContent"){n&&o(n,i,s),r[e]=t??"";return}if(e==="value"&&r.tagName!=="PROGRESS"&&!r.tagName.includes("-")){r._value=t;const l=t??"";(r.value!==l||r.tagName==="OPTION")&&(r.value=l),t==null&&r.removeAttribute(e);return}let a=!1;if(t===""||t==null){const l=typeof r[e];l==="boolean"?t=Mv(t):t==null&&l==="string"?(t="",a=!0):l==="number"&&(t=0,a=!0)}try{r[e]=t}catch{}a&&r.removeAttribute(e)}function WI(r,e,t,n){r.addEventListener(e,t,n)}function GI(r,e,t,n){r.removeEventListener(e,t,n)}function HI(r,e,t,n,i=null){const s=r._vei||(r._vei={}),o=s[e];if(n&&o)o.value=n;else{const[a,l]=jI(e);if(n){const u=s[e]=XI(n,i);WI(r,a,u,l)}else o&&(GI(r,a,o,l),s[e]=void 0)}}const j0=/(?:Once|Passive|Capture)$/;function jI(r){let e;if(j0.test(r)){e={};let n;for(;n=r.match(j0);)r=r.slice(0,r.length-n[0].length),e[n[0].toLowerCase()]=!0}return[r[2]===":"?r.slice(3):eu(r.slice(2)),e]}let bd=0;const qI=Promise.resolve(),KI=()=>bd||(qI.then(()=>bd=0),bd=Date.now());function XI(r,e){const t=n=>{if(!n._vts)n._vts=Date.now();else if(n._vts<=t.attached)return;bi(YI(n,t.value),e,5,[n])};return t.value=r,t.attached=KI(),t}function YI(r,e){if(St(e)){const t=r.stopImmediatePropagation;return r.stopImmediatePropagation=()=>{t.call(r),r._stopped=!0},e.map(n=>i=>!i._stopped&&n&&n(i))}else return e}const q0=/^on[a-z]/,ZI=(r,e,t,n,i=!1,s,o,a,l)=>{e==="class"?$I(r,n,i):e==="style"?zI(r,t,n):bf(e)?bg(e)||HI(r,e,t,n,o):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):QI(r,e,n,i))?VI(r,e,n,s,o,a,l):(e==="true-value"?r._trueValue=n:e==="false-value"&&(r._falseValue=n),UI(r,e,n,i))};function QI(r,e,t,n){return n?!!(e==="innerHTML"||e==="textContent"||e in r&&q0.test(e)&&It(t)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&r.tagName==="INPUT"||e==="type"&&r.tagName==="TEXTAREA"||q0.test(e)&&jn(t)?!1:e in r}const JI={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};z3.props;const eC=lr({patchProp:ZI},FI);let K0;function tC(){return K0||(K0=cI(eC))}const nC=(...r)=>{const e=tC().createApp(...r),{mount:t}=e;return e.mount=n=>{const i=rC(n);if(!i)return;const s=e._component;!It(s)&&!s.render&&!s.template&&(s.template=i.innerHTML),i.innerHTML="";const o=t(i,!1,i instanceof SVGElement);return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),o},e};function rC(r){return jn(r)?document.querySelector(r):r}/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const zg="150",Wa={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Ga={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},iC=0,X0=1,sC=2,gw=1,oC=2,Ou=3,Rs=0,Vr=1,ws=2,mo=0,xl=1,Y0=2,Z0=3,Q0=4,aC=5,ll=100,lC=101,uC=102,J0=103,e_=104,cC=200,hC=201,fC=202,dC=203,yw=204,_w=205,pC=206,mC=207,gC=208,yC=209,_C=210,bC=0,xC=1,vC=2,Gp=3,wC=4,SC=5,TC=6,EC=7,bw=0,MC=1,AC=2,As=0,IC=1,CC=2,kC=3,NC=4,RC=5,xw=300,Rl=301,Pl=302,Hp=303,jp=304,Cf=306,Ll=1e3,hi=1001,Wh=1002,Fn=1003,qp=1004,Ih=1005,Er=1006,vw=1007,ya=1008,_a=1009,PC=1010,LC=1011,ww=1012,DC=1013,ea=1014,io=1015,ac=1016,OC=1017,FC=1018,vl=1020,$C=1021,fi=1023,zC=1024,BC=1025,ca=1026,Dl=1027,UC=1028,VC=1029,WC=1030,GC=1031,HC=1033,xd=33776,vd=33777,wd=33778,Sd=33779,t_=35840,n_=35841,r_=35842,i_=35843,jC=36196,s_=37492,o_=37496,a_=37808,l_=37809,u_=37810,c_=37811,h_=37812,f_=37813,d_=37814,p_=37815,m_=37816,g_=37817,y_=37818,__=37819,b_=37820,x_=37821,Td=36492,qC=36283,v_=36284,w_=36285,S_=36286,lc=2300,Ol=2301,Ed=2302,T_=2400,E_=2401,M_=2402,KC=2500,XC=0,Sw=1,Kp=2,ba=3e3,$t=3001,YC=3200,ZC=3201,Tw=0,QC=1,Hi="srgb",uc="srgb-linear",Ew="display-p3",Md=7680,JC=519,Xp=35044,A_="300 es",Yp=1035;class Ra{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,o=i.length;s<o;s++)i[s].call(this,e);e.target=null}}}const Xn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let I_=1234567;const Ku=Math.PI/180,cc=180/Math.PI;function Fi(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Xn[r&255]+Xn[r>>8&255]+Xn[r>>16&255]+Xn[r>>24&255]+"-"+Xn[e&255]+Xn[e>>8&255]+"-"+Xn[e>>16&15|64]+Xn[e>>24&255]+"-"+Xn[t&63|128]+Xn[t>>8&255]+"-"+Xn[t>>16&255]+Xn[t>>24&255]+Xn[n&255]+Xn[n>>8&255]+Xn[n>>16&255]+Xn[n>>24&255]).toLowerCase()}function Jn(r,e,t){return Math.max(e,Math.min(t,r))}function Bg(r,e){return(r%e+e)%e}function ek(r,e,t,n,i){return n+(r-e)*(i-n)/(t-e)}function tk(r,e,t){return r!==e?(t-r)/(e-r):0}function Xu(r,e,t){return(1-t)*r+t*e}function nk(r,e,t,n){return Xu(r,e,1-Math.exp(-t*n))}function rk(r,e=1){return e-Math.abs(Bg(r,e*2)-e)}function ik(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function sk(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function ok(r,e){return r+Math.floor(Math.random()*(e-r+1))}function ak(r,e){return r+Math.random()*(e-r)}function lk(r){return r*(.5-Math.random())}function uk(r){r!==void 0&&(I_=r);let e=I_+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function ck(r){return r*Ku}function hk(r){return r*cc}function Zp(r){return(r&r-1)===0&&r!==0}function Mw(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function Aw(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function fk(r,e,t,n,i){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),u=s((e+n)/2),c=o((e+n)/2),h=s((e-n)/2),f=o((e-n)/2),d=s((n-e)/2),g=o((n-e)/2);switch(i){case"XYX":r.set(a*c,l*h,l*f,a*u);break;case"YZY":r.set(l*f,a*c,l*h,a*u);break;case"ZXZ":r.set(l*h,l*f,a*c,a*u);break;case"XZX":r.set(a*c,l*g,l*d,a*u);break;case"YXY":r.set(l*d,a*c,l*g,a*u);break;case"ZYZ":r.set(l*g,l*d,a*c,a*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Ss(r,e){switch(e.constructor){case Float32Array:return r;case Uint16Array:return r/65535;case Uint8Array:return r/255;case Int16Array:return Math.max(r/32767,-1);case Int8Array:return Math.max(r/127,-1);default:throw new Error("Invalid component type.")}}function qt(r,e){switch(e.constructor){case Float32Array:return r;case Uint16Array:return Math.round(r*65535);case Uint8Array:return Math.round(r*255);case Int16Array:return Math.round(r*32767);case Int8Array:return Math.round(r*127);default:throw new Error("Invalid component type.")}}const dk={DEG2RAD:Ku,RAD2DEG:cc,generateUUID:Fi,clamp:Jn,euclideanModulo:Bg,mapLinear:ek,inverseLerp:tk,lerp:Xu,damp:nk,pingpong:rk,smoothstep:ik,smootherstep:sk,randInt:ok,randFloat:ak,randFloatSpread:lk,seededRandom:uk,degToRad:ck,radToDeg:hk,isPowerOfTwo:Zp,ceilPowerOfTwo:Mw,floorPowerOfTwo:Aw,setQuaternionFromProperEuler:fk,normalize:qt,denormalize:Ss};class mt{constructor(e=0,t=0){mt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*n-o*i+e.x,this.y=s*i+o*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class gr{constructor(){gr.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,n,i,s,o,a,l,u){const c=this.elements;return c[0]=e,c[1]=i,c[2]=a,c[3]=t,c[4]=s,c[5]=l,c[6]=n,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[3],l=n[6],u=n[1],c=n[4],h=n[7],f=n[2],d=n[5],g=n[8],p=i[0],m=i[3],_=i[6],v=i[1],b=i[4],x=i[7],T=i[2],I=i[5],C=i[8];return s[0]=o*p+a*v+l*T,s[3]=o*m+a*b+l*I,s[6]=o*_+a*x+l*C,s[1]=u*p+c*v+h*T,s[4]=u*m+c*b+h*I,s[7]=u*_+c*x+h*C,s[2]=f*p+d*v+g*T,s[5]=f*m+d*b+g*I,s[8]=f*_+d*x+g*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8];return t*o*c-t*a*u-n*s*c+n*a*l+i*s*u-i*o*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=c*o-a*u,f=a*l-c*s,d=u*s-o*l,g=t*h+n*f+i*d;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const p=1/g;return e[0]=h*p,e[1]=(i*u-c*n)*p,e[2]=(a*n-i*o)*p,e[3]=f*p,e[4]=(c*t-i*l)*p,e[5]=(i*s-a*t)*p,e[6]=d*p,e[7]=(n*l-u*t)*p,e[8]=(o*t-n*s)*p,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,s,o,a){const l=Math.cos(s),u=Math.sin(s);return this.set(n*l,n*u,-n*(l*o+u*a)+o+e,-i*u,i*l,-i*(-u*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(Ad.makeScale(e,t)),this}rotate(e){return this.premultiply(Ad.makeRotation(-e)),this}translate(e,t){return this.premultiply(Ad.makeTranslation(e,t)),this}makeTranslation(e,t){return this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Ad=new gr;function Iw(r){for(let e=r.length-1;e>=0;--e)if(r[e]>=65535)return!0;return!1}function hc(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}class rs{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,s,o,a){let l=n[i+0],u=n[i+1],c=n[i+2],h=n[i+3];const f=s[o+0],d=s[o+1],g=s[o+2],p=s[o+3];if(a===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h;return}if(a===1){e[t+0]=f,e[t+1]=d,e[t+2]=g,e[t+3]=p;return}if(h!==p||l!==f||u!==d||c!==g){let m=1-a;const _=l*f+u*d+c*g+h*p,v=_>=0?1:-1,b=1-_*_;if(b>Number.EPSILON){const T=Math.sqrt(b),I=Math.atan2(T,_*v);m=Math.sin(m*I)/T,a=Math.sin(a*I)/T}const x=a*v;if(l=l*m+f*x,u=u*m+d*x,c=c*m+g*x,h=h*m+p*x,m===1-a){const T=1/Math.sqrt(l*l+u*u+c*c+h*h);l*=T,u*=T,c*=T,h*=T}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,i,s,o){const a=n[i],l=n[i+1],u=n[i+2],c=n[i+3],h=s[o],f=s[o+1],d=s[o+2],g=s[o+3];return e[t]=a*g+c*h+l*d-u*f,e[t+1]=l*g+c*f+u*h-a*d,e[t+2]=u*g+c*d+a*f-l*h,e[t+3]=c*g-a*h-l*f-u*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const n=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,u=a(n/2),c=a(i/2),h=a(s/2),f=l(n/2),d=l(i/2),g=l(s/2);switch(o){case"XYZ":this._x=f*c*h+u*d*g,this._y=u*d*h-f*c*g,this._z=u*c*g+f*d*h,this._w=u*c*h-f*d*g;break;case"YXZ":this._x=f*c*h+u*d*g,this._y=u*d*h-f*c*g,this._z=u*c*g-f*d*h,this._w=u*c*h+f*d*g;break;case"ZXY":this._x=f*c*h-u*d*g,this._y=u*d*h+f*c*g,this._z=u*c*g+f*d*h,this._w=u*c*h-f*d*g;break;case"ZYX":this._x=f*c*h-u*d*g,this._y=u*d*h+f*c*g,this._z=u*c*g-f*d*h,this._w=u*c*h+f*d*g;break;case"YZX":this._x=f*c*h+u*d*g,this._y=u*d*h+f*c*g,this._z=u*c*g-f*d*h,this._w=u*c*h-f*d*g;break;case"XZY":this._x=f*c*h-u*d*g,this._y=u*d*h-f*c*g,this._z=u*c*g+f*d*h,this._w=u*c*h+f*d*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],s=t[8],o=t[1],a=t[5],l=t[9],u=t[2],c=t[6],h=t[10],f=n+a+h;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(c-l)*d,this._y=(s-u)*d,this._z=(o-i)*d}else if(n>a&&n>h){const d=2*Math.sqrt(1+n-a-h);this._w=(c-l)/d,this._x=.25*d,this._y=(i+o)/d,this._z=(s+u)/d}else if(a>h){const d=2*Math.sqrt(1+a-n-h);this._w=(s-u)/d,this._x=(i+o)/d,this._y=.25*d,this._z=(l+c)/d}else{const d=2*Math.sqrt(1+h-n-a);this._w=(o-i)/d,this._x=(s+u)/d,this._y=(l+c)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Jn(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,s=e._z,o=e._w,a=t._x,l=t._y,u=t._z,c=t._w;return this._x=n*c+o*a+i*u-s*l,this._y=i*c+o*l+s*a-n*u,this._z=s*c+o*u+n*l-i*a,this._w=o*c-n*a-i*l-s*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+n*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=n,this._y=i,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*n+t*this._x,this._y=d*i+t*this._y,this._z=d*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const u=Math.sqrt(l),c=Math.atan2(u,a),h=Math.sin((1-t)*c)/u,f=Math.sin(t*c)/u;return this._w=o*h+this._w*f,this._x=n*h+this._x*f,this._y=i*h+this._y*f,this._z=s*h+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(s),n*Math.cos(s),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ie{constructor(e=0,t=0,n=0){ie.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(C_.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(C_.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*i,this.y=s[1]*t+s[4]*n+s[7]*i,this.z=s[2]*t+s[5]*n+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=e.elements,o=1/(s[3]*t+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*i+s[12])*o,this.y=(s[1]*t+s[5]*n+s[9]*i+s[13])*o,this.z=(s[2]*t+s[6]*n+s[10]*i+s[14])*o,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,s=e.x,o=e.y,a=e.z,l=e.w,u=l*t+o*i-a*n,c=l*n+a*t-s*i,h=l*i+s*n-o*t,f=-s*t-o*n-a*i;return this.x=u*l+f*-s+c*-a-h*-o,this.y=c*l+f*-o+h*-s-u*-a,this.z=h*l+f*-a+u*-o-c*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i,this.y=s[1]*t+s[5]*n+s[9]*i,this.z=s[2]*t+s[6]*n+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-s*a,this.y=s*o-n*l,this.z=n*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Id.copy(this).projectOnVector(e),this.sub(Id)}reflect(e){return this.sub(Id.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Jn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Id=new ie,C_=new rs;function wl(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function Cd(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}const pk=new gr().fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-1e-7,1e-7,.9105199]),mk=new gr().fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]),so=new ie;function gk(r){return r.convertSRGBToLinear(),so.set(r.r,r.g,r.b).applyMatrix3(mk),r.setRGB(so.x,so.y,so.z)}function yk(r){return so.set(r.r,r.g,r.b).applyMatrix3(pk),r.setRGB(so.x,so.y,so.z).convertLinearToSRGB()}const _k={[uc]:r=>r,[Hi]:r=>r.convertSRGBToLinear(),[Ew]:gk},bk={[uc]:r=>r,[Hi]:r=>r.convertLinearToSRGB(),[Ew]:yk},ur={enabled:!1,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(r){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!r},get workingColorSpace(){return uc},set workingColorSpace(r){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(r,e,t){if(this.enabled===!1||e===t||!e||!t)return r;const n=_k[e],i=bk[t];if(n===void 0||i===void 0)throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);return i(n(r))},fromWorkingColorSpace:function(r,e){return this.convert(r,this.workingColorSpace,e)},toWorkingColorSpace:function(r,e){return this.convert(r,e,this.workingColorSpace)}};let Ha;class Cw{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Ha===void 0&&(Ha=hc("canvas")),Ha.width=e.width,Ha.height=e.height;const n=Ha.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Ha}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=hc("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),s=i.data;for(let o=0;o<s.length;o++)s[o]=wl(s[o]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(wl(t[n]/255)*255):t[n]=wl(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class kw{constructor(e=null){this.isSource=!0,this.uuid=Fi(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?s.push(kd(i[o].image)):s.push(kd(i[o]))}else s=kd(i);n.url=s}return t||(e.images[this.uuid]=n),n}}function kd(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?Cw.getDataURL(r):r.data?{data:Array.from(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let xk=0;class Hn extends Ra{constructor(e=Hn.DEFAULT_IMAGE,t=Hn.DEFAULT_MAPPING,n=hi,i=hi,s=Er,o=ya,a=fi,l=_a,u=Hn.DEFAULT_ANISOTROPY,c=ba){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:xk++}),this.uuid=Fi(),this.name="",this.source=new kw(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=l,this.offset=new mt(0,0),this.repeat=new mt(1,1),this.center=new mt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new gr,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==xw)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ll:e.x=e.x-Math.floor(e.x);break;case hi:e.x=e.x<0?0:1;break;case Wh:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Ll:e.y=e.y-Math.floor(e.y);break;case hi:e.y=e.y<0?0:1;break;case Wh:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}Hn.DEFAULT_IMAGE=null;Hn.DEFAULT_MAPPING=xw;Hn.DEFAULT_ANISOTROPY=1;class Yt{constructor(e=0,t=0,n=0,i=1){Yt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*i+o[12]*s,this.y=o[1]*t+o[5]*n+o[9]*i+o[13]*s,this.z=o[2]*t+o[6]*n+o[10]*i+o[14]*s,this.w=o[3]*t+o[7]*n+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,s;const l=e.elements,u=l[0],c=l[4],h=l[8],f=l[1],d=l[5],g=l[9],p=l[2],m=l[6],_=l[10];if(Math.abs(c-f)<.01&&Math.abs(h-p)<.01&&Math.abs(g-m)<.01){if(Math.abs(c+f)<.1&&Math.abs(h+p)<.1&&Math.abs(g+m)<.1&&Math.abs(u+d+_-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(u+1)/2,x=(d+1)/2,T=(_+1)/2,I=(c+f)/4,C=(h+p)/4,S=(g+m)/4;return b>x&&b>T?b<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(b),i=I/n,s=C/n):x>T?x<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(x),n=I/i,s=S/i):T<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(T),n=C/s,i=S/s),this.set(n,i,s,t),this}let v=Math.sqrt((m-g)*(m-g)+(h-p)*(h-p)+(f-c)*(f-c));return Math.abs(v)<.001&&(v=1),this.x=(m-g)/v,this.y=(h-p)/v,this.z=(f-c)/v,this.w=Math.acos((u+d+_-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class xa extends Ra{constructor(e=1,t=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Yt(0,0,e,t),this.scissorTest=!1,this.viewport=new Yt(0,0,e,t);const i={width:e,height:t,depth:1};this.texture=new Hn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Er,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new kw(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Nw extends Hn{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Fn,this.minFilter=Fn,this.wrapR=hi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class vk extends Hn{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Fn,this.minFilter=Fn,this.wrapR=hi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ru{constructor(e=new ie(1/0,1/0,1/0),t=new ie(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,u=e.length;l<u;l+=3){const c=e[l],h=e[l+1],f=e[l+2];c<t&&(t=c),h<n&&(n=h),f<i&&(i=f),c>s&&(s=c),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,n,i),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,u=e.count;l<u;l++){const c=e.getX(l),h=e.getY(l),f=e.getZ(l);c<t&&(t=c),h<n&&(n=h),f<i&&(i=f),c>s&&(s=c),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,n,i),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Oo.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0)if(t&&n.attributes!=null&&n.attributes.position!==void 0){const s=n.attributes.position;for(let o=0,a=s.count;o<a;o++)Oo.fromBufferAttribute(s,o).applyMatrix4(e.matrixWorld),this.expandByPoint(Oo)}else n.boundingBox===null&&n.computeBoundingBox(),Nd.copy(n.boundingBox),Nd.applyMatrix4(e.matrixWorld),this.union(Nd);const i=e.children;for(let s=0,o=i.length;s<o;s++)this.expandByObject(i[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Oo),Oo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(bu),Yc.subVectors(this.max,bu),ja.subVectors(e.a,bu),qa.subVectors(e.b,bu),Ka.subVectors(e.c,bu),Ys.subVectors(qa,ja),Zs.subVectors(Ka,qa),Fo.subVectors(ja,Ka);let t=[0,-Ys.z,Ys.y,0,-Zs.z,Zs.y,0,-Fo.z,Fo.y,Ys.z,0,-Ys.x,Zs.z,0,-Zs.x,Fo.z,0,-Fo.x,-Ys.y,Ys.x,0,-Zs.y,Zs.x,0,-Fo.y,Fo.x,0];return!Rd(t,ja,qa,Ka,Yc)||(t=[1,0,0,0,1,0,0,0,1],!Rd(t,ja,qa,Ka,Yc))?!1:(Zc.crossVectors(Ys,Zs),t=[Zc.x,Zc.y,Zc.z],Rd(t,ja,qa,Ka,Yc))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Oo).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Oo).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(ls[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ls[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ls[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ls[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ls[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ls[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ls[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ls[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ls),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const ls=[new ie,new ie,new ie,new ie,new ie,new ie,new ie,new ie],Oo=new ie,Nd=new ru,ja=new ie,qa=new ie,Ka=new ie,Ys=new ie,Zs=new ie,Fo=new ie,bu=new ie,Yc=new ie,Zc=new ie,$o=new ie;function Rd(r,e,t,n,i){for(let s=0,o=r.length-3;s<=o;s+=3){$o.fromArray(r,s);const a=i.x*Math.abs($o.x)+i.y*Math.abs($o.y)+i.z*Math.abs($o.z),l=e.dot($o),u=t.dot($o),c=n.dot($o);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>a)return!1}return!0}const wk=new ru,xu=new ie,Pd=new ie;class iu{constructor(e=new ie,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):wk.setFromPoints(e).getCenter(n);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;xu.subVectors(e,this.center);const t=xu.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(xu,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Pd.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(xu.copy(e.center).add(Pd)),this.expandByPoint(xu.copy(e.center).sub(Pd))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const us=new ie,Ld=new ie,Qc=new ie,Qs=new ie,Dd=new ie,Jc=new ie,Od=new ie;class Ug{constructor(e=new ie,t=new ie(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,us)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=us.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(us.copy(this.origin).addScaledVector(this.direction,t),us.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){Ld.copy(e).add(t).multiplyScalar(.5),Qc.copy(t).sub(e).normalize(),Qs.copy(this.origin).sub(Ld);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Qc),a=Qs.dot(this.direction),l=-Qs.dot(Qc),u=Qs.lengthSq(),c=Math.abs(1-o*o);let h,f,d,g;if(c>0)if(h=o*l-a,f=o*a-l,g=s*c,h>=0)if(f>=-g)if(f<=g){const p=1/c;h*=p,f*=p,d=h*(h+o*f+2*a)+f*(o*h+f+2*l)+u}else f=s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+u;else f=-s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+u;else f<=-g?(h=Math.max(0,-(-o*s+a)),f=h>0?-s:Math.min(Math.max(-s,-l),s),d=-h*h+f*(f+2*l)+u):f<=g?(h=0,f=Math.min(Math.max(-s,-l),s),d=f*(f+2*l)+u):(h=Math.max(0,-(o*s+a)),f=h>0?s:Math.min(Math.max(-s,-l),s),d=-h*h+f*(f+2*l)+u);else f=o>0?-s:s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+u;return n&&n.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(Ld).addScaledVector(Qc,f),d}intersectSphere(e,t){us.subVectors(e.center,this.origin);const n=us.dot(this.direction),i=us.dot(us)-n*n,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=n-o,l=n+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,s,o,a,l;const u=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,f=this.origin;return u>=0?(n=(e.min.x-f.x)*u,i=(e.max.x-f.x)*u):(n=(e.max.x-f.x)*u,i=(e.min.x-f.x)*u),c>=0?(s=(e.min.y-f.y)*c,o=(e.max.y-f.y)*c):(s=(e.max.y-f.y)*c,o=(e.min.y-f.y)*c),n>o||s>i||((s>n||isNaN(n))&&(n=s),(o<i||isNaN(i))&&(i=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),n>l||a>i)||((a>n||n!==n)&&(n=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,us)!==null}intersectTriangle(e,t,n,i,s){Dd.subVectors(t,e),Jc.subVectors(n,e),Od.crossVectors(Dd,Jc);let o=this.direction.dot(Od),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Qs.subVectors(this.origin,e);const l=a*this.direction.dot(Jc.crossVectors(Qs,Jc));if(l<0)return null;const u=a*this.direction.dot(Dd.cross(Qs));if(u<0||l+u>o)return null;const c=-a*Qs.dot(Od);return c<0?null:this.at(c/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ct{constructor(){Ct.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,n,i,s,o,a,l,u,c,h,f,d,g,p,m){const _=this.elements;return _[0]=e,_[4]=t,_[8]=n,_[12]=i,_[1]=s,_[5]=o,_[9]=a,_[13]=l,_[2]=u,_[6]=c,_[10]=h,_[14]=f,_[3]=d,_[7]=g,_[11]=p,_[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ct().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/Xa.setFromMatrixColumn(e,0).length(),s=1/Xa.setFromMatrixColumn(e,1).length(),o=1/Xa.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,s=e.z,o=Math.cos(n),a=Math.sin(n),l=Math.cos(i),u=Math.sin(i),c=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const f=o*c,d=o*h,g=a*c,p=a*h;t[0]=l*c,t[4]=-l*h,t[8]=u,t[1]=d+g*u,t[5]=f-p*u,t[9]=-a*l,t[2]=p-f*u,t[6]=g+d*u,t[10]=o*l}else if(e.order==="YXZ"){const f=l*c,d=l*h,g=u*c,p=u*h;t[0]=f+p*a,t[4]=g*a-d,t[8]=o*u,t[1]=o*h,t[5]=o*c,t[9]=-a,t[2]=d*a-g,t[6]=p+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*c,d=l*h,g=u*c,p=u*h;t[0]=f-p*a,t[4]=-o*h,t[8]=g+d*a,t[1]=d+g*a,t[5]=o*c,t[9]=p-f*a,t[2]=-o*u,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*c,d=o*h,g=a*c,p=a*h;t[0]=l*c,t[4]=g*u-d,t[8]=f*u+p,t[1]=l*h,t[5]=p*u+f,t[9]=d*u-g,t[2]=-u,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,d=o*u,g=a*l,p=a*u;t[0]=l*c,t[4]=p-f*h,t[8]=g*h+d,t[1]=h,t[5]=o*c,t[9]=-a*c,t[2]=-u*c,t[6]=d*h+g,t[10]=f-p*h}else if(e.order==="XZY"){const f=o*l,d=o*u,g=a*l,p=a*u;t[0]=l*c,t[4]=-h,t[8]=u*c,t[1]=f*h+p,t[5]=o*c,t[9]=d*h-g,t[2]=g*h-d,t[6]=a*c,t[10]=p*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Sk,e,Tk)}lookAt(e,t,n){const i=this.elements;return Or.subVectors(e,t),Or.lengthSq()===0&&(Or.z=1),Or.normalize(),Js.crossVectors(n,Or),Js.lengthSq()===0&&(Math.abs(n.z)===1?Or.x+=1e-4:Or.z+=1e-4,Or.normalize(),Js.crossVectors(n,Or)),Js.normalize(),eh.crossVectors(Or,Js),i[0]=Js.x,i[4]=eh.x,i[8]=Or.x,i[1]=Js.y,i[5]=eh.y,i[9]=Or.y,i[2]=Js.z,i[6]=eh.z,i[10]=Or.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[4],l=n[8],u=n[12],c=n[1],h=n[5],f=n[9],d=n[13],g=n[2],p=n[6],m=n[10],_=n[14],v=n[3],b=n[7],x=n[11],T=n[15],I=i[0],C=i[4],S=i[8],A=i[12],R=i[1],F=i[5],q=i[9],O=i[13],z=i[2],H=i[6],Q=i[10],Z=i[14],Y=i[3],fe=i[7],le=i[11],ve=i[15];return s[0]=o*I+a*R+l*z+u*Y,s[4]=o*C+a*F+l*H+u*fe,s[8]=o*S+a*q+l*Q+u*le,s[12]=o*A+a*O+l*Z+u*ve,s[1]=c*I+h*R+f*z+d*Y,s[5]=c*C+h*F+f*H+d*fe,s[9]=c*S+h*q+f*Q+d*le,s[13]=c*A+h*O+f*Z+d*ve,s[2]=g*I+p*R+m*z+_*Y,s[6]=g*C+p*F+m*H+_*fe,s[10]=g*S+p*q+m*Q+_*le,s[14]=g*A+p*O+m*Z+_*ve,s[3]=v*I+b*R+x*z+T*Y,s[7]=v*C+b*F+x*H+T*fe,s[11]=v*S+b*q+x*Q+T*le,s[15]=v*A+b*O+x*Z+T*ve,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],s=e[12],o=e[1],a=e[5],l=e[9],u=e[13],c=e[2],h=e[6],f=e[10],d=e[14],g=e[3],p=e[7],m=e[11],_=e[15];return g*(+s*l*h-i*u*h-s*a*f+n*u*f+i*a*d-n*l*d)+p*(+t*l*d-t*u*f+s*o*f-i*o*d+i*u*c-s*l*c)+m*(+t*u*h-t*a*d-s*o*h+n*o*d+s*a*c-n*u*c)+_*(-i*a*c-t*l*h+t*a*f+i*o*h-n*o*f+n*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=e[9],f=e[10],d=e[11],g=e[12],p=e[13],m=e[14],_=e[15],v=h*m*u-p*f*u+p*l*d-a*m*d-h*l*_+a*f*_,b=g*f*u-c*m*u-g*l*d+o*m*d+c*l*_-o*f*_,x=c*p*u-g*h*u+g*a*d-o*p*d-c*a*_+o*h*_,T=g*h*l-c*p*l-g*a*f+o*p*f+c*a*m-o*h*m,I=t*v+n*b+i*x+s*T;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/I;return e[0]=v*C,e[1]=(p*f*s-h*m*s-p*i*d+n*m*d+h*i*_-n*f*_)*C,e[2]=(a*m*s-p*l*s+p*i*u-n*m*u-a*i*_+n*l*_)*C,e[3]=(h*l*s-a*f*s-h*i*u+n*f*u+a*i*d-n*l*d)*C,e[4]=b*C,e[5]=(c*m*s-g*f*s+g*i*d-t*m*d-c*i*_+t*f*_)*C,e[6]=(g*l*s-o*m*s-g*i*u+t*m*u+o*i*_-t*l*_)*C,e[7]=(o*f*s-c*l*s+c*i*u-t*f*u-o*i*d+t*l*d)*C,e[8]=x*C,e[9]=(g*h*s-c*p*s-g*n*d+t*p*d+c*n*_-t*h*_)*C,e[10]=(o*p*s-g*a*s+g*n*u-t*p*u-o*n*_+t*a*_)*C,e[11]=(c*a*s-o*h*s-c*n*u+t*h*u+o*n*d-t*a*d)*C,e[12]=T*C,e[13]=(c*p*i-g*h*i+g*n*f-t*p*f-c*n*m+t*h*m)*C,e[14]=(g*a*i-o*p*i-g*n*l+t*p*l+o*n*m-t*a*m)*C,e[15]=(o*h*i-c*a*i+c*n*l-t*h*l-o*n*f+t*a*f)*C,this}scale(e){const t=this.elements,n=e.x,i=e.y,s=e.z;return t[0]*=n,t[4]*=i,t[8]*=s,t[1]*=n,t[5]*=i,t[9]*=s,t[2]*=n,t[6]*=i,t[10]*=s,t[3]*=n,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),s=1-n,o=e.x,a=e.y,l=e.z,u=s*o,c=s*a;return this.set(u*o+n,u*a-i*l,u*l+i*a,0,u*a+i*l,c*a+n,c*l-i*o,0,u*l-i*a,c*l+i*o,s*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,s,o){return this.set(1,n,s,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,u=s+s,c=o+o,h=a+a,f=s*u,d=s*c,g=s*h,p=o*c,m=o*h,_=a*h,v=l*u,b=l*c,x=l*h,T=n.x,I=n.y,C=n.z;return i[0]=(1-(p+_))*T,i[1]=(d+x)*T,i[2]=(g-b)*T,i[3]=0,i[4]=(d-x)*I,i[5]=(1-(f+_))*I,i[6]=(m+v)*I,i[7]=0,i[8]=(g+b)*C,i[9]=(m-v)*C,i[10]=(1-(f+p))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let s=Xa.set(i[0],i[1],i[2]).length();const o=Xa.set(i[4],i[5],i[6]).length(),a=Xa.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Mi.copy(this);const u=1/s,c=1/o,h=1/a;return Mi.elements[0]*=u,Mi.elements[1]*=u,Mi.elements[2]*=u,Mi.elements[4]*=c,Mi.elements[5]*=c,Mi.elements[6]*=c,Mi.elements[8]*=h,Mi.elements[9]*=h,Mi.elements[10]*=h,t.setFromRotationMatrix(Mi),n.x=s,n.y=o,n.z=a,this}makePerspective(e,t,n,i,s,o){const a=this.elements,l=2*s/(t-e),u=2*s/(n-i),c=(t+e)/(t-e),h=(n+i)/(n-i),f=-(o+s)/(o-s),d=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=u,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,i,s,o){const a=this.elements,l=1/(t-e),u=1/(n-i),c=1/(o-s),h=(t+e)*l,f=(n+i)*u,d=(o+s)*c;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*u,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const Xa=new ie,Mi=new Ct,Sk=new ie(0,0,0),Tk=new ie(1,1,1),Js=new ie,eh=new ie,Or=new ie,k_=new Ct,N_=new rs;class kf{constructor(e=0,t=0,n=0,i=kf.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,s=i[0],o=i[4],a=i[8],l=i[1],u=i[5],c=i[9],h=i[2],f=i[6],d=i[10];switch(t){case"XYZ":this._y=Math.asin(Jn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(f,u),this._z=0);break;case"YXZ":this._x=Math.asin(-Jn(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(Jn(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Jn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(f,d),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(Jn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Jn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,u),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return k_.makeRotationFromQuaternion(e),this.setFromRotationMatrix(k_,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return N_.setFromEuler(this),this.setFromQuaternion(N_,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}kf.DEFAULT_ORDER="XYZ";class Rw{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Ek=0;const R_=new ie,Ya=new rs,cs=new Ct,th=new ie,vu=new ie,Mk=new ie,Ak=new rs,P_=new ie(1,0,0),L_=new ie(0,1,0),D_=new ie(0,0,1),Ik={type:"added"},O_={type:"removed"};class gn extends Ra{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Ek++}),this.uuid=Fi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=gn.DEFAULT_UP.clone();const e=new ie,t=new kf,n=new rs,i=new ie(1,1,1);function s(){n.setFromEuler(t,!1)}function o(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ct},normalMatrix:{value:new gr}}),this.matrix=new Ct,this.matrixWorld=new Ct,this.matrixAutoUpdate=gn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=gn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new Rw,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Ya.setFromAxisAngle(e,t),this.quaternion.multiply(Ya),this}rotateOnWorldAxis(e,t){return Ya.setFromAxisAngle(e,t),this.quaternion.premultiply(Ya),this}rotateX(e){return this.rotateOnAxis(P_,e)}rotateY(e){return this.rotateOnAxis(L_,e)}rotateZ(e){return this.rotateOnAxis(D_,e)}translateOnAxis(e,t){return R_.copy(e).applyQuaternion(this.quaternion),this.position.add(R_.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(P_,e)}translateY(e){return this.translateOnAxis(L_,e)}translateZ(e){return this.translateOnAxis(D_,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(cs.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?th.copy(e):th.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),vu.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?cs.lookAt(vu,th,this.up):cs.lookAt(th,vu,this.up),this.quaternion.setFromRotationMatrix(cs),i&&(cs.extractRotation(i.matrixWorld),Ya.setFromRotationMatrix(cs),this.quaternion.premultiply(Ya.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Ik)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(O_)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(O_)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),cs.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),cs.multiply(e.parent.matrixWorld)),e.applyMatrix4(cs),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t){let n=[];this[e]===t&&n.push(this);for(let i=0,s=this.children.length;i<s;i++){const o=this.children[i].getObjectsByProperty(e,t);o.length>0&&(n=n.concat(o))}return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vu,e,Mk),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vu,Ak,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++){const s=t[n];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,o=i.length;s<o;s++){const a=i[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const h=l[u];s(e.shapes,h)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,u=this.material.length;l<u;l++)a.push(s(e.materials,this.material[l]));i.material=a}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),u=o(e.textures),c=o(e.images),h=o(e.shapes),f=o(e.skeletons),d=o(e.animations),g=o(e.nodes);a.length>0&&(n.geometries=a),l.length>0&&(n.materials=l),u.length>0&&(n.textures=u),c.length>0&&(n.images=c),h.length>0&&(n.shapes=h),f.length>0&&(n.skeletons=f),d.length>0&&(n.animations=d),g.length>0&&(n.nodes=g)}return n.object=i,n;function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}gn.DEFAULT_UP=new ie(0,1,0);gn.DEFAULT_MATRIX_AUTO_UPDATE=!0;gn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Ai=new ie,hs=new ie,Fd=new ie,fs=new ie,Za=new ie,Qa=new ie,F_=new ie,$d=new ie,zd=new ie,Bd=new ie;class bs{constructor(e=new ie,t=new ie,n=new ie){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Ai.subVectors(e,t),i.cross(Ai);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,n,i,s){Ai.subVectors(i,t),hs.subVectors(n,t),Fd.subVectors(e,t);const o=Ai.dot(Ai),a=Ai.dot(hs),l=Ai.dot(Fd),u=hs.dot(hs),c=hs.dot(Fd),h=o*u-a*a;if(h===0)return s.set(-2,-1,-1);const f=1/h,d=(u*l-a*c)*f,g=(o*c-a*l)*f;return s.set(1-d-g,g,d)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,fs),fs.x>=0&&fs.y>=0&&fs.x+fs.y<=1}static getUV(e,t,n,i,s,o,a,l){return this.getBarycoord(e,t,n,i,fs),l.set(0,0),l.addScaledVector(s,fs.x),l.addScaledVector(o,fs.y),l.addScaledVector(a,fs.z),l}static isFrontFacing(e,t,n,i){return Ai.subVectors(n,t),hs.subVectors(e,t),Ai.cross(hs).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ai.subVectors(this.c,this.b),hs.subVectors(this.a,this.b),Ai.cross(hs).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return bs.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return bs.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,s){return bs.getUV(e,this.a,this.b,this.c,t,n,i,s)}containsPoint(e){return bs.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return bs.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,s=this.c;let o,a;Za.subVectors(i,n),Qa.subVectors(s,n),$d.subVectors(e,n);const l=Za.dot($d),u=Qa.dot($d);if(l<=0&&u<=0)return t.copy(n);zd.subVectors(e,i);const c=Za.dot(zd),h=Qa.dot(zd);if(c>=0&&h<=c)return t.copy(i);const f=l*h-c*u;if(f<=0&&l>=0&&c<=0)return o=l/(l-c),t.copy(n).addScaledVector(Za,o);Bd.subVectors(e,s);const d=Za.dot(Bd),g=Qa.dot(Bd);if(g>=0&&d<=g)return t.copy(s);const p=d*u-l*g;if(p<=0&&u>=0&&g<=0)return a=u/(u-g),t.copy(n).addScaledVector(Qa,a);const m=c*g-d*h;if(m<=0&&h-c>=0&&d-g>=0)return F_.subVectors(s,i),a=(h-c)/(h-c+(d-g)),t.copy(i).addScaledVector(F_,a);const _=1/(m+p+f);return o=p*_,a=f*_,t.copy(n).addScaledVector(Za,o).addScaledVector(Qa,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Ck=0;class Qi extends Ra{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ck++}),this.uuid=Fi(),this.name="",this.type="Material",this.blending=xl,this.side=Rs,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=yw,this.blendDst=_w,this.blendEquation=ll,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Gp,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=JC,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Md,this.stencilZFail=Md,this.stencilZPass=Md,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==xl&&(n.blending=this.blending),this.side!==Rs&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.forceSinglePass===!0&&(n.forceSinglePass=this.forceSinglePass),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=i(e.textures),o=i(e.images);s.length>0&&(n.textures=s),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}const Pw={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ii={h:0,s:0,l:0},nh={h:0,s:0,l:0};function Ud(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}class gt{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Hi){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,ur.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=ur.workingColorSpace){return this.r=e,this.g=t,this.b=n,ur.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=ur.workingColorSpace){if(e=Bg(e,1),t=Jn(t,0,1),n=Jn(n,0,1),t===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+t):n+t-n*t,o=2*n-s;this.r=Ud(o,s,e+1/3),this.g=Ud(o,s,e),this.b=Ud(o,s,e-1/3)}return ur.toWorkingColorSpace(this,i),this}setStyle(e,t=Hi){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,ur.toWorkingColorSpace(this,t),n(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,ur.toWorkingColorSpace(this,t),n(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(s[1])/360,u=parseFloat(s[2])/100,c=parseFloat(s[3])/100;return n(s[4]),this.setHSL(l,u,c,t)}break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],o=s.length;if(o===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,ur.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,ur.toWorkingColorSpace(this,t),this;console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Hi){const n=Pw[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=wl(e.r),this.g=wl(e.g),this.b=wl(e.b),this}copyLinearToSRGB(e){return this.r=Cd(e.r),this.g=Cd(e.g),this.b=Cd(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Hi){return ur.fromWorkingColorSpace(Yn.copy(this),e),Jn(Yn.r*255,0,255)<<16^Jn(Yn.g*255,0,255)<<8^Jn(Yn.b*255,0,255)<<0}getHexString(e=Hi){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=ur.workingColorSpace){ur.fromWorkingColorSpace(Yn.copy(this),t);const n=Yn.r,i=Yn.g,s=Yn.b,o=Math.max(n,i,s),a=Math.min(n,i,s);let l,u;const c=(a+o)/2;if(a===o)l=0,u=0;else{const h=o-a;switch(u=c<=.5?h/(o+a):h/(2-o-a),o){case n:l=(i-s)/h+(i<s?6:0);break;case i:l=(s-n)/h+2;break;case s:l=(n-i)/h+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=ur.workingColorSpace){return ur.fromWorkingColorSpace(Yn.copy(this),t),e.r=Yn.r,e.g=Yn.g,e.b=Yn.b,e}getStyle(e=Hi){ur.fromWorkingColorSpace(Yn.copy(this),e);const t=Yn.r,n=Yn.g,i=Yn.b;return e!==Hi?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${t*255|0},${n*255|0},${i*255|0})`}offsetHSL(e,t,n){return this.getHSL(Ii),Ii.h+=e,Ii.s+=t,Ii.l+=n,this.setHSL(Ii.h,Ii.s,Ii.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Ii),e.getHSL(nh);const n=Xu(Ii.h,nh.h,t),i=Xu(Ii.s,nh.s,t),s=Xu(Ii.l,nh.l,t);return this.setHSL(n,i,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Yn=new gt;gt.NAMES=Pw;class ta extends Qi{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new gt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=bw,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const wn=new ie,rh=new mt;class _r{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=Xp,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)rh.fromBufferAttribute(this,t),rh.applyMatrix3(e),this.setXY(t,rh.x,rh.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)wn.fromBufferAttribute(this,t),wn.applyMatrix3(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)wn.fromBufferAttribute(this,t),wn.applyMatrix4(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)wn.fromBufferAttribute(this,t),wn.applyNormalMatrix(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)wn.fromBufferAttribute(this,t),wn.transformDirection(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Ss(t,this.array)),t}setX(e,t){return this.normalized&&(t=qt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Ss(t,this.array)),t}setY(e,t){return this.normalized&&(t=qt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Ss(t,this.array)),t}setZ(e,t){return this.normalized&&(t=qt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Ss(t,this.array)),t}setW(e,t){return this.normalized&&(t=qt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array),i=qt(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array),i=qt(i,this.array),s=qt(s,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Xp&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Lw extends _r{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Dw extends _r{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class sr extends _r{constructor(e,t,n){super(new Float32Array(e),t,n)}}let kk=0;const ri=new Ct,Vd=new gn,Ja=new ie,Fr=new ru,wu=new ru,Dn=new ie;class Kr extends Ra{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:kk++}),this.uuid=Fi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Iw(e)?Dw:Lw)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new gr().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return ri.makeRotationFromQuaternion(e),this.applyMatrix4(ri),this}rotateX(e){return ri.makeRotationX(e),this.applyMatrix4(ri),this}rotateY(e){return ri.makeRotationY(e),this.applyMatrix4(ri),this}rotateZ(e){return ri.makeRotationZ(e),this.applyMatrix4(ri),this}translate(e,t,n){return ri.makeTranslation(e,t,n),this.applyMatrix4(ri),this}scale(e,t,n){return ri.makeScale(e,t,n),this.applyMatrix4(ri),this}lookAt(e){return Vd.lookAt(e),Vd.updateMatrix(),this.applyMatrix4(Vd.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ja).negate(),this.translate(Ja.x,Ja.y,Ja.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new sr(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ru);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new ie(-1/0,-1/0,-1/0),new ie(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const s=t[n];Fr.setFromBufferAttribute(s),this.morphTargetsRelative?(Dn.addVectors(this.boundingBox.min,Fr.min),this.boundingBox.expandByPoint(Dn),Dn.addVectors(this.boundingBox.max,Fr.max),this.boundingBox.expandByPoint(Dn)):(this.boundingBox.expandByPoint(Fr.min),this.boundingBox.expandByPoint(Fr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new iu);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new ie,1/0);return}if(e){const n=this.boundingSphere.center;if(Fr.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];wu.setFromBufferAttribute(a),this.morphTargetsRelative?(Dn.addVectors(Fr.min,wu.min),Fr.expandByPoint(Dn),Dn.addVectors(Fr.max,wu.max),Fr.expandByPoint(Dn)):(Fr.expandByPoint(wu.min),Fr.expandByPoint(wu.max))}Fr.getCenter(n);let i=0;for(let s=0,o=e.count;s<o;s++)Dn.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(Dn));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Dn.fromBufferAttribute(a,u),l&&(Ja.fromBufferAttribute(e,u),Dn.add(Ja)),i=Math.max(i,n.distanceToSquared(Dn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,s=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new _r(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,u=[],c=[];for(let R=0;R<a;R++)u[R]=new ie,c[R]=new ie;const h=new ie,f=new ie,d=new ie,g=new mt,p=new mt,m=new mt,_=new ie,v=new ie;function b(R,F,q){h.fromArray(i,R*3),f.fromArray(i,F*3),d.fromArray(i,q*3),g.fromArray(o,R*2),p.fromArray(o,F*2),m.fromArray(o,q*2),f.sub(h),d.sub(h),p.sub(g),m.sub(g);const O=1/(p.x*m.y-m.x*p.y);isFinite(O)&&(_.copy(f).multiplyScalar(m.y).addScaledVector(d,-p.y).multiplyScalar(O),v.copy(d).multiplyScalar(p.x).addScaledVector(f,-m.x).multiplyScalar(O),u[R].add(_),u[F].add(_),u[q].add(_),c[R].add(v),c[F].add(v),c[q].add(v))}let x=this.groups;x.length===0&&(x=[{start:0,count:n.length}]);for(let R=0,F=x.length;R<F;++R){const q=x[R],O=q.start,z=q.count;for(let H=O,Q=O+z;H<Q;H+=3)b(n[H+0],n[H+1],n[H+2])}const T=new ie,I=new ie,C=new ie,S=new ie;function A(R){C.fromArray(s,R*3),S.copy(C);const F=u[R];T.copy(F),T.sub(C.multiplyScalar(C.dot(F))).normalize(),I.crossVectors(S,F);const O=I.dot(c[R])<0?-1:1;l[R*4]=T.x,l[R*4+1]=T.y,l[R*4+2]=T.z,l[R*4+3]=O}for(let R=0,F=x.length;R<F;++R){const q=x[R],O=q.start,z=q.count;for(let H=O,Q=O+z;H<Q;H+=3)A(n[H+0]),A(n[H+1]),A(n[H+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new _r(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let f=0,d=n.count;f<d;f++)n.setXYZ(f,0,0,0);const i=new ie,s=new ie,o=new ie,a=new ie,l=new ie,u=new ie,c=new ie,h=new ie;if(e)for(let f=0,d=e.count;f<d;f+=3){const g=e.getX(f+0),p=e.getX(f+1),m=e.getX(f+2);i.fromBufferAttribute(t,g),s.fromBufferAttribute(t,p),o.fromBufferAttribute(t,m),c.subVectors(o,s),h.subVectors(i,s),c.cross(h),a.fromBufferAttribute(n,g),l.fromBufferAttribute(n,p),u.fromBufferAttribute(n,m),a.add(c),l.add(c),u.add(c),n.setXYZ(g,a.x,a.y,a.z),n.setXYZ(p,l.x,l.y,l.z),n.setXYZ(m,u.x,u.y,u.z)}else for(let f=0,d=t.count;f<d;f+=3)i.fromBufferAttribute(t,f+0),s.fromBufferAttribute(t,f+1),o.fromBufferAttribute(t,f+2),c.subVectors(o,s),h.subVectors(i,s),c.cross(h),n.setXYZ(f+0,c.x,c.y,c.z),n.setXYZ(f+1,c.x,c.y,c.z),n.setXYZ(f+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Dn.fromBufferAttribute(e,t),Dn.normalize(),e.setXYZ(t,Dn.x,Dn.y,Dn.z)}toNonIndexed(){function e(a,l){const u=a.array,c=a.itemSize,h=a.normalized,f=new u.constructor(l.length*c);let d=0,g=0;for(let p=0,m=l.length;p<m;p++){a.isInterleavedBufferAttribute?d=l[p]*a.data.stride+a.offset:d=l[p]*c;for(let _=0;_<c;_++)f[g++]=u[d++]}return new _r(f,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Kr,n=this.index.array,i=this.attributes;for(const a in i){const l=i[a],u=e(l,n);t.setAttribute(a,u)}const s=this.morphAttributes;for(const a in s){const l=[],u=s[a];for(let c=0,h=u.length;c<h;c++){const f=u[c],d=e(f,n);l.push(d)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const u=o[a];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const u=n[l];e.data.attributes[l]=u.toJSON(e.data)}const i={};let s=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let h=0,f=u.length;h<f;h++){const d=u[h];c.push(d.toJSON(e.data))}c.length>0&&(i[l]=c,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const u in i){const c=i[u];this.setAttribute(u,c.clone(t))}const s=e.morphAttributes;for(const u in s){const c=[],h=s[u];for(let f=0,d=h.length;f<d;f++)c.push(h[f].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let u=0,c=o.length;u<c;u++){const h=o[u];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const $_=new Ct,Wi=new Ug,ih=new iu,z_=new ie,Su=new ie,Tu=new ie,Eu=new ie,Wd=new ie,sh=new ie,oh=new mt,ah=new mt,lh=new mt,Gd=new ie,uh=new ie;class Ur extends gn{constructor(e=new Kr,t=new ta){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,o=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(s&&a){sh.set(0,0,0);for(let l=0,u=s.length;l<u;l++){const c=a[l],h=s[l];c!==0&&(Wd.fromBufferAttribute(h,e),o?sh.addScaledVector(Wd,c):sh.addScaledVector(Wd.sub(t),c))}t.add(sh)}return this.isSkinnedMesh&&this.boneTransform(e,t),t}raycast(e,t){const n=this.geometry,i=this.material,s=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),ih.copy(n.boundingSphere),ih.applyMatrix4(s),Wi.copy(e.ray).recast(e.near),ih.containsPoint(Wi.origin)===!1&&(Wi.intersectSphere(ih,z_)===null||Wi.origin.distanceToSquared(z_)>(e.far-e.near)**2))||($_.copy(s).invert(),Wi.copy(e.ray).applyMatrix4($_),n.boundingBox!==null&&Wi.intersectsBox(n.boundingBox)===!1))return;let o;const a=n.index,l=n.attributes.position,u=n.attributes.uv,c=n.attributes.uv2,h=n.groups,f=n.drawRange;if(a!==null)if(Array.isArray(i))for(let d=0,g=h.length;d<g;d++){const p=h[d],m=i[p.materialIndex],_=Math.max(p.start,f.start),v=Math.min(a.count,Math.min(p.start+p.count,f.start+f.count));for(let b=_,x=v;b<x;b+=3){const T=a.getX(b),I=a.getX(b+1),C=a.getX(b+2);o=ch(this,m,e,Wi,u,c,T,I,C),o&&(o.faceIndex=Math.floor(b/3),o.face.materialIndex=p.materialIndex,t.push(o))}}else{const d=Math.max(0,f.start),g=Math.min(a.count,f.start+f.count);for(let p=d,m=g;p<m;p+=3){const _=a.getX(p),v=a.getX(p+1),b=a.getX(p+2);o=ch(this,i,e,Wi,u,c,_,v,b),o&&(o.faceIndex=Math.floor(p/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(i))for(let d=0,g=h.length;d<g;d++){const p=h[d],m=i[p.materialIndex],_=Math.max(p.start,f.start),v=Math.min(l.count,Math.min(p.start+p.count,f.start+f.count));for(let b=_,x=v;b<x;b+=3){const T=b,I=b+1,C=b+2;o=ch(this,m,e,Wi,u,c,T,I,C),o&&(o.faceIndex=Math.floor(b/3),o.face.materialIndex=p.materialIndex,t.push(o))}}else{const d=Math.max(0,f.start),g=Math.min(l.count,f.start+f.count);for(let p=d,m=g;p<m;p+=3){const _=p,v=p+1,b=p+2;o=ch(this,i,e,Wi,u,c,_,v,b),o&&(o.faceIndex=Math.floor(p/3),t.push(o))}}}}function Nk(r,e,t,n,i,s,o,a){let l;if(e.side===Vr?l=n.intersectTriangle(o,s,i,!0,a):l=n.intersectTriangle(i,s,o,e.side===Rs,a),l===null)return null;uh.copy(a),uh.applyMatrix4(r.matrixWorld);const u=t.ray.origin.distanceTo(uh);return u<t.near||u>t.far?null:{distance:u,point:uh.clone(),object:r}}function ch(r,e,t,n,i,s,o,a,l){r.getVertexPosition(o,Su),r.getVertexPosition(a,Tu),r.getVertexPosition(l,Eu);const u=Nk(r,e,t,n,Su,Tu,Eu,Gd);if(u){i&&(oh.fromBufferAttribute(i,o),ah.fromBufferAttribute(i,a),lh.fromBufferAttribute(i,l),u.uv=bs.getUV(Gd,Su,Tu,Eu,oh,ah,lh,new mt)),s&&(oh.fromBufferAttribute(s,o),ah.fromBufferAttribute(s,a),lh.fromBufferAttribute(s,l),u.uv2=bs.getUV(Gd,Su,Tu,Eu,oh,ah,lh,new mt));const c={a:o,b:a,c:l,normal:new ie,materialIndex:0};bs.getNormal(Su,Tu,Eu,c.normal),u.face=c}return u}class Nc extends Kr{constructor(e=1,t=1,n=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const l=[],u=[],c=[],h=[];let f=0,d=0;g("z","y","x",-1,-1,n,t,e,o,s,0),g("z","y","x",1,-1,n,t,-e,o,s,1),g("x","z","y",1,1,e,n,t,i,o,2),g("x","z","y",1,-1,e,n,-t,i,o,3),g("x","y","z",1,-1,e,t,n,i,s,4),g("x","y","z",-1,-1,e,t,-n,i,s,5),this.setIndex(l),this.setAttribute("position",new sr(u,3)),this.setAttribute("normal",new sr(c,3)),this.setAttribute("uv",new sr(h,2));function g(p,m,_,v,b,x,T,I,C,S,A){const R=x/C,F=T/S,q=x/2,O=T/2,z=I/2,H=C+1,Q=S+1;let Z=0,Y=0;const fe=new ie;for(let le=0;le<Q;le++){const ve=le*F-O;for(let ee=0;ee<H;ee++){const _e=ee*R-q;fe[p]=_e*v,fe[m]=ve*b,fe[_]=z,u.push(fe.x,fe.y,fe.z),fe[p]=0,fe[m]=0,fe[_]=I>0?1:-1,c.push(fe.x,fe.y,fe.z),h.push(ee/C),h.push(1-le/S),Z+=1}}for(let le=0;le<S;le++)for(let ve=0;ve<C;ve++){const ee=f+ve+H*le,_e=f+ve+H*(le+1),Te=f+(ve+1)+H*(le+1),ne=f+(ve+1)+H*le;l.push(ee,_e,ne),l.push(_e,Te,ne),Y+=6}a.addGroup(d,Y,A),d+=Y,f+=Z}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Nc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Fl(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const i=r[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function fr(r){const e={};for(let t=0;t<r.length;t++){const n=Fl(r[t]);for(const i in n)e[i]=n[i]}return e}function Rk(r){const e=[];for(let t=0;t<r.length;t++)e.push(r[t].clone());return e}function Ow(r){return r.getRenderTarget()===null&&r.outputEncoding===$t?Hi:uc}const Pk={clone:Fl,merge:fr};var Lk=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Dk=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class va extends Qi{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Lk,this.fragmentShader=Dk,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Fl(e.uniforms),this.uniformsGroups=Rk(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class Fw extends gn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Ct,this.projectionMatrix=new Ct,this.projectionMatrixInverse=new Ct}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class dr extends Fw{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=cc*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Ku*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return cc*2*Math.atan(Math.tan(Ku*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Ku*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,s=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,u=o.fullHeight;s+=o.offsetX*i/l,t-=o.offsetY*n/u,i*=o.width/l,n*=o.height/u}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const el=-90,tl=1;class Ok extends gn{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n;const i=new dr(el,tl,e,t);i.layers=this.layers,i.up.set(0,1,0),i.lookAt(1,0,0),this.add(i);const s=new dr(el,tl,e,t);s.layers=this.layers,s.up.set(0,1,0),s.lookAt(-1,0,0),this.add(s);const o=new dr(el,tl,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(0,1,0),this.add(o);const a=new dr(el,tl,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(0,-1,0),this.add(a);const l=new dr(el,tl,e,t);l.layers=this.layers,l.up.set(0,1,0),l.lookAt(0,0,1),this.add(l);const u=new dr(el,tl,e,t);u.layers=this.layers,u.up.set(0,1,0),u.lookAt(0,0,-1),this.add(u)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,s,o,a,l,u]=this.children,c=e.getRenderTarget(),h=e.toneMapping,f=e.xr.enabled;e.toneMapping=As,e.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,s),e.setRenderTarget(n,2),e.render(t,o),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,u),e.setRenderTarget(c),e.toneMapping=h,e.xr.enabled=f,n.texture.needsPMREMUpdate=!0}}class $w extends Hn{constructor(e,t,n,i,s,o,a,l,u,c){e=e!==void 0?e:[],t=t!==void 0?t:Rl,super(e,t,n,i,s,o,a,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class Fk extends xa{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new $w(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Er}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Nc(5,5,5),s=new va({name:"CubemapFromEquirect",uniforms:Fl(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Vr,blending:mo});s.uniforms.tEquirect.value=t;const o=new Ur(i,s),a=t.minFilter;return t.minFilter===ya&&(t.minFilter=Er),new Ok(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,i);e.setRenderTarget(s)}}const Hd=new ie,$k=new ie,zk=new gr;class Wo{constructor(e=new ie(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Hd.subVectors(n,t).cross($k.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(Hd),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(n,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||zk.getNormalMatrix(e),i=this.coplanarPoint(Hd).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const nl=new iu,hh=new ie;class Vg{constructor(e=new Wo,t=new Wo,n=new Wo,i=new Wo,s=new Wo,o=new Wo){this.planes=[e,t,n,i,s,o]}set(e,t,n,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],s=n[1],o=n[2],a=n[3],l=n[4],u=n[5],c=n[6],h=n[7],f=n[8],d=n[9],g=n[10],p=n[11],m=n[12],_=n[13],v=n[14],b=n[15];return t[0].setComponents(a-i,h-l,p-f,b-m).normalize(),t[1].setComponents(a+i,h+l,p+f,b+m).normalize(),t[2].setComponents(a+s,h+u,p+d,b+_).normalize(),t[3].setComponents(a-s,h-u,p-d,b-_).normalize(),t[4].setComponents(a-o,h-c,p-g,b-v).normalize(),t[5].setComponents(a+o,h+c,p+g,b+v).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),nl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(nl)}intersectsSprite(e){return nl.center.set(0,0,0),nl.radius=.7071067811865476,nl.applyMatrix4(e.matrixWorld),this.intersectsSphere(nl)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(hh.x=i.normal.x>0?e.max.x:e.min.x,hh.y=i.normal.y>0?e.max.y:e.min.y,hh.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(hh)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function zw(){let r=null,e=!1,t=null,n=null;function i(s,o){t(s,o),n=r.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(i),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){r=s}}}function Bk(r,e){const t=e.isWebGL2,n=new WeakMap;function i(u,c){const h=u.array,f=u.usage,d=r.createBuffer();r.bindBuffer(c,d),r.bufferData(c,h,f),u.onUploadCallback();let g;if(h instanceof Float32Array)g=5126;else if(h instanceof Uint16Array)if(u.isFloat16BufferAttribute)if(t)g=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else g=5123;else if(h instanceof Int16Array)g=5122;else if(h instanceof Uint32Array)g=5125;else if(h instanceof Int32Array)g=5124;else if(h instanceof Int8Array)g=5120;else if(h instanceof Uint8Array)g=5121;else if(h instanceof Uint8ClampedArray)g=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:d,type:g,bytesPerElement:h.BYTES_PER_ELEMENT,version:u.version}}function s(u,c,h){const f=c.array,d=c.updateRange;r.bindBuffer(h,u),d.count===-1?r.bufferSubData(h,0,f):(t?r.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):r.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1),c.onUploadCallback()}function o(u){return u.isInterleavedBufferAttribute&&(u=u.data),n.get(u)}function a(u){u.isInterleavedBufferAttribute&&(u=u.data);const c=n.get(u);c&&(r.deleteBuffer(c.buffer),n.delete(u))}function l(u,c){if(u.isGLBufferAttribute){const f=n.get(u);(!f||f.version<u.version)&&n.set(u,{buffer:u.buffer,type:u.type,bytesPerElement:u.elementSize,version:u.version});return}u.isInterleavedBufferAttribute&&(u=u.data);const h=n.get(u);h===void 0?n.set(u,i(u,c)):h.version<u.version&&(s(h.buffer,u,c),h.version=u.version)}return{get:o,remove:a,update:l}}class Wg extends Kr{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const s=e/2,o=t/2,a=Math.floor(n),l=Math.floor(i),u=a+1,c=l+1,h=e/a,f=t/l,d=[],g=[],p=[],m=[];for(let _=0;_<c;_++){const v=_*f-o;for(let b=0;b<u;b++){const x=b*h-s;g.push(x,-v,0),p.push(0,0,1),m.push(b/a),m.push(1-_/l)}}for(let _=0;_<l;_++)for(let v=0;v<a;v++){const b=v+u*_,x=v+u*(_+1),T=v+1+u*(_+1),I=v+1+u*_;d.push(b,x,I),d.push(x,T,I)}this.setIndex(d),this.setAttribute("position",new sr(g,3)),this.setAttribute("normal",new sr(p,3)),this.setAttribute("uv",new sr(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Wg(e.width,e.height,e.widthSegments,e.heightSegments)}}var Uk=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Vk=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Wk=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Gk=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Hk=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,jk=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,qk="vec3 transformed = vec3( position );",Kk=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Xk=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,Yk=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Zk=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Qk=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Jk=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,eN=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,tN=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,nN=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,rN=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,iN=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,sN=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,oN=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,aN=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,lN=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,uN=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,cN=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,hN=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,fN=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,dN="gl_FragColor = linearToOutputTexel( gl_FragColor );",pN=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,mN=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,gN=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,yN=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,_N=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,bN=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,xN=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,vN=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,wN=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,SN=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,TN=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,EN=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,MN=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,AN=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,IN=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,CN=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,kN=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,NN=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,RN=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,PN=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,LN=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,DN=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,ON=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,FN=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,$N=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,zN=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,BN=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,UN=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,VN=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,WN=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,GN=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,HN=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,jN=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,qN=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,KN=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,XN=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,YN=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,ZN=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,QN=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,JN=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,eR=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,tR=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,nR=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,rR=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,iR=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,sR=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,oR=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,aR=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,lR=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,uR=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,cR=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,hR=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,fR=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,dR=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,pR=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,mR=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,gR=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,yR=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,_R=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,bR=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,xR=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,vR=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,wR=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,SR=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,TR=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,ER=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,MR=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,AR=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,IR=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,CR=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,kR=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,NR=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,RR=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,PR=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,LR=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,DR=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,OR=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,FR=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,$R=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const zR=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,BR=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,UR=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,VR=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,WR=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,GR=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,HR=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,jR=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,qR=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,KR=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,XR=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,YR=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ZR=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,QR=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,JR=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,eP=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,tP=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,nP=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,rP=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,iP=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,sP=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,oP=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,aP=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,lP=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uP=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,cP=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hP=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fP=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dP=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,pP=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,mP=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gP=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,yP=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,_P=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,wt={alphamap_fragment:Uk,alphamap_pars_fragment:Vk,alphatest_fragment:Wk,alphatest_pars_fragment:Gk,aomap_fragment:Hk,aomap_pars_fragment:jk,begin_vertex:qk,beginnormal_vertex:Kk,bsdfs:Xk,iridescence_fragment:Yk,bumpmap_pars_fragment:Zk,clipping_planes_fragment:Qk,clipping_planes_pars_fragment:Jk,clipping_planes_pars_vertex:eN,clipping_planes_vertex:tN,color_fragment:nN,color_pars_fragment:rN,color_pars_vertex:iN,color_vertex:sN,common:oN,cube_uv_reflection_fragment:aN,defaultnormal_vertex:lN,displacementmap_pars_vertex:uN,displacementmap_vertex:cN,emissivemap_fragment:hN,emissivemap_pars_fragment:fN,encodings_fragment:dN,encodings_pars_fragment:pN,envmap_fragment:mN,envmap_common_pars_fragment:gN,envmap_pars_fragment:yN,envmap_pars_vertex:_N,envmap_physical_pars_fragment:kN,envmap_vertex:bN,fog_vertex:xN,fog_pars_vertex:vN,fog_fragment:wN,fog_pars_fragment:SN,gradientmap_pars_fragment:TN,lightmap_fragment:EN,lightmap_pars_fragment:MN,lights_lambert_fragment:AN,lights_lambert_pars_fragment:IN,lights_pars_begin:CN,lights_toon_fragment:NN,lights_toon_pars_fragment:RN,lights_phong_fragment:PN,lights_phong_pars_fragment:LN,lights_physical_fragment:DN,lights_physical_pars_fragment:ON,lights_fragment_begin:FN,lights_fragment_maps:$N,lights_fragment_end:zN,logdepthbuf_fragment:BN,logdepthbuf_pars_fragment:UN,logdepthbuf_pars_vertex:VN,logdepthbuf_vertex:WN,map_fragment:GN,map_pars_fragment:HN,map_particle_fragment:jN,map_particle_pars_fragment:qN,metalnessmap_fragment:KN,metalnessmap_pars_fragment:XN,morphcolor_vertex:YN,morphnormal_vertex:ZN,morphtarget_pars_vertex:QN,morphtarget_vertex:JN,normal_fragment_begin:eR,normal_fragment_maps:tR,normal_pars_fragment:nR,normal_pars_vertex:rR,normal_vertex:iR,normalmap_pars_fragment:sR,clearcoat_normal_fragment_begin:oR,clearcoat_normal_fragment_maps:aR,clearcoat_pars_fragment:lR,iridescence_pars_fragment:uR,output_fragment:cR,packing:hR,premultiplied_alpha_fragment:fR,project_vertex:dR,dithering_fragment:pR,dithering_pars_fragment:mR,roughnessmap_fragment:gR,roughnessmap_pars_fragment:yR,shadowmap_pars_fragment:_R,shadowmap_pars_vertex:bR,shadowmap_vertex:xR,shadowmask_pars_fragment:vR,skinbase_vertex:wR,skinning_pars_vertex:SR,skinning_vertex:TR,skinnormal_vertex:ER,specularmap_fragment:MR,specularmap_pars_fragment:AR,tonemapping_fragment:IR,tonemapping_pars_fragment:CR,transmission_fragment:kR,transmission_pars_fragment:NR,uv_pars_fragment:RR,uv_pars_vertex:PR,uv_vertex:LR,uv2_pars_fragment:DR,uv2_pars_vertex:OR,uv2_vertex:FR,worldpos_vertex:$R,background_vert:zR,background_frag:BR,backgroundCube_vert:UR,backgroundCube_frag:VR,cube_vert:WR,cube_frag:GR,depth_vert:HR,depth_frag:jR,distanceRGBA_vert:qR,distanceRGBA_frag:KR,equirect_vert:XR,equirect_frag:YR,linedashed_vert:ZR,linedashed_frag:QR,meshbasic_vert:JR,meshbasic_frag:eP,meshlambert_vert:tP,meshlambert_frag:nP,meshmatcap_vert:rP,meshmatcap_frag:iP,meshnormal_vert:sP,meshnormal_frag:oP,meshphong_vert:aP,meshphong_frag:lP,meshphysical_vert:uP,meshphysical_frag:cP,meshtoon_vert:hP,meshtoon_frag:fP,points_vert:dP,points_frag:pP,shadow_vert:mP,shadow_frag:gP,sprite_vert:yP,sprite_frag:_P},$e={common:{diffuse:{value:new gt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new gr},uv2Transform:{value:new gr},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new mt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new gt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new gt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new gr}},sprite:{diffuse:{value:new gt(16777215)},opacity:{value:1},center:{value:new mt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new gr}}},qi={basic:{uniforms:fr([$e.common,$e.specularmap,$e.envmap,$e.aomap,$e.lightmap,$e.fog]),vertexShader:wt.meshbasic_vert,fragmentShader:wt.meshbasic_frag},lambert:{uniforms:fr([$e.common,$e.specularmap,$e.envmap,$e.aomap,$e.lightmap,$e.emissivemap,$e.bumpmap,$e.normalmap,$e.displacementmap,$e.fog,$e.lights,{emissive:{value:new gt(0)}}]),vertexShader:wt.meshlambert_vert,fragmentShader:wt.meshlambert_frag},phong:{uniforms:fr([$e.common,$e.specularmap,$e.envmap,$e.aomap,$e.lightmap,$e.emissivemap,$e.bumpmap,$e.normalmap,$e.displacementmap,$e.fog,$e.lights,{emissive:{value:new gt(0)},specular:{value:new gt(1118481)},shininess:{value:30}}]),vertexShader:wt.meshphong_vert,fragmentShader:wt.meshphong_frag},standard:{uniforms:fr([$e.common,$e.envmap,$e.aomap,$e.lightmap,$e.emissivemap,$e.bumpmap,$e.normalmap,$e.displacementmap,$e.roughnessmap,$e.metalnessmap,$e.fog,$e.lights,{emissive:{value:new gt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:wt.meshphysical_vert,fragmentShader:wt.meshphysical_frag},toon:{uniforms:fr([$e.common,$e.aomap,$e.lightmap,$e.emissivemap,$e.bumpmap,$e.normalmap,$e.displacementmap,$e.gradientmap,$e.fog,$e.lights,{emissive:{value:new gt(0)}}]),vertexShader:wt.meshtoon_vert,fragmentShader:wt.meshtoon_frag},matcap:{uniforms:fr([$e.common,$e.bumpmap,$e.normalmap,$e.displacementmap,$e.fog,{matcap:{value:null}}]),vertexShader:wt.meshmatcap_vert,fragmentShader:wt.meshmatcap_frag},points:{uniforms:fr([$e.points,$e.fog]),vertexShader:wt.points_vert,fragmentShader:wt.points_frag},dashed:{uniforms:fr([$e.common,$e.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:wt.linedashed_vert,fragmentShader:wt.linedashed_frag},depth:{uniforms:fr([$e.common,$e.displacementmap]),vertexShader:wt.depth_vert,fragmentShader:wt.depth_frag},normal:{uniforms:fr([$e.common,$e.bumpmap,$e.normalmap,$e.displacementmap,{opacity:{value:1}}]),vertexShader:wt.meshnormal_vert,fragmentShader:wt.meshnormal_frag},sprite:{uniforms:fr([$e.sprite,$e.fog]),vertexShader:wt.sprite_vert,fragmentShader:wt.sprite_frag},background:{uniforms:{uvTransform:{value:new gr},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:wt.background_vert,fragmentShader:wt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:wt.backgroundCube_vert,fragmentShader:wt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:wt.cube_vert,fragmentShader:wt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:wt.equirect_vert,fragmentShader:wt.equirect_frag},distanceRGBA:{uniforms:fr([$e.common,$e.displacementmap,{referencePosition:{value:new ie},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:wt.distanceRGBA_vert,fragmentShader:wt.distanceRGBA_frag},shadow:{uniforms:fr([$e.lights,$e.fog,{color:{value:new gt(0)},opacity:{value:1}}]),vertexShader:wt.shadow_vert,fragmentShader:wt.shadow_frag}};qi.physical={uniforms:fr([qi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new mt(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new gt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new mt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new gt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new gt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:wt.meshphysical_vert,fragmentShader:wt.meshphysical_frag};const fh={r:0,b:0,g:0};function bP(r,e,t,n,i,s,o){const a=new gt(0);let l=s===!0?0:1,u,c,h=null,f=0,d=null;function g(m,_){let v=!1,b=_.isScene===!0?_.background:null;b&&b.isTexture&&(b=(_.backgroundBlurriness>0?t:e).get(b));const x=r.xr,T=x.getSession&&x.getSession();T&&T.environmentBlendMode==="additive"&&(b=null),b===null?p(a,l):b&&b.isColor&&(p(b,1),v=!0),(r.autoClear||v)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),b&&(b.isCubeTexture||b.mapping===Cf)?(c===void 0&&(c=new Ur(new Nc(1,1,1),new va({name:"BackgroundCubeMaterial",uniforms:Fl(qi.backgroundCube.uniforms),vertexShader:qi.backgroundCube.vertexShader,fragmentShader:qi.backgroundCube.fragmentShader,side:Vr,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(I,C,S){this.matrixWorld.copyPosition(S.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=b,c.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=_.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,c.material.toneMapped=b.encoding!==$t,(h!==b||f!==b.version||d!==r.toneMapping)&&(c.material.needsUpdate=!0,h=b,f=b.version,d=r.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null)):b&&b.isTexture&&(u===void 0&&(u=new Ur(new Wg(2,2),new va({name:"BackgroundMaterial",uniforms:Fl(qi.background.uniforms),vertexShader:qi.background.vertexShader,fragmentShader:qi.background.fragmentShader,side:Rs,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(u)),u.material.uniforms.t2D.value=b,u.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,u.material.toneMapped=b.encoding!==$t,b.matrixAutoUpdate===!0&&b.updateMatrix(),u.material.uniforms.uvTransform.value.copy(b.matrix),(h!==b||f!==b.version||d!==r.toneMapping)&&(u.material.needsUpdate=!0,h=b,f=b.version,d=r.toneMapping),u.layers.enableAll(),m.unshift(u,u.geometry,u.material,0,0,null))}function p(m,_){m.getRGB(fh,Ow(r)),n.buffers.color.setClear(fh.r,fh.g,fh.b,_,o)}return{getClearColor:function(){return a},setClearColor:function(m,_=1){a.set(m),l=_,p(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(m){l=m,p(a,l)},render:g}}function xP(r,e,t,n){const i=r.getParameter(34921),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),o=n.isWebGL2||s!==null,a={},l=m(null);let u=l,c=!1;function h(z,H,Q,Z,Y){let fe=!1;if(o){const le=p(Z,Q,H);u!==le&&(u=le,d(u.object)),fe=_(z,Z,Q,Y),fe&&v(z,Z,Q,Y)}else{const le=H.wireframe===!0;(u.geometry!==Z.id||u.program!==Q.id||u.wireframe!==le)&&(u.geometry=Z.id,u.program=Q.id,u.wireframe=le,fe=!0)}Y!==null&&t.update(Y,34963),(fe||c)&&(c=!1,S(z,H,Q,Z),Y!==null&&r.bindBuffer(34963,t.get(Y).buffer))}function f(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function d(z){return n.isWebGL2?r.bindVertexArray(z):s.bindVertexArrayOES(z)}function g(z){return n.isWebGL2?r.deleteVertexArray(z):s.deleteVertexArrayOES(z)}function p(z,H,Q){const Z=Q.wireframe===!0;let Y=a[z.id];Y===void 0&&(Y={},a[z.id]=Y);let fe=Y[H.id];fe===void 0&&(fe={},Y[H.id]=fe);let le=fe[Z];return le===void 0&&(le=m(f()),fe[Z]=le),le}function m(z){const H=[],Q=[],Z=[];for(let Y=0;Y<i;Y++)H[Y]=0,Q[Y]=0,Z[Y]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:H,enabledAttributes:Q,attributeDivisors:Z,object:z,attributes:{},index:null}}function _(z,H,Q,Z){const Y=u.attributes,fe=H.attributes;let le=0;const ve=Q.getAttributes();for(const ee in ve)if(ve[ee].location>=0){const Te=Y[ee];let ne=fe[ee];if(ne===void 0&&(ee==="instanceMatrix"&&z.instanceMatrix&&(ne=z.instanceMatrix),ee==="instanceColor"&&z.instanceColor&&(ne=z.instanceColor)),Te===void 0||Te.attribute!==ne||ne&&Te.data!==ne.data)return!0;le++}return u.attributesNum!==le||u.index!==Z}function v(z,H,Q,Z){const Y={},fe=H.attributes;let le=0;const ve=Q.getAttributes();for(const ee in ve)if(ve[ee].location>=0){let Te=fe[ee];Te===void 0&&(ee==="instanceMatrix"&&z.instanceMatrix&&(Te=z.instanceMatrix),ee==="instanceColor"&&z.instanceColor&&(Te=z.instanceColor));const ne={};ne.attribute=Te,Te&&Te.data&&(ne.data=Te.data),Y[ee]=ne,le++}u.attributes=Y,u.attributesNum=le,u.index=Z}function b(){const z=u.newAttributes;for(let H=0,Q=z.length;H<Q;H++)z[H]=0}function x(z){T(z,0)}function T(z,H){const Q=u.newAttributes,Z=u.enabledAttributes,Y=u.attributeDivisors;Q[z]=1,Z[z]===0&&(r.enableVertexAttribArray(z),Z[z]=1),Y[z]!==H&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](z,H),Y[z]=H)}function I(){const z=u.newAttributes,H=u.enabledAttributes;for(let Q=0,Z=H.length;Q<Z;Q++)H[Q]!==z[Q]&&(r.disableVertexAttribArray(Q),H[Q]=0)}function C(z,H,Q,Z,Y,fe){n.isWebGL2===!0&&(Q===5124||Q===5125)?r.vertexAttribIPointer(z,H,Q,Y,fe):r.vertexAttribPointer(z,H,Q,Z,Y,fe)}function S(z,H,Q,Z){if(n.isWebGL2===!1&&(z.isInstancedMesh||Z.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const Y=Z.attributes,fe=Q.getAttributes(),le=H.defaultAttributeValues;for(const ve in fe){const ee=fe[ve];if(ee.location>=0){let _e=Y[ve];if(_e===void 0&&(ve==="instanceMatrix"&&z.instanceMatrix&&(_e=z.instanceMatrix),ve==="instanceColor"&&z.instanceColor&&(_e=z.instanceColor)),_e!==void 0){const Te=_e.normalized,ne=_e.itemSize,Le=t.get(_e);if(Le===void 0)continue;const Ve=Le.buffer,He=Le.type,We=Le.bytesPerElement;if(_e.isInterleavedBufferAttribute){const Je=_e.data,nt=Je.stride,U=_e.offset;if(Je.isInstancedInterleavedBuffer){for(let j=0;j<ee.locationSize;j++)T(ee.location+j,Je.meshPerAttribute);z.isInstancedMesh!==!0&&Z._maxInstanceCount===void 0&&(Z._maxInstanceCount=Je.meshPerAttribute*Je.count)}else for(let j=0;j<ee.locationSize;j++)x(ee.location+j);r.bindBuffer(34962,Ve);for(let j=0;j<ee.locationSize;j++)C(ee.location+j,ne/ee.locationSize,He,Te,nt*We,(U+ne/ee.locationSize*j)*We)}else{if(_e.isInstancedBufferAttribute){for(let Je=0;Je<ee.locationSize;Je++)T(ee.location+Je,_e.meshPerAttribute);z.isInstancedMesh!==!0&&Z._maxInstanceCount===void 0&&(Z._maxInstanceCount=_e.meshPerAttribute*_e.count)}else for(let Je=0;Je<ee.locationSize;Je++)x(ee.location+Je);r.bindBuffer(34962,Ve);for(let Je=0;Je<ee.locationSize;Je++)C(ee.location+Je,ne/ee.locationSize,He,Te,ne*We,ne/ee.locationSize*Je*We)}}else if(le!==void 0){const Te=le[ve];if(Te!==void 0)switch(Te.length){case 2:r.vertexAttrib2fv(ee.location,Te);break;case 3:r.vertexAttrib3fv(ee.location,Te);break;case 4:r.vertexAttrib4fv(ee.location,Te);break;default:r.vertexAttrib1fv(ee.location,Te)}}}}I()}function A(){q();for(const z in a){const H=a[z];for(const Q in H){const Z=H[Q];for(const Y in Z)g(Z[Y].object),delete Z[Y];delete H[Q]}delete a[z]}}function R(z){if(a[z.id]===void 0)return;const H=a[z.id];for(const Q in H){const Z=H[Q];for(const Y in Z)g(Z[Y].object),delete Z[Y];delete H[Q]}delete a[z.id]}function F(z){for(const H in a){const Q=a[H];if(Q[z.id]===void 0)continue;const Z=Q[z.id];for(const Y in Z)g(Z[Y].object),delete Z[Y];delete Q[z.id]}}function q(){O(),c=!0,u!==l&&(u=l,d(u.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:q,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:R,releaseStatesOfProgram:F,initAttributes:b,enableAttribute:x,disableUnusedAttributes:I}}function vP(r,e,t,n){const i=n.isWebGL2;let s;function o(u){s=u}function a(u,c){r.drawArrays(s,u,c),t.update(c,s,1)}function l(u,c,h){if(h===0)return;let f,d;if(i)f=r,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](s,u,c,h),t.update(c,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function wP(r,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const C=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(C){if(C==="highp"){if(r.getShaderPrecisionFormat(35633,36338).precision>0&&r.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&r.getShaderPrecisionFormat(35633,36337).precision>0&&r.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&r instanceof WebGL2RenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const u=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,h=r.getParameter(34930),f=r.getParameter(35660),d=r.getParameter(3379),g=r.getParameter(34076),p=r.getParameter(34921),m=r.getParameter(36347),_=r.getParameter(36348),v=r.getParameter(36349),b=f>0,x=o||e.has("OES_texture_float"),T=b&&x,I=o?r.getParameter(36183):0;return{isWebGL2:o,drawBuffers:u,getMaxAnisotropy:i,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:f,maxTextureSize:d,maxCubemapSize:g,maxAttributes:p,maxVertexUniforms:m,maxVaryings:_,maxFragmentUniforms:v,vertexTextures:b,floatFragmentTextures:x,floatVertexTextures:T,maxSamples:I}}function SP(r){const e=this;let t=null,n=0,i=!1,s=!1;const o=new Wo,a=new gr,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f){const d=h.length!==0||f||n!==0||i;return i=f,n=h.length,d},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(h,f){t=c(h,f,0)},this.setState=function(h,f,d){const g=h.clippingPlanes,p=h.clipIntersection,m=h.clipShadows,_=r.get(h);if(!i||g===null||g.length===0||s&&!m)s?c(null):u();else{const v=s?0:n,b=v*4;let x=_.clippingState||null;l.value=x,x=c(g,f,b,d);for(let T=0;T!==b;++T)x[T]=t[T];_.clippingState=x,this.numIntersection=p?this.numPlanes:0,this.numPlanes+=v}};function u(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function c(h,f,d,g){const p=h!==null?h.length:0;let m=null;if(p!==0){if(m=l.value,g!==!0||m===null){const _=d+p*4,v=f.matrixWorldInverse;a.getNormalMatrix(v),(m===null||m.length<_)&&(m=new Float32Array(_));for(let b=0,x=d;b!==p;++b,x+=4)o.copy(h[b]).applyMatrix4(v,a),o.normal.toArray(m,x),m[x+3]=o.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=p,e.numIntersection=0,m}}function TP(r){let e=new WeakMap;function t(o,a){return a===Hp?o.mapping=Rl:a===jp&&(o.mapping=Pl),o}function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Hp||a===jp)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const u=new Fk(l.height/2);return u.fromEquirectangularTexture(r,o),e.set(o,u),o.addEventListener("dispose",i),t(u.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class Gg extends Fw{constructor(e=-1,t=1,n=1,i=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-e,o=n+e,a=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=u*this.view.offsetX,o=s+u*this.view.width,a-=c*this.view.offsetY,l=a-c*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const dl=4,B_=[.125,.215,.35,.446,.526,.582],Zo=20,jd=new Gg,U_=new gt;let qd=null;const Go=(1+Math.sqrt(5))/2,rl=1/Go,V_=[new ie(1,1,1),new ie(-1,1,1),new ie(1,1,-1),new ie(-1,1,-1),new ie(0,Go,rl),new ie(0,Go,-rl),new ie(rl,0,Go),new ie(-rl,0,Go),new ie(Go,rl,0),new ie(-Go,rl,0)];class W_{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){qd=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=j_(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=H_(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(qd),e.scissorTest=!1,dh(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Rl||e.mapping===Pl?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),qd=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:Er,minFilter:Er,generateMipmaps:!1,type:ac,format:fi,encoding:ba,depthBuffer:!1},i=G_(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=G_(e,t,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=EP(s)),this._blurMaterial=MP(s,e,t)}return i}_compileMaterial(e){const t=new Ur(this._lodPlanes[0],e);this._renderer.compile(t,jd)}_sceneToCubeUV(e,t,n,i){const a=new dr(90,1,t,n),l=[1,-1,1,1,1,1],u=[1,1,1,-1,-1,-1],c=this._renderer,h=c.autoClear,f=c.toneMapping;c.getClearColor(U_),c.toneMapping=As,c.autoClear=!1;const d=new ta({name:"PMREM.Background",side:Vr,depthWrite:!1,depthTest:!1}),g=new Ur(new Nc,d);let p=!1;const m=e.background;m?m.isColor&&(d.color.copy(m),e.background=null,p=!0):(d.color.copy(U_),p=!0);for(let _=0;_<6;_++){const v=_%3;v===0?(a.up.set(0,l[_],0),a.lookAt(u[_],0,0)):v===1?(a.up.set(0,0,l[_]),a.lookAt(0,u[_],0)):(a.up.set(0,l[_],0),a.lookAt(0,0,u[_]));const b=this._cubeSize;dh(i,v*b,_>2?b:0,b,b),c.setRenderTarget(i),p&&c.render(g,a),c.render(e,a)}g.geometry.dispose(),g.material.dispose(),c.toneMapping=f,c.autoClear=h,e.background=m}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===Rl||e.mapping===Pl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=j_()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=H_());const s=i?this._cubemapMaterial:this._equirectMaterial,o=new Ur(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;dh(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(o,jd)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=V_[(i-1)%V_.length];this._blur(e,i-1,i,s,o)}t.autoClear=n}_blur(e,t,n,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,n,i,"latitudinal",s),this._halfBlur(o,e,n,n,i,"longitudinal",s)}_halfBlur(e,t,n,i,s,o,a){const l=this._renderer,u=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,h=new Ur(this._lodPlanes[i],u),f=u.uniforms,d=this._sizeLods[n]-1,g=isFinite(s)?Math.PI/(2*d):2*Math.PI/(2*Zo-1),p=s/g,m=isFinite(s)?1+Math.floor(c*p):Zo;m>Zo&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Zo}`);const _=[];let v=0;for(let C=0;C<Zo;++C){const S=C/p,A=Math.exp(-S*S/2);_.push(A),C===0?v+=A:C<m&&(v+=2*A)}for(let C=0;C<_.length;C++)_[C]=_[C]/v;f.envMap.value=e.texture,f.samples.value=m,f.weights.value=_,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a);const{_lodMax:b}=this;f.dTheta.value=g,f.mipInt.value=b-n;const x=this._sizeLods[i],T=3*x*(i>b-dl?i-b+dl:0),I=4*(this._cubeSize-x);dh(t,T,I,3*x,2*x),l.setRenderTarget(t),l.render(h,jd)}}function EP(r){const e=[],t=[],n=[];let i=r;const s=r-dl+1+B_.length;for(let o=0;o<s;o++){const a=Math.pow(2,i);t.push(a);let l=1/a;o>r-dl?l=B_[o-r+dl-1]:o===0&&(l=0),n.push(l);const u=1/(a-2),c=-u,h=1+u,f=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,g=6,p=3,m=2,_=1,v=new Float32Array(p*g*d),b=new Float32Array(m*g*d),x=new Float32Array(_*g*d);for(let I=0;I<d;I++){const C=I%3*2/3-1,S=I>2?0:-1,A=[C,S,0,C+2/3,S,0,C+2/3,S+1,0,C,S,0,C+2/3,S+1,0,C,S+1,0];v.set(A,p*g*I),b.set(f,m*g*I);const R=[I,I,I,I,I,I];x.set(R,_*g*I)}const T=new Kr;T.setAttribute("position",new _r(v,p)),T.setAttribute("uv",new _r(b,m)),T.setAttribute("faceIndex",new _r(x,_)),e.push(T),i>dl&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function G_(r,e,t){const n=new xa(r,e,t);return n.texture.mapping=Cf,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function dh(r,e,t,n,i){r.viewport.set(e,t,n,i),r.scissor.set(e,t,n,i)}function MP(r,e,t){const n=new Float32Array(Zo),i=new ie(0,1,0);return new va({name:"SphericalGaussianBlur",defines:{n:Zo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${r}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Hg(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:mo,depthTest:!1,depthWrite:!1})}function H_(){return new va({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Hg(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:mo,depthTest:!1,depthWrite:!1})}function j_(){return new va({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Hg(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:mo,depthTest:!1,depthWrite:!1})}function Hg(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function AP(r){let e=new WeakMap,t=null;function n(a){if(a&&a.isTexture){const l=a.mapping,u=l===Hp||l===jp,c=l===Rl||l===Pl;if(u||c)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new W_(r)),h=u?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(u&&h&&h.height>0||c&&h&&i(h)){t===null&&(t=new W_(r));const f=u?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,f),a.addEventListener("dispose",s),f.texture}else return null}}}return a}function i(a){let l=0;const u=6;for(let c=0;c<u;c++)a[c]!==void 0&&l++;return l===u}function s(a){const l=a.target;l.removeEventListener("dispose",s);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:o}}function IP(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function CP(r,e,t,n){const i={},s=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const g in f.attributes)e.remove(f.attributes[g]);f.removeEventListener("dispose",o),delete i[f.id];const d=s.get(f);d&&(e.remove(d),s.delete(f)),n.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return i[f.id]===!0||(f.addEventListener("dispose",o),i[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const g in f)e.update(f[g],34962);const d=h.morphAttributes;for(const g in d){const p=d[g];for(let m=0,_=p.length;m<_;m++)e.update(p[m],34962)}}function u(h){const f=[],d=h.index,g=h.attributes.position;let p=0;if(d!==null){const v=d.array;p=d.version;for(let b=0,x=v.length;b<x;b+=3){const T=v[b+0],I=v[b+1],C=v[b+2];f.push(T,I,I,C,C,T)}}else{const v=g.array;p=g.version;for(let b=0,x=v.length/3-1;b<x;b+=3){const T=b+0,I=b+1,C=b+2;f.push(T,I,I,C,C,T)}}const m=new(Iw(f)?Dw:Lw)(f,1);m.version=p;const _=s.get(h);_&&e.remove(_),s.set(h,m)}function c(h){const f=s.get(h);if(f){const d=h.index;d!==null&&f.version<d.version&&u(h)}else u(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:c}}function kP(r,e,t,n){const i=n.isWebGL2;let s;function o(f){s=f}let a,l;function u(f){a=f.type,l=f.bytesPerElement}function c(f,d){r.drawElements(s,d,a,f*l),t.update(d,s,1)}function h(f,d,g){if(g===0)return;let p,m;if(i)p=r,m="drawElementsInstanced";else if(p=e.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",p===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[m](s,d,a,f*l,g),t.update(d,s,g)}this.setMode=o,this.setIndex=u,this.render=c,this.renderInstances=h}function NP(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(s/3);break;case 1:t.lines+=a*(s/2);break;case 3:t.lines+=a*(s-1);break;case 2:t.lines+=a*s;break;case 0:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function RP(r,e){return r[0]-e[0]}function PP(r,e){return Math.abs(e[1])-Math.abs(r[1])}function LP(r,e,t){const n={},i=new Float32Array(8),s=new WeakMap,o=new Yt,a=[];for(let u=0;u<8;u++)a[u]=[u,0];function l(u,c,h){const f=u.morphTargetInfluences;if(e.isWebGL2===!0){const g=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,p=g!==void 0?g.length:0;let m=s.get(c);if(m===void 0||m.count!==p){let H=function(){O.dispose(),s.delete(c),c.removeEventListener("dispose",H)};var d=H;m!==void 0&&m.texture.dispose();const b=c.morphAttributes.position!==void 0,x=c.morphAttributes.normal!==void 0,T=c.morphAttributes.color!==void 0,I=c.morphAttributes.position||[],C=c.morphAttributes.normal||[],S=c.morphAttributes.color||[];let A=0;b===!0&&(A=1),x===!0&&(A=2),T===!0&&(A=3);let R=c.attributes.position.count*A,F=1;R>e.maxTextureSize&&(F=Math.ceil(R/e.maxTextureSize),R=e.maxTextureSize);const q=new Float32Array(R*F*4*p),O=new Nw(q,R,F,p);O.type=io,O.needsUpdate=!0;const z=A*4;for(let Q=0;Q<p;Q++){const Z=I[Q],Y=C[Q],fe=S[Q],le=R*F*4*Q;for(let ve=0;ve<Z.count;ve++){const ee=ve*z;b===!0&&(o.fromBufferAttribute(Z,ve),q[le+ee+0]=o.x,q[le+ee+1]=o.y,q[le+ee+2]=o.z,q[le+ee+3]=0),x===!0&&(o.fromBufferAttribute(Y,ve),q[le+ee+4]=o.x,q[le+ee+5]=o.y,q[le+ee+6]=o.z,q[le+ee+7]=0),T===!0&&(o.fromBufferAttribute(fe,ve),q[le+ee+8]=o.x,q[le+ee+9]=o.y,q[le+ee+10]=o.z,q[le+ee+11]=fe.itemSize===4?o.w:1)}}m={count:p,texture:O,size:new mt(R,F)},s.set(c,m),c.addEventListener("dispose",H)}let _=0;for(let b=0;b<f.length;b++)_+=f[b];const v=c.morphTargetsRelative?1:1-_;h.getUniforms().setValue(r,"morphTargetBaseInfluence",v),h.getUniforms().setValue(r,"morphTargetInfluences",f),h.getUniforms().setValue(r,"morphTargetsTexture",m.texture,t),h.getUniforms().setValue(r,"morphTargetsTextureSize",m.size)}else{const g=f===void 0?0:f.length;let p=n[c.id];if(p===void 0||p.length!==g){p=[];for(let x=0;x<g;x++)p[x]=[x,0];n[c.id]=p}for(let x=0;x<g;x++){const T=p[x];T[0]=x,T[1]=f[x]}p.sort(PP);for(let x=0;x<8;x++)x<g&&p[x][1]?(a[x][0]=p[x][0],a[x][1]=p[x][1]):(a[x][0]=Number.MAX_SAFE_INTEGER,a[x][1]=0);a.sort(RP);const m=c.morphAttributes.position,_=c.morphAttributes.normal;let v=0;for(let x=0;x<8;x++){const T=a[x],I=T[0],C=T[1];I!==Number.MAX_SAFE_INTEGER&&C?(m&&c.getAttribute("morphTarget"+x)!==m[I]&&c.setAttribute("morphTarget"+x,m[I]),_&&c.getAttribute("morphNormal"+x)!==_[I]&&c.setAttribute("morphNormal"+x,_[I]),i[x]=C,v+=C):(m&&c.hasAttribute("morphTarget"+x)===!0&&c.deleteAttribute("morphTarget"+x),_&&c.hasAttribute("morphNormal"+x)===!0&&c.deleteAttribute("morphNormal"+x),i[x]=0)}const b=c.morphTargetsRelative?1:1-v;h.getUniforms().setValue(r,"morphTargetBaseInfluence",b),h.getUniforms().setValue(r,"morphTargetInfluences",i)}}return{update:l}}function DP(r,e,t,n){let i=new WeakMap;function s(l){const u=n.render.frame,c=l.geometry,h=e.get(l,c);return i.get(h)!==u&&(e.update(h),i.set(h,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){i=new WeakMap}function a(l){const u=l.target;u.removeEventListener("dispose",a),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:s,dispose:o}}const Bw=new Hn,Uw=new Nw,Vw=new vk,Ww=new $w,q_=[],K_=[],X_=new Float32Array(16),Y_=new Float32Array(9),Z_=new Float32Array(4);function su(r,e,t){const n=r[0];if(n<=0||n>0)return r;const i=e*t;let s=q_[i];if(s===void 0&&(s=new Float32Array(i),q_[i]=s),e!==0){n.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,r[o].toArray(s,a)}return s}function Nn(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function Rn(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function Nf(r,e){let t=K_[e];t===void 0&&(t=new Int32Array(e),K_[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function OP(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function FP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Nn(t,e))return;r.uniform2fv(this.addr,e),Rn(t,e)}}function $P(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Nn(t,e))return;r.uniform3fv(this.addr,e),Rn(t,e)}}function zP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Nn(t,e))return;r.uniform4fv(this.addr,e),Rn(t,e)}}function BP(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Nn(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),Rn(t,e)}else{if(Nn(t,n))return;Z_.set(n),r.uniformMatrix2fv(this.addr,!1,Z_),Rn(t,n)}}function UP(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Nn(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),Rn(t,e)}else{if(Nn(t,n))return;Y_.set(n),r.uniformMatrix3fv(this.addr,!1,Y_),Rn(t,n)}}function VP(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Nn(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),Rn(t,e)}else{if(Nn(t,n))return;X_.set(n),r.uniformMatrix4fv(this.addr,!1,X_),Rn(t,n)}}function WP(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function GP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Nn(t,e))return;r.uniform2iv(this.addr,e),Rn(t,e)}}function HP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Nn(t,e))return;r.uniform3iv(this.addr,e),Rn(t,e)}}function jP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Nn(t,e))return;r.uniform4iv(this.addr,e),Rn(t,e)}}function qP(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function KP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Nn(t,e))return;r.uniform2uiv(this.addr,e),Rn(t,e)}}function XP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Nn(t,e))return;r.uniform3uiv(this.addr,e),Rn(t,e)}}function YP(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Nn(t,e))return;r.uniform4uiv(this.addr,e),Rn(t,e)}}function ZP(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||Bw,i)}function QP(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||Vw,i)}function JP(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||Ww,i)}function eL(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||Uw,i)}function tL(r){switch(r){case 5126:return OP;case 35664:return FP;case 35665:return $P;case 35666:return zP;case 35674:return BP;case 35675:return UP;case 35676:return VP;case 5124:case 35670:return WP;case 35667:case 35671:return GP;case 35668:case 35672:return HP;case 35669:case 35673:return jP;case 5125:return qP;case 36294:return KP;case 36295:return XP;case 36296:return YP;case 35678:case 36198:case 36298:case 36306:case 35682:return ZP;case 35679:case 36299:case 36307:return QP;case 35680:case 36300:case 36308:case 36293:return JP;case 36289:case 36303:case 36311:case 36292:return eL}}function nL(r,e){r.uniform1fv(this.addr,e)}function rL(r,e){const t=su(e,this.size,2);r.uniform2fv(this.addr,t)}function iL(r,e){const t=su(e,this.size,3);r.uniform3fv(this.addr,t)}function sL(r,e){const t=su(e,this.size,4);r.uniform4fv(this.addr,t)}function oL(r,e){const t=su(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function aL(r,e){const t=su(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function lL(r,e){const t=su(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function uL(r,e){r.uniform1iv(this.addr,e)}function cL(r,e){r.uniform2iv(this.addr,e)}function hL(r,e){r.uniform3iv(this.addr,e)}function fL(r,e){r.uniform4iv(this.addr,e)}function dL(r,e){r.uniform1uiv(this.addr,e)}function pL(r,e){r.uniform2uiv(this.addr,e)}function mL(r,e){r.uniform3uiv(this.addr,e)}function gL(r,e){r.uniform4uiv(this.addr,e)}function yL(r,e,t){const n=this.cache,i=e.length,s=Nf(t,i);Nn(n,s)||(r.uniform1iv(this.addr,s),Rn(n,s));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||Bw,s[o])}function _L(r,e,t){const n=this.cache,i=e.length,s=Nf(t,i);Nn(n,s)||(r.uniform1iv(this.addr,s),Rn(n,s));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||Vw,s[o])}function bL(r,e,t){const n=this.cache,i=e.length,s=Nf(t,i);Nn(n,s)||(r.uniform1iv(this.addr,s),Rn(n,s));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||Ww,s[o])}function xL(r,e,t){const n=this.cache,i=e.length,s=Nf(t,i);Nn(n,s)||(r.uniform1iv(this.addr,s),Rn(n,s));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||Uw,s[o])}function vL(r){switch(r){case 5126:return nL;case 35664:return rL;case 35665:return iL;case 35666:return sL;case 35674:return oL;case 35675:return aL;case 35676:return lL;case 5124:case 35670:return uL;case 35667:case 35671:return cL;case 35668:case 35672:return hL;case 35669:case 35673:return fL;case 5125:return dL;case 36294:return pL;case 36295:return mL;case 36296:return gL;case 35678:case 36198:case 36298:case 36306:case 35682:return yL;case 35679:case 36299:case 36307:return _L;case 35680:case 36300:case 36308:case 36293:return bL;case 36289:case 36303:case 36311:case 36292:return xL}}class wL{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=tL(t.type)}}class SL{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=vL(t.type)}}class TL{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let s=0,o=i.length;s!==o;++s){const a=i[s];a.setValue(e,t[a.id],n)}}}const Kd=/(\w+)(\])?(\[|\.)?/g;function Q_(r,e){r.seq.push(e),r.map[e.id]=e}function EL(r,e,t){const n=r.name,i=n.length;for(Kd.lastIndex=0;;){const s=Kd.exec(n),o=Kd.lastIndex;let a=s[1];const l=s[2]==="]",u=s[3];if(l&&(a=a|0),u===void 0||u==="["&&o+2===i){Q_(t,u===void 0?new wL(a,r,e):new SL(a,r,e));break}else{let h=t.map[a];h===void 0&&(h=new TL(a),Q_(t,h)),t=h}}}class Ch{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let i=0;i<n;++i){const s=e.getActiveUniform(t,i),o=e.getUniformLocation(t,s.name);EL(s,o,this)}}setValue(e,t,n,i){const s=this.map[t];s!==void 0&&s.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let s=0,o=t.length;s!==o;++s){const a=t[s],l=n[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,s=e.length;i!==s;++i){const o=e[i];o.id in t&&n.push(o)}return n}}function J_(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}let ML=0;function AL(r,e){const t=r.split(`
`),n=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=i;o<s;o++){const a=o+1;n.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return n.join(`
`)}function IL(r){switch(r){case ba:return["Linear","( value )"];case $t:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",r),["Linear","( value )"]}}function eb(r,e,t){const n=r.getShaderParameter(e,35713),i=r.getShaderInfoLog(e).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+AL(r.getShaderSource(e),o)}else return i}function CL(r,e){const t=IL(e);return"vec4 "+r+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function kL(r,e){let t;switch(e){case IC:t="Linear";break;case CC:t="Reinhard";break;case kC:t="OptimizedCineon";break;case NC:t="ACESFilmic";break;case RC:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function NL(r){return[r.extensionDerivatives||r.envMapCubeUVHeight||r.bumpMap||r.tangentSpaceNormalMap||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Fu).join(`
`)}function RL(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function PL(r,e){const t={},n=r.getProgramParameter(e,35721);for(let i=0;i<n;i++){const s=r.getActiveAttrib(e,i),o=s.name;let a=1;s.type===35674&&(a=2),s.type===35675&&(a=3),s.type===35676&&(a=4),t[o]={type:s.type,location:r.getAttribLocation(e,o),locationSize:a}}return t}function Fu(r){return r!==""}function tb(r,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function nb(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const LL=/^[ \t]*#include +<([\w\d./]+)>/gm;function Qp(r){return r.replace(LL,DL)}function DL(r,e){const t=wt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Qp(t)}const OL=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function rb(r){return r.replace(OL,FL)}function FL(r,e,t,n){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function ib(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function $L(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===gw?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===oC?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===Ou&&(e="SHADOWMAP_TYPE_VSM"),e}function zL(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case Rl:case Pl:e="ENVMAP_TYPE_CUBE";break;case Cf:e="ENVMAP_TYPE_CUBE_UV";break}return e}function BL(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case Pl:e="ENVMAP_MODE_REFRACTION";break}return e}function UL(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case bw:e="ENVMAP_BLENDING_MULTIPLY";break;case MC:e="ENVMAP_BLENDING_MIX";break;case AC:e="ENVMAP_BLENDING_ADD";break}return e}function VL(r){const e=r.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:n,maxMip:t}}function WL(r,e,t,n){const i=r.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=$L(t),u=zL(t),c=BL(t),h=UL(t),f=VL(t),d=t.isWebGL2?"":NL(t),g=RL(s),p=i.createProgram();let m,_,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=[g].filter(Fu).join(`
`),m.length>0&&(m+=`
`),_=[d,g].filter(Fu).join(`
`),_.length>0&&(_+=`
`)):(m=[ib(t),"#define SHADER_NAME "+t.shaderName,g,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Fu).join(`
`),_=[d,ib(t),"#define SHADER_NAME "+t.shaderName,g,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==As?"#define TONE_MAPPING":"",t.toneMapping!==As?wt.tonemapping_pars_fragment:"",t.toneMapping!==As?kL("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",wt.encodings_pars_fragment,CL("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Fu).join(`
`)),o=Qp(o),o=tb(o,t),o=nb(o,t),a=Qp(a),a=tb(a,t),a=nb(a,t),o=rb(o),a=rb(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,_=["#define varying in",t.glslVersion===A_?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===A_?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const b=v+m+o,x=v+_+a,T=J_(i,35633,b),I=J_(i,35632,x);if(i.attachShader(p,T),i.attachShader(p,I),t.index0AttributeName!==void 0?i.bindAttribLocation(p,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(p,0,"position"),i.linkProgram(p),r.debug.checkShaderErrors){const A=i.getProgramInfoLog(p).trim(),R=i.getShaderInfoLog(T).trim(),F=i.getShaderInfoLog(I).trim();let q=!0,O=!0;if(i.getProgramParameter(p,35714)===!1){q=!1;const z=eb(i,T,"vertex"),H=eb(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(p,35715)+`

Program Info Log: `+A+`
`+z+`
`+H)}else A!==""?console.warn("THREE.WebGLProgram: Program Info Log:",A):(R===""||F==="")&&(O=!1);O&&(this.diagnostics={runnable:q,programLog:A,vertexShader:{log:R,prefix:m},fragmentShader:{log:F,prefix:_}})}i.deleteShader(T),i.deleteShader(I);let C;this.getUniforms=function(){return C===void 0&&(C=new Ch(i,p)),C};let S;return this.getAttributes=function(){return S===void 0&&(S=PL(i,p)),S},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(p),this.program=void 0},this.name=t.shaderName,this.id=ML++,this.cacheKey=e,this.usedTimes=1,this.program=p,this.vertexShader=T,this.fragmentShader=I,this}let GL=0;class HL{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(n),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new jL(e),t.set(e,n)),n}}class jL{constructor(e){this.id=GL++,this.code=e,this.usedTimes=0}}function qL(r,e,t,n,i,s,o){const a=new Rw,l=new HL,u=[],c=i.isWebGL2,h=i.logarithmicDepthBuffer,f=i.vertexTextures;let d=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function p(S,A,R,F,q){const O=F.fog,z=q.geometry,H=S.isMeshStandardMaterial?F.environment:null,Q=(S.isMeshStandardMaterial?t:e).get(S.envMap||H),Z=Q&&Q.mapping===Cf?Q.image.height:null,Y=g[S.type];S.precision!==null&&(d=i.getMaxPrecision(S.precision),d!==S.precision&&console.warn("THREE.WebGLProgram.getParameters:",S.precision,"not supported, using",d,"instead."));const fe=z.morphAttributes.position||z.morphAttributes.normal||z.morphAttributes.color,le=fe!==void 0?fe.length:0;let ve=0;z.morphAttributes.position!==void 0&&(ve=1),z.morphAttributes.normal!==void 0&&(ve=2),z.morphAttributes.color!==void 0&&(ve=3);let ee,_e,Te,ne;if(Y){const nt=qi[Y];ee=nt.vertexShader,_e=nt.fragmentShader}else ee=S.vertexShader,_e=S.fragmentShader,l.update(S),Te=l.getVertexShaderID(S),ne=l.getFragmentShaderID(S);const Le=r.getRenderTarget(),Ve=S.alphaTest>0,He=S.clearcoat>0,We=S.iridescence>0;return{isWebGL2:c,shaderID:Y,shaderName:S.type,vertexShader:ee,fragmentShader:_e,defines:S.defines,customVertexShaderID:Te,customFragmentShaderID:ne,isRawShaderMaterial:S.isRawShaderMaterial===!0,glslVersion:S.glslVersion,precision:d,instancing:q.isInstancedMesh===!0,instancingColor:q.isInstancedMesh===!0&&q.instanceColor!==null,supportsVertexTextures:f,outputEncoding:Le===null?r.outputEncoding:Le.isXRRenderTarget===!0?Le.texture.encoding:ba,map:!!S.map,matcap:!!S.matcap,envMap:!!Q,envMapMode:Q&&Q.mapping,envMapCubeUVHeight:Z,lightMap:!!S.lightMap,aoMap:!!S.aoMap,emissiveMap:!!S.emissiveMap,bumpMap:!!S.bumpMap,normalMap:!!S.normalMap,objectSpaceNormalMap:S.normalMapType===QC,tangentSpaceNormalMap:S.normalMapType===Tw,decodeVideoTexture:!!S.map&&S.map.isVideoTexture===!0&&S.map.encoding===$t,clearcoat:He,clearcoatMap:He&&!!S.clearcoatMap,clearcoatRoughnessMap:He&&!!S.clearcoatRoughnessMap,clearcoatNormalMap:He&&!!S.clearcoatNormalMap,iridescence:We,iridescenceMap:We&&!!S.iridescenceMap,iridescenceThicknessMap:We&&!!S.iridescenceThicknessMap,displacementMap:!!S.displacementMap,roughnessMap:!!S.roughnessMap,metalnessMap:!!S.metalnessMap,specularMap:!!S.specularMap,specularIntensityMap:!!S.specularIntensityMap,specularColorMap:!!S.specularColorMap,opaque:S.transparent===!1&&S.blending===xl,alphaMap:!!S.alphaMap,alphaTest:Ve,gradientMap:!!S.gradientMap,sheen:S.sheen>0,sheenColorMap:!!S.sheenColorMap,sheenRoughnessMap:!!S.sheenRoughnessMap,transmission:S.transmission>0,transmissionMap:!!S.transmissionMap,thicknessMap:!!S.thicknessMap,combine:S.combine,vertexTangents:!!S.normalMap&&!!z.attributes.tangent,vertexColors:S.vertexColors,vertexAlphas:S.vertexColors===!0&&!!z.attributes.color&&z.attributes.color.itemSize===4,vertexUvs:!!S.map||!!S.bumpMap||!!S.normalMap||!!S.specularMap||!!S.alphaMap||!!S.emissiveMap||!!S.roughnessMap||!!S.metalnessMap||!!S.clearcoatMap||!!S.clearcoatRoughnessMap||!!S.clearcoatNormalMap||!!S.iridescenceMap||!!S.iridescenceThicknessMap||!!S.displacementMap||!!S.transmissionMap||!!S.thicknessMap||!!S.specularIntensityMap||!!S.specularColorMap||!!S.sheenColorMap||!!S.sheenRoughnessMap,uvsVertexOnly:!(S.map||S.bumpMap||S.normalMap||S.specularMap||S.alphaMap||S.emissiveMap||S.roughnessMap||S.metalnessMap||S.clearcoatNormalMap||S.iridescenceMap||S.iridescenceThicknessMap||S.transmission>0||S.transmissionMap||S.thicknessMap||S.specularIntensityMap||S.specularColorMap||S.sheen>0||S.sheenColorMap||S.sheenRoughnessMap)&&!!S.displacementMap,fog:!!O,useFog:S.fog===!0,fogExp2:O&&O.isFogExp2,flatShading:!!S.flatShading,sizeAttenuation:S.sizeAttenuation,logarithmicDepthBuffer:h,skinning:q.isSkinnedMesh===!0,morphTargets:z.morphAttributes.position!==void 0,morphNormals:z.morphAttributes.normal!==void 0,morphColors:z.morphAttributes.color!==void 0,morphTargetsCount:le,morphTextureStride:ve,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numSpotLightMaps:A.spotLightMap.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numSpotLightShadowsWithMaps:A.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:S.dithering,shadowMapEnabled:r.shadowMap.enabled&&R.length>0,shadowMapType:r.shadowMap.type,toneMapping:S.toneMapped?r.toneMapping:As,useLegacyLights:r.useLegacyLights,premultipliedAlpha:S.premultipliedAlpha,doubleSided:S.side===ws,flipSided:S.side===Vr,useDepthPacking:!!S.depthPacking,depthPacking:S.depthPacking||0,index0AttributeName:S.index0AttributeName,extensionDerivatives:S.extensions&&S.extensions.derivatives,extensionFragDepth:S.extensions&&S.extensions.fragDepth,extensionDrawBuffers:S.extensions&&S.extensions.drawBuffers,extensionShaderTextureLOD:S.extensions&&S.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||n.has("EXT_shader_texture_lod"),customProgramCacheKey:S.customProgramCacheKey()}}function m(S){const A=[];if(S.shaderID?A.push(S.shaderID):(A.push(S.customVertexShaderID),A.push(S.customFragmentShaderID)),S.defines!==void 0)for(const R in S.defines)A.push(R),A.push(S.defines[R]);return S.isRawShaderMaterial===!1&&(_(A,S),v(A,S),A.push(r.outputEncoding)),A.push(S.customProgramCacheKey),A.join()}function _(S,A){S.push(A.precision),S.push(A.outputEncoding),S.push(A.envMapMode),S.push(A.envMapCubeUVHeight),S.push(A.combine),S.push(A.vertexUvs),S.push(A.fogExp2),S.push(A.sizeAttenuation),S.push(A.morphTargetsCount),S.push(A.morphAttributeCount),S.push(A.numDirLights),S.push(A.numPointLights),S.push(A.numSpotLights),S.push(A.numSpotLightMaps),S.push(A.numHemiLights),S.push(A.numRectAreaLights),S.push(A.numDirLightShadows),S.push(A.numPointLightShadows),S.push(A.numSpotLightShadows),S.push(A.numSpotLightShadowsWithMaps),S.push(A.shadowMapType),S.push(A.toneMapping),S.push(A.numClippingPlanes),S.push(A.numClipIntersection),S.push(A.depthPacking)}function v(S,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.map&&a.enable(4),A.matcap&&a.enable(5),A.envMap&&a.enable(6),A.lightMap&&a.enable(7),A.aoMap&&a.enable(8),A.emissiveMap&&a.enable(9),A.bumpMap&&a.enable(10),A.normalMap&&a.enable(11),A.objectSpaceNormalMap&&a.enable(12),A.tangentSpaceNormalMap&&a.enable(13),A.clearcoat&&a.enable(14),A.clearcoatMap&&a.enable(15),A.clearcoatRoughnessMap&&a.enable(16),A.clearcoatNormalMap&&a.enable(17),A.iridescence&&a.enable(18),A.iridescenceMap&&a.enable(19),A.iridescenceThicknessMap&&a.enable(20),A.displacementMap&&a.enable(21),A.specularMap&&a.enable(22),A.roughnessMap&&a.enable(23),A.metalnessMap&&a.enable(24),A.gradientMap&&a.enable(25),A.alphaMap&&a.enable(26),A.alphaTest&&a.enable(27),A.vertexColors&&a.enable(28),A.vertexAlphas&&a.enable(29),A.vertexUvs&&a.enable(30),A.vertexTangents&&a.enable(31),A.uvsVertexOnly&&a.enable(32),S.push(a.mask),a.disableAll(),A.fog&&a.enable(0),A.useFog&&a.enable(1),A.flatShading&&a.enable(2),A.logarithmicDepthBuffer&&a.enable(3),A.skinning&&a.enable(4),A.morphTargets&&a.enable(5),A.morphNormals&&a.enable(6),A.morphColors&&a.enable(7),A.premultipliedAlpha&&a.enable(8),A.shadowMapEnabled&&a.enable(9),A.useLegacyLights&&a.enable(10),A.doubleSided&&a.enable(11),A.flipSided&&a.enable(12),A.useDepthPacking&&a.enable(13),A.dithering&&a.enable(14),A.specularIntensityMap&&a.enable(15),A.specularColorMap&&a.enable(16),A.transmission&&a.enable(17),A.transmissionMap&&a.enable(18),A.thicknessMap&&a.enable(19),A.sheen&&a.enable(20),A.sheenColorMap&&a.enable(21),A.sheenRoughnessMap&&a.enable(22),A.decodeVideoTexture&&a.enable(23),A.opaque&&a.enable(24),S.push(a.mask)}function b(S){const A=g[S.type];let R;if(A){const F=qi[A];R=Pk.clone(F.uniforms)}else R=S.uniforms;return R}function x(S,A){let R;for(let F=0,q=u.length;F<q;F++){const O=u[F];if(O.cacheKey===A){R=O,++R.usedTimes;break}}return R===void 0&&(R=new WL(r,A,S,s),u.push(R)),R}function T(S){if(--S.usedTimes===0){const A=u.indexOf(S);u[A]=u[u.length-1],u.pop(),S.destroy()}}function I(S){l.remove(S)}function C(){l.dispose()}return{getParameters:p,getProgramCacheKey:m,getUniforms:b,acquireProgram:x,releaseProgram:T,releaseShaderCache:I,programs:u,dispose:C}}function KL(){let r=new WeakMap;function e(s){let o=r.get(s);return o===void 0&&(o={},r.set(s,o)),o}function t(s){r.delete(s)}function n(s,o,a){r.get(s)[o]=a}function i(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function XL(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function sb(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function ob(){const r=[];let e=0;const t=[],n=[],i=[];function s(){e=0,t.length=0,n.length=0,i.length=0}function o(h,f,d,g,p,m){let _=r[e];return _===void 0?(_={id:h.id,object:h,geometry:f,material:d,groupOrder:g,renderOrder:h.renderOrder,z:p,group:m},r[e]=_):(_.id=h.id,_.object=h,_.geometry=f,_.material=d,_.groupOrder=g,_.renderOrder=h.renderOrder,_.z=p,_.group=m),e++,_}function a(h,f,d,g,p,m){const _=o(h,f,d,g,p,m);d.transmission>0?n.push(_):d.transparent===!0?i.push(_):t.push(_)}function l(h,f,d,g,p,m){const _=o(h,f,d,g,p,m);d.transmission>0?n.unshift(_):d.transparent===!0?i.unshift(_):t.unshift(_)}function u(h,f){t.length>1&&t.sort(h||XL),n.length>1&&n.sort(f||sb),i.length>1&&i.sort(f||sb)}function c(){for(let h=e,f=r.length;h<f;h++){const d=r[h];if(d.id===null)break;d.id=null,d.object=null,d.geometry=null,d.material=null,d.group=null}}return{opaque:t,transmissive:n,transparent:i,init:s,push:a,unshift:l,finish:c,sort:u}}function YL(){let r=new WeakMap;function e(n,i){const s=r.get(n);let o;return s===void 0?(o=new ob,r.set(n,[o])):i>=s.length?(o=new ob,s.push(o)):o=s[i],o}function t(){r=new WeakMap}return{get:e,dispose:t}}function ZL(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new ie,color:new gt};break;case"SpotLight":t={position:new ie,direction:new ie,color:new gt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new ie,color:new gt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new ie,skyColor:new gt,groundColor:new gt};break;case"RectAreaLight":t={color:new gt,position:new ie,halfWidth:new ie,halfHeight:new ie};break}return r[e.id]=t,t}}}function QL(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let JL=0;function eD(r,e){return(e.castShadow?2:0)-(r.castShadow?2:0)+(e.map?1:0)-(r.map?1:0)}function tD(r,e){const t=new ZL,n=QL(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let c=0;c<9;c++)i.probe.push(new ie);const s=new ie,o=new Ct,a=new Ct;function l(c,h){let f=0,d=0,g=0;for(let F=0;F<9;F++)i.probe[F].set(0,0,0);let p=0,m=0,_=0,v=0,b=0,x=0,T=0,I=0,C=0,S=0;c.sort(eD);const A=h===!0?Math.PI:1;for(let F=0,q=c.length;F<q;F++){const O=c[F],z=O.color,H=O.intensity,Q=O.distance,Z=O.shadow&&O.shadow.map?O.shadow.map.texture:null;if(O.isAmbientLight)f+=z.r*H*A,d+=z.g*H*A,g+=z.b*H*A;else if(O.isLightProbe)for(let Y=0;Y<9;Y++)i.probe[Y].addScaledVector(O.sh.coefficients[Y],H);else if(O.isDirectionalLight){const Y=t.get(O);if(Y.color.copy(O.color).multiplyScalar(O.intensity*A),O.castShadow){const fe=O.shadow,le=n.get(O);le.shadowBias=fe.bias,le.shadowNormalBias=fe.normalBias,le.shadowRadius=fe.radius,le.shadowMapSize=fe.mapSize,i.directionalShadow[p]=le,i.directionalShadowMap[p]=Z,i.directionalShadowMatrix[p]=O.shadow.matrix,x++}i.directional[p]=Y,p++}else if(O.isSpotLight){const Y=t.get(O);Y.position.setFromMatrixPosition(O.matrixWorld),Y.color.copy(z).multiplyScalar(H*A),Y.distance=Q,Y.coneCos=Math.cos(O.angle),Y.penumbraCos=Math.cos(O.angle*(1-O.penumbra)),Y.decay=O.decay,i.spot[_]=Y;const fe=O.shadow;if(O.map&&(i.spotLightMap[C]=O.map,C++,fe.updateMatrices(O),O.castShadow&&S++),i.spotLightMatrix[_]=fe.matrix,O.castShadow){const le=n.get(O);le.shadowBias=fe.bias,le.shadowNormalBias=fe.normalBias,le.shadowRadius=fe.radius,le.shadowMapSize=fe.mapSize,i.spotShadow[_]=le,i.spotShadowMap[_]=Z,I++}_++}else if(O.isRectAreaLight){const Y=t.get(O);Y.color.copy(z).multiplyScalar(H),Y.halfWidth.set(O.width*.5,0,0),Y.halfHeight.set(0,O.height*.5,0),i.rectArea[v]=Y,v++}else if(O.isPointLight){const Y=t.get(O);if(Y.color.copy(O.color).multiplyScalar(O.intensity*A),Y.distance=O.distance,Y.decay=O.decay,O.castShadow){const fe=O.shadow,le=n.get(O);le.shadowBias=fe.bias,le.shadowNormalBias=fe.normalBias,le.shadowRadius=fe.radius,le.shadowMapSize=fe.mapSize,le.shadowCameraNear=fe.camera.near,le.shadowCameraFar=fe.camera.far,i.pointShadow[m]=le,i.pointShadowMap[m]=Z,i.pointShadowMatrix[m]=O.shadow.matrix,T++}i.point[m]=Y,m++}else if(O.isHemisphereLight){const Y=t.get(O);Y.skyColor.copy(O.color).multiplyScalar(H*A),Y.groundColor.copy(O.groundColor).multiplyScalar(H*A),i.hemi[b]=Y,b++}}v>0&&(e.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=$e.LTC_FLOAT_1,i.rectAreaLTC2=$e.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=$e.LTC_HALF_1,i.rectAreaLTC2=$e.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=f,i.ambient[1]=d,i.ambient[2]=g;const R=i.hash;(R.directionalLength!==p||R.pointLength!==m||R.spotLength!==_||R.rectAreaLength!==v||R.hemiLength!==b||R.numDirectionalShadows!==x||R.numPointShadows!==T||R.numSpotShadows!==I||R.numSpotMaps!==C)&&(i.directional.length=p,i.spot.length=_,i.rectArea.length=v,i.point.length=m,i.hemi.length=b,i.directionalShadow.length=x,i.directionalShadowMap.length=x,i.pointShadow.length=T,i.pointShadowMap.length=T,i.spotShadow.length=I,i.spotShadowMap.length=I,i.directionalShadowMatrix.length=x,i.pointShadowMatrix.length=T,i.spotLightMatrix.length=I+C-S,i.spotLightMap.length=C,i.numSpotLightShadowsWithMaps=S,R.directionalLength=p,R.pointLength=m,R.spotLength=_,R.rectAreaLength=v,R.hemiLength=b,R.numDirectionalShadows=x,R.numPointShadows=T,R.numSpotShadows=I,R.numSpotMaps=C,i.version=JL++)}function u(c,h){let f=0,d=0,g=0,p=0,m=0;const _=h.matrixWorldInverse;for(let v=0,b=c.length;v<b;v++){const x=c[v];if(x.isDirectionalLight){const T=i.directional[f];T.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),T.direction.sub(s),T.direction.transformDirection(_),f++}else if(x.isSpotLight){const T=i.spot[g];T.position.setFromMatrixPosition(x.matrixWorld),T.position.applyMatrix4(_),T.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),T.direction.sub(s),T.direction.transformDirection(_),g++}else if(x.isRectAreaLight){const T=i.rectArea[p];T.position.setFromMatrixPosition(x.matrixWorld),T.position.applyMatrix4(_),a.identity(),o.copy(x.matrixWorld),o.premultiply(_),a.extractRotation(o),T.halfWidth.set(x.width*.5,0,0),T.halfHeight.set(0,x.height*.5,0),T.halfWidth.applyMatrix4(a),T.halfHeight.applyMatrix4(a),p++}else if(x.isPointLight){const T=i.point[d];T.position.setFromMatrixPosition(x.matrixWorld),T.position.applyMatrix4(_),d++}else if(x.isHemisphereLight){const T=i.hemi[m];T.direction.setFromMatrixPosition(x.matrixWorld),T.direction.transformDirection(_),m++}}}return{setup:l,setupView:u,state:i}}function ab(r,e){const t=new tD(r,e),n=[],i=[];function s(){n.length=0,i.length=0}function o(h){n.push(h)}function a(h){i.push(h)}function l(h){t.setup(n,h)}function u(h){t.setupView(n,h)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:l,setupLightsView:u,pushLight:o,pushShadow:a}}function nD(r,e){let t=new WeakMap;function n(s,o=0){const a=t.get(s);let l;return a===void 0?(l=new ab(r,e),t.set(s,[l])):o>=a.length?(l=new ab(r,e),a.push(l)):l=a[o],l}function i(){t=new WeakMap}return{get:n,dispose:i}}class rD extends Qi{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=YC,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class iD extends Qi{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new ie,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const sD=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,oD=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function aD(r,e,t){let n=new Vg;const i=new mt,s=new mt,o=new Yt,a=new rD({depthPacking:ZC}),l=new iD,u={},c=t.maxTextureSize,h={[Rs]:Vr,[Vr]:Rs,[ws]:ws},f=new va({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new mt},radius:{value:4}},vertexShader:sD,fragmentShader:oD}),d=f.clone();d.defines.HORIZONTAL_PASS=1;const g=new Kr;g.setAttribute("position",new _r(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new Ur(g,f),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=gw,this.render=function(x,T,I){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||x.length===0)return;const C=r.getRenderTarget(),S=r.getActiveCubeFace(),A=r.getActiveMipmapLevel(),R=r.state;R.setBlending(mo),R.buffers.color.setClear(1,1,1,1),R.buffers.depth.setTest(!0),R.setScissorTest(!1);for(let F=0,q=x.length;F<q;F++){const O=x[F],z=O.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",O,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;i.copy(z.mapSize);const H=z.getFrameExtents();if(i.multiply(H),s.copy(z.mapSize),(i.x>c||i.y>c)&&(i.x>c&&(s.x=Math.floor(c/H.x),i.x=s.x*H.x,z.mapSize.x=s.x),i.y>c&&(s.y=Math.floor(c/H.y),i.y=s.y*H.y,z.mapSize.y=s.y)),z.map===null){const Z=this.type!==Ou?{minFilter:Fn,magFilter:Fn}:{};z.map=new xa(i.x,i.y,Z),z.map.texture.name=O.name+".shadowMap",z.camera.updateProjectionMatrix()}r.setRenderTarget(z.map),r.clear();const Q=z.getViewportCount();for(let Z=0;Z<Q;Z++){const Y=z.getViewport(Z);o.set(s.x*Y.x,s.y*Y.y,s.x*Y.z,s.y*Y.w),R.viewport(o),z.updateMatrices(O,Z),n=z.getFrustum(),b(T,I,z.camera,O,this.type)}z.isPointLightShadow!==!0&&this.type===Ou&&_(z,I),z.needsUpdate=!1}m.needsUpdate=!1,r.setRenderTarget(C,S,A)};function _(x,T){const I=e.update(p);f.defines.VSM_SAMPLES!==x.blurSamples&&(f.defines.VSM_SAMPLES=x.blurSamples,d.defines.VSM_SAMPLES=x.blurSamples,f.needsUpdate=!0,d.needsUpdate=!0),x.mapPass===null&&(x.mapPass=new xa(i.x,i.y)),f.uniforms.shadow_pass.value=x.map.texture,f.uniforms.resolution.value=x.mapSize,f.uniforms.radius.value=x.radius,r.setRenderTarget(x.mapPass),r.clear(),r.renderBufferDirect(T,null,I,f,p,null),d.uniforms.shadow_pass.value=x.mapPass.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,r.setRenderTarget(x.map),r.clear(),r.renderBufferDirect(T,null,I,d,p,null)}function v(x,T,I,C,S,A){let R=null;const F=I.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(F!==void 0)R=F;else if(R=I.isPointLight===!0?l:a,r.localClippingEnabled&&T.clipShadows===!0&&Array.isArray(T.clippingPlanes)&&T.clippingPlanes.length!==0||T.displacementMap&&T.displacementScale!==0||T.alphaMap&&T.alphaTest>0||T.map&&T.alphaTest>0){const q=R.uuid,O=T.uuid;let z=u[q];z===void 0&&(z={},u[q]=z);let H=z[O];H===void 0&&(H=R.clone(),z[O]=H),R=H}return R.visible=T.visible,R.wireframe=T.wireframe,A===Ou?R.side=T.shadowSide!==null?T.shadowSide:T.side:R.side=T.shadowSide!==null?T.shadowSide:h[T.side],R.alphaMap=T.alphaMap,R.alphaTest=T.alphaTest,R.map=T.map,R.clipShadows=T.clipShadows,R.clippingPlanes=T.clippingPlanes,R.clipIntersection=T.clipIntersection,R.displacementMap=T.displacementMap,R.displacementScale=T.displacementScale,R.displacementBias=T.displacementBias,R.wireframeLinewidth=T.wireframeLinewidth,R.linewidth=T.linewidth,I.isPointLight===!0&&R.isMeshDistanceMaterial===!0&&(R.referencePosition.setFromMatrixPosition(I.matrixWorld),R.nearDistance=C,R.farDistance=S),R}function b(x,T,I,C,S){if(x.visible===!1)return;if(x.layers.test(T.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&S===Ou)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,x.matrixWorld);const F=e.update(x),q=x.material;if(Array.isArray(q)){const O=F.groups;for(let z=0,H=O.length;z<H;z++){const Q=O[z],Z=q[Q.materialIndex];if(Z&&Z.visible){const Y=v(x,Z,C,I.near,I.far,S);r.renderBufferDirect(I,null,F,Y,x,Q)}}}else if(q.visible){const O=v(x,q,C,I.near,I.far,S);r.renderBufferDirect(I,null,F,O,x,null)}}const R=x.children;for(let F=0,q=R.length;F<q;F++)b(R[F],T,I,C,S)}}function lD(r,e,t){const n=t.isWebGL2;function i(){let te=!1;const me=new Yt;let Ne=null;const qe=new Yt(0,0,0,0);return{setMask:function(Ke){Ne!==Ke&&!te&&(r.colorMask(Ke,Ke,Ke,Ke),Ne=Ke)},setLocked:function(Ke){te=Ke},setClear:function(Ke,Gt,Qt,An,Lr){Lr===!0&&(Ke*=An,Gt*=An,Qt*=An),me.set(Ke,Gt,Qt,An),qe.equals(me)===!1&&(r.clearColor(Ke,Gt,Qt,An),qe.copy(me))},reset:function(){te=!1,Ne=null,qe.set(-1,0,0,0)}}}function s(){let te=!1,me=null,Ne=null,qe=null;return{setTest:function(Ke){Ke?Ve(2929):He(2929)},setMask:function(Ke){me!==Ke&&!te&&(r.depthMask(Ke),me=Ke)},setFunc:function(Ke){if(Ne!==Ke){switch(Ke){case bC:r.depthFunc(512);break;case xC:r.depthFunc(519);break;case vC:r.depthFunc(513);break;case Gp:r.depthFunc(515);break;case wC:r.depthFunc(514);break;case SC:r.depthFunc(518);break;case TC:r.depthFunc(516);break;case EC:r.depthFunc(517);break;default:r.depthFunc(515)}Ne=Ke}},setLocked:function(Ke){te=Ke},setClear:function(Ke){qe!==Ke&&(r.clearDepth(Ke),qe=Ke)},reset:function(){te=!1,me=null,Ne=null,qe=null}}}function o(){let te=!1,me=null,Ne=null,qe=null,Ke=null,Gt=null,Qt=null,An=null,Lr=null;return{setTest:function(Jt){te||(Jt?Ve(2960):He(2960))},setMask:function(Jt){me!==Jt&&!te&&(r.stencilMask(Jt),me=Jt)},setFunc:function(Jt,Bn,Jr){(Ne!==Jt||qe!==Bn||Ke!==Jr)&&(r.stencilFunc(Jt,Bn,Jr),Ne=Jt,qe=Bn,Ke=Jr)},setOp:function(Jt,Bn,Jr){(Gt!==Jt||Qt!==Bn||An!==Jr)&&(r.stencilOp(Jt,Bn,Jr),Gt=Jt,Qt=Bn,An=Jr)},setLocked:function(Jt){te=Jt},setClear:function(Jt){Lr!==Jt&&(r.clearStencil(Jt),Lr=Jt)},reset:function(){te=!1,me=null,Ne=null,qe=null,Ke=null,Gt=null,Qt=null,An=null,Lr=null}}}const a=new i,l=new s,u=new o,c=new WeakMap,h=new WeakMap;let f={},d={},g=new WeakMap,p=[],m=null,_=!1,v=null,b=null,x=null,T=null,I=null,C=null,S=null,A=!1,R=null,F=null,q=null,O=null,z=null;const H=r.getParameter(35661);let Q=!1,Z=0;const Y=r.getParameter(7938);Y.indexOf("WebGL")!==-1?(Z=parseFloat(/^WebGL (\d)/.exec(Y)[1]),Q=Z>=1):Y.indexOf("OpenGL ES")!==-1&&(Z=parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]),Q=Z>=2);let fe=null,le={};const ve=r.getParameter(3088),ee=r.getParameter(2978),_e=new Yt().fromArray(ve),Te=new Yt().fromArray(ee);function ne(te,me,Ne){const qe=new Uint8Array(4),Ke=r.createTexture();r.bindTexture(te,Ke),r.texParameteri(te,10241,9728),r.texParameteri(te,10240,9728);for(let Gt=0;Gt<Ne;Gt++)r.texImage2D(me+Gt,0,6408,1,1,0,6408,5121,qe);return Ke}const Le={};Le[3553]=ne(3553,3553,1),Le[34067]=ne(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),u.setClear(0),Ve(2929),l.setFunc(Gp),de(!1),Ee(X0),Ve(2884),ae(mo);function Ve(te){f[te]!==!0&&(r.enable(te),f[te]=!0)}function He(te){f[te]!==!1&&(r.disable(te),f[te]=!1)}function We(te,me){return d[te]!==me?(r.bindFramebuffer(te,me),d[te]=me,n&&(te===36009&&(d[36160]=me),te===36160&&(d[36009]=me)),!0):!1}function Je(te,me){let Ne=p,qe=!1;if(te)if(Ne=g.get(me),Ne===void 0&&(Ne=[],g.set(me,Ne)),te.isWebGLMultipleRenderTargets){const Ke=te.texture;if(Ne.length!==Ke.length||Ne[0]!==36064){for(let Gt=0,Qt=Ke.length;Gt<Qt;Gt++)Ne[Gt]=36064+Gt;Ne.length=Ke.length,qe=!0}}else Ne[0]!==36064&&(Ne[0]=36064,qe=!0);else Ne[0]!==1029&&(Ne[0]=1029,qe=!0);qe&&(t.isWebGL2?r.drawBuffers(Ne):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ne))}function nt(te){return m!==te?(r.useProgram(te),m=te,!0):!1}const U={[ll]:32774,[lC]:32778,[uC]:32779};if(n)U[J0]=32775,U[e_]=32776;else{const te=e.get("EXT_blend_minmax");te!==null&&(U[J0]=te.MIN_EXT,U[e_]=te.MAX_EXT)}const j={[cC]:0,[hC]:1,[fC]:768,[yw]:770,[_C]:776,[gC]:774,[pC]:772,[dC]:769,[_w]:771,[yC]:775,[mC]:773};function ae(te,me,Ne,qe,Ke,Gt,Qt,An){if(te===mo){_===!0&&(He(3042),_=!1);return}if(_===!1&&(Ve(3042),_=!0),te!==aC){if(te!==v||An!==A){if((b!==ll||I!==ll)&&(r.blendEquation(32774),b=ll,I=ll),An)switch(te){case xl:r.blendFuncSeparate(1,771,1,771);break;case Y0:r.blendFunc(1,1);break;case Z0:r.blendFuncSeparate(0,769,0,1);break;case Q0:r.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",te);break}else switch(te){case xl:r.blendFuncSeparate(770,771,1,771);break;case Y0:r.blendFunc(770,1);break;case Z0:r.blendFuncSeparate(0,769,0,1);break;case Q0:r.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",te);break}x=null,T=null,C=null,S=null,v=te,A=An}return}Ke=Ke||me,Gt=Gt||Ne,Qt=Qt||qe,(me!==b||Ke!==I)&&(r.blendEquationSeparate(U[me],U[Ke]),b=me,I=Ke),(Ne!==x||qe!==T||Gt!==C||Qt!==S)&&(r.blendFuncSeparate(j[Ne],j[qe],j[Gt],j[Qt]),x=Ne,T=qe,C=Gt,S=Qt),v=te,A=!1}function be(te,me){te.side===ws?He(2884):Ve(2884);let Ne=te.side===Vr;me&&(Ne=!Ne),de(Ne),te.blending===xl&&te.transparent===!1?ae(mo):ae(te.blending,te.blendEquation,te.blendSrc,te.blendDst,te.blendEquationAlpha,te.blendSrcAlpha,te.blendDstAlpha,te.premultipliedAlpha),l.setFunc(te.depthFunc),l.setTest(te.depthTest),l.setMask(te.depthWrite),a.setMask(te.colorWrite);const qe=te.stencilWrite;u.setTest(qe),qe&&(u.setMask(te.stencilWriteMask),u.setFunc(te.stencilFunc,te.stencilRef,te.stencilFuncMask),u.setOp(te.stencilFail,te.stencilZFail,te.stencilZPass)),we(te.polygonOffset,te.polygonOffsetFactor,te.polygonOffsetUnits),te.alphaToCoverage===!0?Ve(32926):He(32926)}function de(te){R!==te&&(te?r.frontFace(2304):r.frontFace(2305),R=te)}function Ee(te){te!==iC?(Ve(2884),te!==F&&(te===X0?r.cullFace(1029):te===sC?r.cullFace(1028):r.cullFace(1032))):He(2884),F=te}function Ae(te){te!==q&&(Q&&r.lineWidth(te),q=te)}function we(te,me,Ne){te?(Ve(32823),(O!==me||z!==Ne)&&(r.polygonOffset(me,Ne),O=me,z=Ne)):He(32823)}function ke(te){te?Ve(3089):He(3089)}function Se(te){te===void 0&&(te=33984+H-1),fe!==te&&(r.activeTexture(te),fe=te)}function L(te,me,Ne){Ne===void 0&&(fe===null?Ne=33984+H-1:Ne=fe);let qe=le[Ne];qe===void 0&&(qe={type:void 0,texture:void 0},le[Ne]=qe),(qe.type!==te||qe.texture!==me)&&(fe!==Ne&&(r.activeTexture(Ne),fe=Ne),r.bindTexture(te,me||Le[te]),qe.type=te,qe.texture=me)}function N(){const te=le[fe];te!==void 0&&te.type!==void 0&&(r.bindTexture(te.type,null),te.type=void 0,te.texture=void 0)}function re(){try{r.compressedTexImage2D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function pe(){try{r.compressedTexImage3D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function ge(){try{r.texSubImage2D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Me(){try{r.texSubImage3D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Pe(){try{r.compressedTexSubImage2D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function G(){try{r.compressedTexSubImage3D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function se(){try{r.texStorage2D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Be(){try{r.texStorage3D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function De(){try{r.texImage2D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function je(){try{r.texImage3D.apply(r,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Xe(te){_e.equals(te)===!1&&(r.scissor(te.x,te.y,te.z,te.w),_e.copy(te))}function Ue(te){Te.equals(te)===!1&&(r.viewport(te.x,te.y,te.z,te.w),Te.copy(te))}function ot(te,me){let Ne=h.get(me);Ne===void 0&&(Ne=new WeakMap,h.set(me,Ne));let qe=Ne.get(te);qe===void 0&&(qe=r.getUniformBlockIndex(me,te.name),Ne.set(te,qe))}function xt(te,me){const qe=h.get(me).get(te);c.get(me)!==qe&&(r.uniformBlockBinding(me,qe,te.__bindingPointIndex),c.set(me,qe))}function Ot(){r.disable(3042),r.disable(2884),r.disable(2929),r.disable(32823),r.disable(3089),r.disable(2960),r.disable(32926),r.blendEquation(32774),r.blendFunc(1,0),r.blendFuncSeparate(1,0,1,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(513),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(519,0,4294967295),r.stencilOp(7680,7680,7680),r.clearStencil(0),r.cullFace(1029),r.frontFace(2305),r.polygonOffset(0,0),r.activeTexture(33984),r.bindFramebuffer(36160,null),n===!0&&(r.bindFramebuffer(36009,null),r.bindFramebuffer(36008,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),f={},fe=null,le={},d={},g=new WeakMap,p=[],m=null,_=!1,v=null,b=null,x=null,T=null,I=null,C=null,S=null,A=!1,R=null,F=null,q=null,O=null,z=null,_e.set(0,0,r.canvas.width,r.canvas.height),Te.set(0,0,r.canvas.width,r.canvas.height),a.reset(),l.reset(),u.reset()}return{buffers:{color:a,depth:l,stencil:u},enable:Ve,disable:He,bindFramebuffer:We,drawBuffers:Je,useProgram:nt,setBlending:ae,setMaterial:be,setFlipSided:de,setCullFace:Ee,setLineWidth:Ae,setPolygonOffset:we,setScissorTest:ke,activeTexture:Se,bindTexture:L,unbindTexture:N,compressedTexImage2D:re,compressedTexImage3D:pe,texImage2D:De,texImage3D:je,updateUBOMapping:ot,uniformBlockBinding:xt,texStorage2D:se,texStorage3D:Be,texSubImage2D:ge,texSubImage3D:Me,compressedTexSubImage2D:Pe,compressedTexSubImage3D:G,scissor:Xe,viewport:Ue,reset:Ot}}function uD(r,e,t,n,i,s,o){const a=i.isWebGL2,l=i.maxTextures,u=i.maxCubemapSize,c=i.maxTextureSize,h=i.maxSamples,f=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,d=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),g=new WeakMap;let p;const m=new WeakMap;let _=!1;try{_=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(L,N){return _?new OffscreenCanvas(L,N):hc("canvas")}function b(L,N,re,pe){let ge=1;if((L.width>pe||L.height>pe)&&(ge=pe/Math.max(L.width,L.height)),ge<1||N===!0)if(typeof HTMLImageElement<"u"&&L instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&L instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&L instanceof ImageBitmap){const Me=N?Aw:Math.floor,Pe=Me(ge*L.width),G=Me(ge*L.height);p===void 0&&(p=v(Pe,G));const se=re?v(Pe,G):p;return se.width=Pe,se.height=G,se.getContext("2d").drawImage(L,0,0,Pe,G),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+L.width+"x"+L.height+") to ("+Pe+"x"+G+")."),se}else return"data"in L&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+L.width+"x"+L.height+")."),L;return L}function x(L){return Zp(L.width)&&Zp(L.height)}function T(L){return a?!1:L.wrapS!==hi||L.wrapT!==hi||L.minFilter!==Fn&&L.minFilter!==Er}function I(L,N){return L.generateMipmaps&&N&&L.minFilter!==Fn&&L.minFilter!==Er}function C(L){r.generateMipmap(L)}function S(L,N,re,pe,ge=!1){if(a===!1)return N;if(L!==null){if(r[L]!==void 0)return r[L];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+L+"'")}let Me=N;return N===6403&&(re===5126&&(Me=33326),re===5131&&(Me=33325),re===5121&&(Me=33321)),N===33319&&(re===5126&&(Me=33328),re===5131&&(Me=33327),re===5121&&(Me=33323)),N===6408&&(re===5126&&(Me=34836),re===5131&&(Me=34842),re===5121&&(Me=pe===$t&&ge===!1?35907:32856),re===32819&&(Me=32854),re===32820&&(Me=32855)),(Me===33325||Me===33326||Me===33327||Me===33328||Me===34842||Me===34836)&&e.get("EXT_color_buffer_float"),Me}function A(L,N,re){return I(L,re)===!0||L.isFramebufferTexture&&L.minFilter!==Fn&&L.minFilter!==Er?Math.log2(Math.max(N.width,N.height))+1:L.mipmaps!==void 0&&L.mipmaps.length>0?L.mipmaps.length:L.isCompressedTexture&&Array.isArray(L.image)?N.mipmaps.length:1}function R(L){return L===Fn||L===qp||L===Ih?9728:9729}function F(L){const N=L.target;N.removeEventListener("dispose",F),O(N),N.isVideoTexture&&g.delete(N)}function q(L){const N=L.target;N.removeEventListener("dispose",q),H(N)}function O(L){const N=n.get(L);if(N.__webglInit===void 0)return;const re=L.source,pe=m.get(re);if(pe){const ge=pe[N.__cacheKey];ge.usedTimes--,ge.usedTimes===0&&z(L),Object.keys(pe).length===0&&m.delete(re)}n.remove(L)}function z(L){const N=n.get(L);r.deleteTexture(N.__webglTexture);const re=L.source,pe=m.get(re);delete pe[N.__cacheKey],o.memory.textures--}function H(L){const N=L.texture,re=n.get(L),pe=n.get(N);if(pe.__webglTexture!==void 0&&(r.deleteTexture(pe.__webglTexture),o.memory.textures--),L.depthTexture&&L.depthTexture.dispose(),L.isWebGLCubeRenderTarget)for(let ge=0;ge<6;ge++)r.deleteFramebuffer(re.__webglFramebuffer[ge]),re.__webglDepthbuffer&&r.deleteRenderbuffer(re.__webglDepthbuffer[ge]);else{if(r.deleteFramebuffer(re.__webglFramebuffer),re.__webglDepthbuffer&&r.deleteRenderbuffer(re.__webglDepthbuffer),re.__webglMultisampledFramebuffer&&r.deleteFramebuffer(re.__webglMultisampledFramebuffer),re.__webglColorRenderbuffer)for(let ge=0;ge<re.__webglColorRenderbuffer.length;ge++)re.__webglColorRenderbuffer[ge]&&r.deleteRenderbuffer(re.__webglColorRenderbuffer[ge]);re.__webglDepthRenderbuffer&&r.deleteRenderbuffer(re.__webglDepthRenderbuffer)}if(L.isWebGLMultipleRenderTargets)for(let ge=0,Me=N.length;ge<Me;ge++){const Pe=n.get(N[ge]);Pe.__webglTexture&&(r.deleteTexture(Pe.__webglTexture),o.memory.textures--),n.remove(N[ge])}n.remove(N),n.remove(L)}let Q=0;function Z(){Q=0}function Y(){const L=Q;return L>=l&&console.warn("THREE.WebGLTextures: Trying to use "+L+" texture units while this GPU supports only "+l),Q+=1,L}function fe(L){const N=[];return N.push(L.wrapS),N.push(L.wrapT),N.push(L.wrapR||0),N.push(L.magFilter),N.push(L.minFilter),N.push(L.anisotropy),N.push(L.internalFormat),N.push(L.format),N.push(L.type),N.push(L.generateMipmaps),N.push(L.premultiplyAlpha),N.push(L.flipY),N.push(L.unpackAlignment),N.push(L.encoding),N.join()}function le(L,N){const re=n.get(L);if(L.isVideoTexture&&ke(L),L.isRenderTargetTexture===!1&&L.version>0&&re.__version!==L.version){const pe=L.image;if(pe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(pe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{He(re,L,N);return}}t.bindTexture(3553,re.__webglTexture,33984+N)}function ve(L,N){const re=n.get(L);if(L.version>0&&re.__version!==L.version){He(re,L,N);return}t.bindTexture(35866,re.__webglTexture,33984+N)}function ee(L,N){const re=n.get(L);if(L.version>0&&re.__version!==L.version){He(re,L,N);return}t.bindTexture(32879,re.__webglTexture,33984+N)}function _e(L,N){const re=n.get(L);if(L.version>0&&re.__version!==L.version){We(re,L,N);return}t.bindTexture(34067,re.__webglTexture,33984+N)}const Te={[Ll]:10497,[hi]:33071,[Wh]:33648},ne={[Fn]:9728,[qp]:9984,[Ih]:9986,[Er]:9729,[vw]:9985,[ya]:9987};function Le(L,N,re){if(re?(r.texParameteri(L,10242,Te[N.wrapS]),r.texParameteri(L,10243,Te[N.wrapT]),(L===32879||L===35866)&&r.texParameteri(L,32882,Te[N.wrapR]),r.texParameteri(L,10240,ne[N.magFilter]),r.texParameteri(L,10241,ne[N.minFilter])):(r.texParameteri(L,10242,33071),r.texParameteri(L,10243,33071),(L===32879||L===35866)&&r.texParameteri(L,32882,33071),(N.wrapS!==hi||N.wrapT!==hi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(L,10240,R(N.magFilter)),r.texParameteri(L,10241,R(N.minFilter)),N.minFilter!==Fn&&N.minFilter!==Er&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const pe=e.get("EXT_texture_filter_anisotropic");if(N.magFilter===Fn||N.minFilter!==Ih&&N.minFilter!==ya||N.type===io&&e.has("OES_texture_float_linear")===!1||a===!1&&N.type===ac&&e.has("OES_texture_half_float_linear")===!1)return;(N.anisotropy>1||n.get(N).__currentAnisotropy)&&(r.texParameterf(L,pe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(N.anisotropy,i.getMaxAnisotropy())),n.get(N).__currentAnisotropy=N.anisotropy)}}function Ve(L,N){let re=!1;L.__webglInit===void 0&&(L.__webglInit=!0,N.addEventListener("dispose",F));const pe=N.source;let ge=m.get(pe);ge===void 0&&(ge={},m.set(pe,ge));const Me=fe(N);if(Me!==L.__cacheKey){ge[Me]===void 0&&(ge[Me]={texture:r.createTexture(),usedTimes:0},o.memory.textures++,re=!0),ge[Me].usedTimes++;const Pe=ge[L.__cacheKey];Pe!==void 0&&(ge[L.__cacheKey].usedTimes--,Pe.usedTimes===0&&z(N)),L.__cacheKey=Me,L.__webglTexture=ge[Me].texture}return re}function He(L,N,re){let pe=3553;(N.isDataArrayTexture||N.isCompressedArrayTexture)&&(pe=35866),N.isData3DTexture&&(pe=32879);const ge=Ve(L,N),Me=N.source;t.bindTexture(pe,L.__webglTexture,33984+re);const Pe=n.get(Me);if(Me.version!==Pe.__version||ge===!0){t.activeTexture(33984+re),r.pixelStorei(37440,N.flipY),r.pixelStorei(37441,N.premultiplyAlpha),r.pixelStorei(3317,N.unpackAlignment),r.pixelStorei(37443,0);const G=T(N)&&x(N.image)===!1;let se=b(N.image,G,!1,c);se=Se(N,se);const Be=x(se)||a,De=s.convert(N.format,N.encoding);let je=s.convert(N.type),Xe=S(N.internalFormat,De,je,N.encoding,N.isVideoTexture);Le(pe,N,Be);let Ue;const ot=N.mipmaps,xt=a&&N.isVideoTexture!==!0,Ot=Pe.__version===void 0||ge===!0,te=A(N,se,Be);if(N.isDepthTexture)Xe=6402,a?N.type===io?Xe=36012:N.type===ea?Xe=33190:N.type===vl?Xe=35056:Xe=33189:N.type===io&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),N.format===ca&&Xe===6402&&N.type!==ww&&N.type!==ea&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),N.type=ea,je=s.convert(N.type)),N.format===Dl&&Xe===6402&&(Xe=34041,N.type!==vl&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),N.type=vl,je=s.convert(N.type))),Ot&&(xt?t.texStorage2D(3553,1,Xe,se.width,se.height):t.texImage2D(3553,0,Xe,se.width,se.height,0,De,je,null));else if(N.isDataTexture)if(ot.length>0&&Be){xt&&Ot&&t.texStorage2D(3553,te,Xe,ot[0].width,ot[0].height);for(let me=0,Ne=ot.length;me<Ne;me++)Ue=ot[me],xt?t.texSubImage2D(3553,me,0,0,Ue.width,Ue.height,De,je,Ue.data):t.texImage2D(3553,me,Xe,Ue.width,Ue.height,0,De,je,Ue.data);N.generateMipmaps=!1}else xt?(Ot&&t.texStorage2D(3553,te,Xe,se.width,se.height),t.texSubImage2D(3553,0,0,0,se.width,se.height,De,je,se.data)):t.texImage2D(3553,0,Xe,se.width,se.height,0,De,je,se.data);else if(N.isCompressedTexture)if(N.isCompressedArrayTexture){xt&&Ot&&t.texStorage3D(35866,te,Xe,ot[0].width,ot[0].height,se.depth);for(let me=0,Ne=ot.length;me<Ne;me++)Ue=ot[me],N.format!==fi?De!==null?xt?t.compressedTexSubImage3D(35866,me,0,0,0,Ue.width,Ue.height,se.depth,De,Ue.data,0,0):t.compressedTexImage3D(35866,me,Xe,Ue.width,Ue.height,se.depth,0,Ue.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):xt?t.texSubImage3D(35866,me,0,0,0,Ue.width,Ue.height,se.depth,De,je,Ue.data):t.texImage3D(35866,me,Xe,Ue.width,Ue.height,se.depth,0,De,je,Ue.data)}else{xt&&Ot&&t.texStorage2D(3553,te,Xe,ot[0].width,ot[0].height);for(let me=0,Ne=ot.length;me<Ne;me++)Ue=ot[me],N.format!==fi?De!==null?xt?t.compressedTexSubImage2D(3553,me,0,0,Ue.width,Ue.height,De,Ue.data):t.compressedTexImage2D(3553,me,Xe,Ue.width,Ue.height,0,Ue.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):xt?t.texSubImage2D(3553,me,0,0,Ue.width,Ue.height,De,je,Ue.data):t.texImage2D(3553,me,Xe,Ue.width,Ue.height,0,De,je,Ue.data)}else if(N.isDataArrayTexture)xt?(Ot&&t.texStorage3D(35866,te,Xe,se.width,se.height,se.depth),t.texSubImage3D(35866,0,0,0,0,se.width,se.height,se.depth,De,je,se.data)):t.texImage3D(35866,0,Xe,se.width,se.height,se.depth,0,De,je,se.data);else if(N.isData3DTexture)xt?(Ot&&t.texStorage3D(32879,te,Xe,se.width,se.height,se.depth),t.texSubImage3D(32879,0,0,0,0,se.width,se.height,se.depth,De,je,se.data)):t.texImage3D(32879,0,Xe,se.width,se.height,se.depth,0,De,je,se.data);else if(N.isFramebufferTexture){if(Ot)if(xt)t.texStorage2D(3553,te,Xe,se.width,se.height);else{let me=se.width,Ne=se.height;for(let qe=0;qe<te;qe++)t.texImage2D(3553,qe,Xe,me,Ne,0,De,je,null),me>>=1,Ne>>=1}}else if(ot.length>0&&Be){xt&&Ot&&t.texStorage2D(3553,te,Xe,ot[0].width,ot[0].height);for(let me=0,Ne=ot.length;me<Ne;me++)Ue=ot[me],xt?t.texSubImage2D(3553,me,0,0,De,je,Ue):t.texImage2D(3553,me,Xe,De,je,Ue);N.generateMipmaps=!1}else xt?(Ot&&t.texStorage2D(3553,te,Xe,se.width,se.height),t.texSubImage2D(3553,0,0,0,De,je,se)):t.texImage2D(3553,0,Xe,De,je,se);I(N,Be)&&C(pe),Pe.__version=Me.version,N.onUpdate&&N.onUpdate(N)}L.__version=N.version}function We(L,N,re){if(N.image.length!==6)return;const pe=Ve(L,N),ge=N.source;t.bindTexture(34067,L.__webglTexture,33984+re);const Me=n.get(ge);if(ge.version!==Me.__version||pe===!0){t.activeTexture(33984+re),r.pixelStorei(37440,N.flipY),r.pixelStorei(37441,N.premultiplyAlpha),r.pixelStorei(3317,N.unpackAlignment),r.pixelStorei(37443,0);const Pe=N.isCompressedTexture||N.image[0].isCompressedTexture,G=N.image[0]&&N.image[0].isDataTexture,se=[];for(let me=0;me<6;me++)!Pe&&!G?se[me]=b(N.image[me],!1,!0,u):se[me]=G?N.image[me].image:N.image[me],se[me]=Se(N,se[me]);const Be=se[0],De=x(Be)||a,je=s.convert(N.format,N.encoding),Xe=s.convert(N.type),Ue=S(N.internalFormat,je,Xe,N.encoding),ot=a&&N.isVideoTexture!==!0,xt=Me.__version===void 0||pe===!0;let Ot=A(N,Be,De);Le(34067,N,De);let te;if(Pe){ot&&xt&&t.texStorage2D(34067,Ot,Ue,Be.width,Be.height);for(let me=0;me<6;me++){te=se[me].mipmaps;for(let Ne=0;Ne<te.length;Ne++){const qe=te[Ne];N.format!==fi?je!==null?ot?t.compressedTexSubImage2D(34069+me,Ne,0,0,qe.width,qe.height,je,qe.data):t.compressedTexImage2D(34069+me,Ne,Ue,qe.width,qe.height,0,qe.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):ot?t.texSubImage2D(34069+me,Ne,0,0,qe.width,qe.height,je,Xe,qe.data):t.texImage2D(34069+me,Ne,Ue,qe.width,qe.height,0,je,Xe,qe.data)}}}else{te=N.mipmaps,ot&&xt&&(te.length>0&&Ot++,t.texStorage2D(34067,Ot,Ue,se[0].width,se[0].height));for(let me=0;me<6;me++)if(G){ot?t.texSubImage2D(34069+me,0,0,0,se[me].width,se[me].height,je,Xe,se[me].data):t.texImage2D(34069+me,0,Ue,se[me].width,se[me].height,0,je,Xe,se[me].data);for(let Ne=0;Ne<te.length;Ne++){const Ke=te[Ne].image[me].image;ot?t.texSubImage2D(34069+me,Ne+1,0,0,Ke.width,Ke.height,je,Xe,Ke.data):t.texImage2D(34069+me,Ne+1,Ue,Ke.width,Ke.height,0,je,Xe,Ke.data)}}else{ot?t.texSubImage2D(34069+me,0,0,0,je,Xe,se[me]):t.texImage2D(34069+me,0,Ue,je,Xe,se[me]);for(let Ne=0;Ne<te.length;Ne++){const qe=te[Ne];ot?t.texSubImage2D(34069+me,Ne+1,0,0,je,Xe,qe.image[me]):t.texImage2D(34069+me,Ne+1,Ue,je,Xe,qe.image[me])}}}I(N,De)&&C(34067),Me.__version=ge.version,N.onUpdate&&N.onUpdate(N)}L.__version=N.version}function Je(L,N,re,pe,ge){const Me=s.convert(re.format,re.encoding),Pe=s.convert(re.type),G=S(re.internalFormat,Me,Pe,re.encoding);n.get(N).__hasExternalTextures||(ge===32879||ge===35866?t.texImage3D(ge,0,G,N.width,N.height,N.depth,0,Me,Pe,null):t.texImage2D(ge,0,G,N.width,N.height,0,Me,Pe,null)),t.bindFramebuffer(36160,L),we(N)?f.framebufferTexture2DMultisampleEXT(36160,pe,ge,n.get(re).__webglTexture,0,Ae(N)):(ge===3553||ge>=34069&&ge<=34074)&&r.framebufferTexture2D(36160,pe,ge,n.get(re).__webglTexture,0),t.bindFramebuffer(36160,null)}function nt(L,N,re){if(r.bindRenderbuffer(36161,L),N.depthBuffer&&!N.stencilBuffer){let pe=33189;if(re||we(N)){const ge=N.depthTexture;ge&&ge.isDepthTexture&&(ge.type===io?pe=36012:ge.type===ea&&(pe=33190));const Me=Ae(N);we(N)?f.renderbufferStorageMultisampleEXT(36161,Me,pe,N.width,N.height):r.renderbufferStorageMultisample(36161,Me,pe,N.width,N.height)}else r.renderbufferStorage(36161,pe,N.width,N.height);r.framebufferRenderbuffer(36160,36096,36161,L)}else if(N.depthBuffer&&N.stencilBuffer){const pe=Ae(N);re&&we(N)===!1?r.renderbufferStorageMultisample(36161,pe,35056,N.width,N.height):we(N)?f.renderbufferStorageMultisampleEXT(36161,pe,35056,N.width,N.height):r.renderbufferStorage(36161,34041,N.width,N.height),r.framebufferRenderbuffer(36160,33306,36161,L)}else{const pe=N.isWebGLMultipleRenderTargets===!0?N.texture:[N.texture];for(let ge=0;ge<pe.length;ge++){const Me=pe[ge],Pe=s.convert(Me.format,Me.encoding),G=s.convert(Me.type),se=S(Me.internalFormat,Pe,G,Me.encoding),Be=Ae(N);re&&we(N)===!1?r.renderbufferStorageMultisample(36161,Be,se,N.width,N.height):we(N)?f.renderbufferStorageMultisampleEXT(36161,Be,se,N.width,N.height):r.renderbufferStorage(36161,se,N.width,N.height)}}r.bindRenderbuffer(36161,null)}function U(L,N){if(N&&N.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,L),!(N.depthTexture&&N.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(N.depthTexture).__webglTexture||N.depthTexture.image.width!==N.width||N.depthTexture.image.height!==N.height)&&(N.depthTexture.image.width=N.width,N.depthTexture.image.height=N.height,N.depthTexture.needsUpdate=!0),le(N.depthTexture,0);const pe=n.get(N.depthTexture).__webglTexture,ge=Ae(N);if(N.depthTexture.format===ca)we(N)?f.framebufferTexture2DMultisampleEXT(36160,36096,3553,pe,0,ge):r.framebufferTexture2D(36160,36096,3553,pe,0);else if(N.depthTexture.format===Dl)we(N)?f.framebufferTexture2DMultisampleEXT(36160,33306,3553,pe,0,ge):r.framebufferTexture2D(36160,33306,3553,pe,0);else throw new Error("Unknown depthTexture format")}function j(L){const N=n.get(L),re=L.isWebGLCubeRenderTarget===!0;if(L.depthTexture&&!N.__autoAllocateDepthBuffer){if(re)throw new Error("target.depthTexture not supported in Cube render targets");U(N.__webglFramebuffer,L)}else if(re){N.__webglDepthbuffer=[];for(let pe=0;pe<6;pe++)t.bindFramebuffer(36160,N.__webglFramebuffer[pe]),N.__webglDepthbuffer[pe]=r.createRenderbuffer(),nt(N.__webglDepthbuffer[pe],L,!1)}else t.bindFramebuffer(36160,N.__webglFramebuffer),N.__webglDepthbuffer=r.createRenderbuffer(),nt(N.__webglDepthbuffer,L,!1);t.bindFramebuffer(36160,null)}function ae(L,N,re){const pe=n.get(L);N!==void 0&&Je(pe.__webglFramebuffer,L,L.texture,36064,3553),re!==void 0&&j(L)}function be(L){const N=L.texture,re=n.get(L),pe=n.get(N);L.addEventListener("dispose",q),L.isWebGLMultipleRenderTargets!==!0&&(pe.__webglTexture===void 0&&(pe.__webglTexture=r.createTexture()),pe.__version=N.version,o.memory.textures++);const ge=L.isWebGLCubeRenderTarget===!0,Me=L.isWebGLMultipleRenderTargets===!0,Pe=x(L)||a;if(ge){re.__webglFramebuffer=[];for(let G=0;G<6;G++)re.__webglFramebuffer[G]=r.createFramebuffer()}else{if(re.__webglFramebuffer=r.createFramebuffer(),Me)if(i.drawBuffers){const G=L.texture;for(let se=0,Be=G.length;se<Be;se++){const De=n.get(G[se]);De.__webglTexture===void 0&&(De.__webglTexture=r.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&L.samples>0&&we(L)===!1){const G=Me?N:[N];re.__webglMultisampledFramebuffer=r.createFramebuffer(),re.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,re.__webglMultisampledFramebuffer);for(let se=0;se<G.length;se++){const Be=G[se];re.__webglColorRenderbuffer[se]=r.createRenderbuffer(),r.bindRenderbuffer(36161,re.__webglColorRenderbuffer[se]);const De=s.convert(Be.format,Be.encoding),je=s.convert(Be.type),Xe=S(Be.internalFormat,De,je,Be.encoding,L.isXRRenderTarget===!0),Ue=Ae(L);r.renderbufferStorageMultisample(36161,Ue,Xe,L.width,L.height),r.framebufferRenderbuffer(36160,36064+se,36161,re.__webglColorRenderbuffer[se])}r.bindRenderbuffer(36161,null),L.depthBuffer&&(re.__webglDepthRenderbuffer=r.createRenderbuffer(),nt(re.__webglDepthRenderbuffer,L,!0)),t.bindFramebuffer(36160,null)}}if(ge){t.bindTexture(34067,pe.__webglTexture),Le(34067,N,Pe);for(let G=0;G<6;G++)Je(re.__webglFramebuffer[G],L,N,36064,34069+G);I(N,Pe)&&C(34067),t.unbindTexture()}else if(Me){const G=L.texture;for(let se=0,Be=G.length;se<Be;se++){const De=G[se],je=n.get(De);t.bindTexture(3553,je.__webglTexture),Le(3553,De,Pe),Je(re.__webglFramebuffer,L,De,36064+se,3553),I(De,Pe)&&C(3553)}t.unbindTexture()}else{let G=3553;(L.isWebGL3DRenderTarget||L.isWebGLArrayRenderTarget)&&(a?G=L.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(G,pe.__webglTexture),Le(G,N,Pe),Je(re.__webglFramebuffer,L,N,36064,G),I(N,Pe)&&C(G),t.unbindTexture()}L.depthBuffer&&j(L)}function de(L){const N=x(L)||a,re=L.isWebGLMultipleRenderTargets===!0?L.texture:[L.texture];for(let pe=0,ge=re.length;pe<ge;pe++){const Me=re[pe];if(I(Me,N)){const Pe=L.isWebGLCubeRenderTarget?34067:3553,G=n.get(Me).__webglTexture;t.bindTexture(Pe,G),C(Pe),t.unbindTexture()}}}function Ee(L){if(a&&L.samples>0&&we(L)===!1){const N=L.isWebGLMultipleRenderTargets?L.texture:[L.texture],re=L.width,pe=L.height;let ge=16384;const Me=[],Pe=L.stencilBuffer?33306:36096,G=n.get(L),se=L.isWebGLMultipleRenderTargets===!0;if(se)for(let Be=0;Be<N.length;Be++)t.bindFramebuffer(36160,G.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064+Be,36161,null),t.bindFramebuffer(36160,G.__webglFramebuffer),r.framebufferTexture2D(36009,36064+Be,3553,null,0);t.bindFramebuffer(36008,G.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,G.__webglFramebuffer);for(let Be=0;Be<N.length;Be++){Me.push(36064+Be),L.depthBuffer&&Me.push(Pe);const De=G.__ignoreDepthValues!==void 0?G.__ignoreDepthValues:!1;if(De===!1&&(L.depthBuffer&&(ge|=256),L.stencilBuffer&&(ge|=1024)),se&&r.framebufferRenderbuffer(36008,36064,36161,G.__webglColorRenderbuffer[Be]),De===!0&&(r.invalidateFramebuffer(36008,[Pe]),r.invalidateFramebuffer(36009,[Pe])),se){const je=n.get(N[Be]).__webglTexture;r.framebufferTexture2D(36009,36064,3553,je,0)}r.blitFramebuffer(0,0,re,pe,0,0,re,pe,ge,9728),d&&r.invalidateFramebuffer(36008,Me)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),se)for(let Be=0;Be<N.length;Be++){t.bindFramebuffer(36160,G.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064+Be,36161,G.__webglColorRenderbuffer[Be]);const De=n.get(N[Be]).__webglTexture;t.bindFramebuffer(36160,G.__webglFramebuffer),r.framebufferTexture2D(36009,36064+Be,3553,De,0)}t.bindFramebuffer(36009,G.__webglMultisampledFramebuffer)}}function Ae(L){return Math.min(h,L.samples)}function we(L){const N=n.get(L);return a&&L.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&N.__useRenderToTexture!==!1}function ke(L){const N=o.render.frame;g.get(L)!==N&&(g.set(L,N),L.update())}function Se(L,N){const re=L.encoding,pe=L.format,ge=L.type;return L.isCompressedTexture===!0||L.isVideoTexture===!0||L.format===Yp||re!==ba&&(re===$t?a===!1?e.has("EXT_sRGB")===!0&&pe===fi?(L.format=Yp,L.minFilter=Er,L.generateMipmaps=!1):N=Cw.sRGBToLinear(N):(pe!==fi||ge!==_a)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",re)),N}this.allocateTextureUnit=Y,this.resetTextureUnits=Z,this.setTexture2D=le,this.setTexture2DArray=ve,this.setTexture3D=ee,this.setTextureCube=_e,this.rebindTextures=ae,this.setupRenderTarget=be,this.updateRenderTargetMipmap=de,this.updateMultisampleRenderTarget=Ee,this.setupDepthRenderbuffer=j,this.setupFrameBufferTexture=Je,this.useMultisampledRTT=we}function cD(r,e,t){const n=t.isWebGL2;function i(s,o=null){let a;if(s===_a)return 5121;if(s===OC)return 32819;if(s===FC)return 32820;if(s===PC)return 5120;if(s===LC)return 5122;if(s===ww)return 5123;if(s===DC)return 5124;if(s===ea)return 5125;if(s===io)return 5126;if(s===ac)return n?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===$C)return 6406;if(s===fi)return 6408;if(s===zC)return 6409;if(s===BC)return 6410;if(s===ca)return 6402;if(s===Dl)return 34041;if(s===Yp)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===UC)return 6403;if(s===VC)return 36244;if(s===WC)return 33319;if(s===GC)return 33320;if(s===HC)return 36249;if(s===xd||s===vd||s===wd||s===Sd)if(o===$t)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===xd)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===vd)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===wd)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Sd)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===xd)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===vd)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===wd)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Sd)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===t_||s===n_||s===r_||s===i_)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===t_)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===n_)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===r_)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===i_)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===jC)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===s_||s===o_)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===s_)return o===$t?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===o_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===a_||s===l_||s===u_||s===c_||s===h_||s===f_||s===d_||s===p_||s===m_||s===g_||s===y_||s===__||s===b_||s===x_)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===a_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===l_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===u_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===c_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===h_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===f_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===d_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===p_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===m_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===g_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===y_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===__)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===b_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===x_)return o===$t?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===Td)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===Td)return o===$t?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(s===qC||s===v_||s===w_||s===S_)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===Td)return a.COMPRESSED_RED_RGTC1_EXT;if(s===v_)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===w_)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===S_)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===vl?n?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):r[s]!==void 0?r[s]:null}return{convert:i}}class hD extends dr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class na extends gn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const fD={type:"move"};class Xd{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new na,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new na,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ie,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ie),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new na,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ie,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ie),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,s=null,o=null;const a=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){o=!0;for(const p of e.hand.values()){const m=t.getJointPose(p,n),_=this._getHandJoint(u,p);m!==null&&(_.matrix.fromArray(m.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.jointRadius=m.radius),_.visible=m!==null}const c=u.joints["index-finger-tip"],h=u.joints["thumb-tip"],f=c.position.distanceTo(h.position),d=.02,g=.005;u.inputState.pinching&&f>d+g?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&f<=d-g&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(fD)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=s!==null),u!==null&&(u.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new na;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class dD extends Hn{constructor(e,t,n,i,s,o,a,l,u,c){if(c=c!==void 0?c:ca,c!==ca&&c!==Dl)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&c===ca&&(n=ea),n===void 0&&c===Dl&&(n=vl),super(null,i,s,o,a,l,c,n,u),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:Fn,this.minFilter=l!==void 0?l:Fn,this.flipY=!1,this.generateMipmaps=!1}}class pD extends Ra{constructor(e,t){super();const n=this;let i=null,s=1,o=null,a="local-floor",l=1,u=null,c=null,h=null,f=null,d=null,g=null;const p=t.getContextAttributes();let m=null,_=null;const v=[],b=[],x=new Set,T=new Map,I=new dr;I.layers.enable(1),I.viewport=new Yt;const C=new dr;C.layers.enable(2),C.viewport=new Yt;const S=[I,C],A=new hD;A.layers.enable(1),A.layers.enable(2);let R=null,F=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ee){let _e=v[ee];return _e===void 0&&(_e=new Xd,v[ee]=_e),_e.getTargetRaySpace()},this.getControllerGrip=function(ee){let _e=v[ee];return _e===void 0&&(_e=new Xd,v[ee]=_e),_e.getGripSpace()},this.getHand=function(ee){let _e=v[ee];return _e===void 0&&(_e=new Xd,v[ee]=_e),_e.getHandSpace()};function q(ee){const _e=b.indexOf(ee.inputSource);if(_e===-1)return;const Te=v[_e];Te!==void 0&&Te.dispatchEvent({type:ee.type,data:ee.inputSource})}function O(){i.removeEventListener("select",q),i.removeEventListener("selectstart",q),i.removeEventListener("selectend",q),i.removeEventListener("squeeze",q),i.removeEventListener("squeezestart",q),i.removeEventListener("squeezeend",q),i.removeEventListener("end",O),i.removeEventListener("inputsourceschange",z);for(let ee=0;ee<v.length;ee++){const _e=b[ee];_e!==null&&(b[ee]=null,v[ee].disconnect(_e))}R=null,F=null,e.setRenderTarget(m),d=null,f=null,h=null,i=null,_=null,ve.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ee){s=ee,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ee){a=ee,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||o},this.setReferenceSpace=function(ee){u=ee},this.getBaseLayer=function(){return f!==null?f:d},this.getBinding=function(){return h},this.getFrame=function(){return g},this.getSession=function(){return i},this.setSession=async function(ee){if(i=ee,i!==null){if(m=e.getRenderTarget(),i.addEventListener("select",q),i.addEventListener("selectstart",q),i.addEventListener("selectend",q),i.addEventListener("squeeze",q),i.addEventListener("squeezestart",q),i.addEventListener("squeezeend",q),i.addEventListener("end",O),i.addEventListener("inputsourceschange",z),p.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const _e={antialias:i.renderState.layers===void 0?p.antialias:!0,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(i,t,_e),i.updateRenderState({baseLayer:d}),_=new xa(d.framebufferWidth,d.framebufferHeight,{format:fi,type:_a,encoding:e.outputEncoding,stencilBuffer:p.stencil})}else{let _e=null,Te=null,ne=null;p.depth&&(ne=p.stencil?35056:33190,_e=p.stencil?Dl:ca,Te=p.stencil?vl:ea);const Le={colorFormat:32856,depthFormat:ne,scaleFactor:s};h=new XRWebGLBinding(i,t),f=h.createProjectionLayer(Le),i.updateRenderState({layers:[f]}),_=new xa(f.textureWidth,f.textureHeight,{format:fi,type:_a,depthTexture:new dD(f.textureWidth,f.textureHeight,Te,void 0,void 0,void 0,void 0,void 0,void 0,_e),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0});const Ve=e.properties.get(_);Ve.__ignoreDepthValues=f.ignoreDepthValues}_.isXRRenderTarget=!0,this.setFoveation(l),u=null,o=await i.requestReferenceSpace(a),ve.setContext(i),ve.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function z(ee){for(let _e=0;_e<ee.removed.length;_e++){const Te=ee.removed[_e],ne=b.indexOf(Te);ne>=0&&(b[ne]=null,v[ne].disconnect(Te))}for(let _e=0;_e<ee.added.length;_e++){const Te=ee.added[_e];let ne=b.indexOf(Te);if(ne===-1){for(let Ve=0;Ve<v.length;Ve++)if(Ve>=b.length){b.push(Te),ne=Ve;break}else if(b[Ve]===null){b[Ve]=Te,ne=Ve;break}if(ne===-1)break}const Le=v[ne];Le&&Le.connect(Te)}}const H=new ie,Q=new ie;function Z(ee,_e,Te){H.setFromMatrixPosition(_e.matrixWorld),Q.setFromMatrixPosition(Te.matrixWorld);const ne=H.distanceTo(Q),Le=_e.projectionMatrix.elements,Ve=Te.projectionMatrix.elements,He=Le[14]/(Le[10]-1),We=Le[14]/(Le[10]+1),Je=(Le[9]+1)/Le[5],nt=(Le[9]-1)/Le[5],U=(Le[8]-1)/Le[0],j=(Ve[8]+1)/Ve[0],ae=He*U,be=He*j,de=ne/(-U+j),Ee=de*-U;_e.matrixWorld.decompose(ee.position,ee.quaternion,ee.scale),ee.translateX(Ee),ee.translateZ(de),ee.matrixWorld.compose(ee.position,ee.quaternion,ee.scale),ee.matrixWorldInverse.copy(ee.matrixWorld).invert();const Ae=He+de,we=We+de,ke=ae-Ee,Se=be+(ne-Ee),L=Je*We/we*Ae,N=nt*We/we*Ae;ee.projectionMatrix.makePerspective(ke,Se,L,N,Ae,we)}function Y(ee,_e){_e===null?ee.matrixWorld.copy(ee.matrix):ee.matrixWorld.multiplyMatrices(_e.matrixWorld,ee.matrix),ee.matrixWorldInverse.copy(ee.matrixWorld).invert()}this.updateCamera=function(ee){if(i===null)return;A.near=C.near=I.near=ee.near,A.far=C.far=I.far=ee.far,(R!==A.near||F!==A.far)&&(i.updateRenderState({depthNear:A.near,depthFar:A.far}),R=A.near,F=A.far);const _e=ee.parent,Te=A.cameras;Y(A,_e);for(let Le=0;Le<Te.length;Le++)Y(Te[Le],_e);A.matrixWorld.decompose(A.position,A.quaternion,A.scale),ee.matrix.copy(A.matrix),ee.matrix.decompose(ee.position,ee.quaternion,ee.scale);const ne=ee.children;for(let Le=0,Ve=ne.length;Le<Ve;Le++)ne[Le].updateMatrixWorld(!0);Te.length===2?Z(A,I,C):A.projectionMatrix.copy(I.projectionMatrix)},this.getCamera=function(){return A},this.getFoveation=function(){if(!(f===null&&d===null))return l},this.setFoveation=function(ee){l=ee,f!==null&&(f.fixedFoveation=ee),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=ee)},this.getPlanes=function(){return x};let fe=null;function le(ee,_e){if(c=_e.getViewerPose(u||o),g=_e,c!==null){const Te=c.views;d!==null&&(e.setRenderTargetFramebuffer(_,d.framebuffer),e.setRenderTarget(_));let ne=!1;Te.length!==A.cameras.length&&(A.cameras.length=0,ne=!0);for(let Le=0;Le<Te.length;Le++){const Ve=Te[Le];let He=null;if(d!==null)He=d.getViewport(Ve);else{const Je=h.getViewSubImage(f,Ve);He=Je.viewport,Le===0&&(e.setRenderTargetTextures(_,Je.colorTexture,f.ignoreDepthValues?void 0:Je.depthStencilTexture),e.setRenderTarget(_))}let We=S[Le];We===void 0&&(We=new dr,We.layers.enable(Le),We.viewport=new Yt,S[Le]=We),We.matrix.fromArray(Ve.transform.matrix),We.projectionMatrix.fromArray(Ve.projectionMatrix),We.viewport.set(He.x,He.y,He.width,He.height),Le===0&&A.matrix.copy(We.matrix),ne===!0&&A.cameras.push(We)}}for(let Te=0;Te<v.length;Te++){const ne=b[Te],Le=v[Te];ne!==null&&Le!==void 0&&Le.update(ne,_e,u||o)}if(fe&&fe(ee,_e),_e.detectedPlanes){n.dispatchEvent({type:"planesdetected",data:_e.detectedPlanes});let Te=null;for(const ne of x)_e.detectedPlanes.has(ne)||(Te===null&&(Te=[]),Te.push(ne));if(Te!==null)for(const ne of Te)x.delete(ne),T.delete(ne),n.dispatchEvent({type:"planeremoved",data:ne});for(const ne of _e.detectedPlanes)if(!x.has(ne))x.add(ne),T.set(ne,_e.lastChangedTime),n.dispatchEvent({type:"planeadded",data:ne});else{const Le=T.get(ne);ne.lastChangedTime>Le&&(T.set(ne,ne.lastChangedTime),n.dispatchEvent({type:"planechanged",data:ne}))}}g=null}const ve=new zw;ve.setAnimationLoop(le),this.setAnimationLoop=function(ee){fe=ee},this.dispose=function(){}}}function mD(r,e){function t(p,m){m.color.getRGB(p.fogColor.value,Ow(r)),m.isFog?(p.fogNear.value=m.near,p.fogFar.value=m.far):m.isFogExp2&&(p.fogDensity.value=m.density)}function n(p,m,_,v,b){m.isMeshBasicMaterial||m.isMeshLambertMaterial?i(p,m):m.isMeshToonMaterial?(i(p,m),c(p,m)):m.isMeshPhongMaterial?(i(p,m),u(p,m)):m.isMeshStandardMaterial?(i(p,m),h(p,m),m.isMeshPhysicalMaterial&&f(p,m,b)):m.isMeshMatcapMaterial?(i(p,m),d(p,m)):m.isMeshDepthMaterial?i(p,m):m.isMeshDistanceMaterial?(i(p,m),g(p,m)):m.isMeshNormalMaterial?i(p,m):m.isLineBasicMaterial?(s(p,m),m.isLineDashedMaterial&&o(p,m)):m.isPointsMaterial?a(p,m,_,v):m.isSpriteMaterial?l(p,m):m.isShadowMaterial?(p.color.value.copy(m.color),p.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function i(p,m){p.opacity.value=m.opacity,m.color&&p.diffuse.value.copy(m.color),m.emissive&&p.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(p.map.value=m.map),m.alphaMap&&(p.alphaMap.value=m.alphaMap),m.bumpMap&&(p.bumpMap.value=m.bumpMap,p.bumpScale.value=m.bumpScale,m.side===Vr&&(p.bumpScale.value*=-1)),m.displacementMap&&(p.displacementMap.value=m.displacementMap,p.displacementScale.value=m.displacementScale,p.displacementBias.value=m.displacementBias),m.emissiveMap&&(p.emissiveMap.value=m.emissiveMap),m.normalMap&&(p.normalMap.value=m.normalMap,p.normalScale.value.copy(m.normalScale),m.side===Vr&&p.normalScale.value.negate()),m.specularMap&&(p.specularMap.value=m.specularMap),m.alphaTest>0&&(p.alphaTest.value=m.alphaTest);const _=e.get(m).envMap;if(_&&(p.envMap.value=_,p.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=m.reflectivity,p.ior.value=m.ior,p.refractionRatio.value=m.refractionRatio),m.lightMap){p.lightMap.value=m.lightMap;const x=r.useLegacyLights===!0?Math.PI:1;p.lightMapIntensity.value=m.lightMapIntensity*x}m.aoMap&&(p.aoMap.value=m.aoMap,p.aoMapIntensity.value=m.aoMapIntensity);let v;m.map?v=m.map:m.specularMap?v=m.specularMap:m.displacementMap?v=m.displacementMap:m.normalMap?v=m.normalMap:m.bumpMap?v=m.bumpMap:m.roughnessMap?v=m.roughnessMap:m.metalnessMap?v=m.metalnessMap:m.alphaMap?v=m.alphaMap:m.emissiveMap?v=m.emissiveMap:m.clearcoatMap?v=m.clearcoatMap:m.clearcoatNormalMap?v=m.clearcoatNormalMap:m.clearcoatRoughnessMap?v=m.clearcoatRoughnessMap:m.iridescenceMap?v=m.iridescenceMap:m.iridescenceThicknessMap?v=m.iridescenceThicknessMap:m.specularIntensityMap?v=m.specularIntensityMap:m.specularColorMap?v=m.specularColorMap:m.transmissionMap?v=m.transmissionMap:m.thicknessMap?v=m.thicknessMap:m.sheenColorMap?v=m.sheenColorMap:m.sheenRoughnessMap&&(v=m.sheenRoughnessMap),v!==void 0&&(v.isWebGLRenderTarget&&(v=v.texture),v.matrixAutoUpdate===!0&&v.updateMatrix(),p.uvTransform.value.copy(v.matrix));let b;m.aoMap?b=m.aoMap:m.lightMap&&(b=m.lightMap),b!==void 0&&(b.isWebGLRenderTarget&&(b=b.texture),b.matrixAutoUpdate===!0&&b.updateMatrix(),p.uv2Transform.value.copy(b.matrix))}function s(p,m){p.diffuse.value.copy(m.color),p.opacity.value=m.opacity}function o(p,m){p.dashSize.value=m.dashSize,p.totalSize.value=m.dashSize+m.gapSize,p.scale.value=m.scale}function a(p,m,_,v){p.diffuse.value.copy(m.color),p.opacity.value=m.opacity,p.size.value=m.size*_,p.scale.value=v*.5,m.map&&(p.map.value=m.map),m.alphaMap&&(p.alphaMap.value=m.alphaMap),m.alphaTest>0&&(p.alphaTest.value=m.alphaTest);let b;m.map?b=m.map:m.alphaMap&&(b=m.alphaMap),b!==void 0&&(b.matrixAutoUpdate===!0&&b.updateMatrix(),p.uvTransform.value.copy(b.matrix))}function l(p,m){p.diffuse.value.copy(m.color),p.opacity.value=m.opacity,p.rotation.value=m.rotation,m.map&&(p.map.value=m.map),m.alphaMap&&(p.alphaMap.value=m.alphaMap),m.alphaTest>0&&(p.alphaTest.value=m.alphaTest);let _;m.map?_=m.map:m.alphaMap&&(_=m.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),p.uvTransform.value.copy(_.matrix))}function u(p,m){p.specular.value.copy(m.specular),p.shininess.value=Math.max(m.shininess,1e-4)}function c(p,m){m.gradientMap&&(p.gradientMap.value=m.gradientMap)}function h(p,m){p.roughness.value=m.roughness,p.metalness.value=m.metalness,m.roughnessMap&&(p.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(p.metalnessMap.value=m.metalnessMap),e.get(m).envMap&&(p.envMapIntensity.value=m.envMapIntensity)}function f(p,m,_){p.ior.value=m.ior,m.sheen>0&&(p.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),p.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(p.sheenColorMap.value=m.sheenColorMap),m.sheenRoughnessMap&&(p.sheenRoughnessMap.value=m.sheenRoughnessMap)),m.clearcoat>0&&(p.clearcoat.value=m.clearcoat,p.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(p.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),p.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===Vr&&p.clearcoatNormalScale.value.negate())),m.iridescence>0&&(p.iridescence.value=m.iridescence,p.iridescenceIOR.value=m.iridescenceIOR,p.iridescenceThicknessMinimum.value=m.iridescenceThicknessRange[0],p.iridescenceThicknessMaximum.value=m.iridescenceThicknessRange[1],m.iridescenceMap&&(p.iridescenceMap.value=m.iridescenceMap),m.iridescenceThicknessMap&&(p.iridescenceThicknessMap.value=m.iridescenceThicknessMap)),m.transmission>0&&(p.transmission.value=m.transmission,p.transmissionSamplerMap.value=_.texture,p.transmissionSamplerSize.value.set(_.width,_.height),m.transmissionMap&&(p.transmissionMap.value=m.transmissionMap),p.thickness.value=m.thickness,m.thicknessMap&&(p.thicknessMap.value=m.thicknessMap),p.attenuationDistance.value=m.attenuationDistance,p.attenuationColor.value.copy(m.attenuationColor)),p.specularIntensity.value=m.specularIntensity,p.specularColor.value.copy(m.specularColor),m.specularIntensityMap&&(p.specularIntensityMap.value=m.specularIntensityMap),m.specularColorMap&&(p.specularColorMap.value=m.specularColorMap)}function d(p,m){m.matcap&&(p.matcap.value=m.matcap)}function g(p,m){p.referencePosition.value.copy(m.referencePosition),p.nearDistance.value=m.nearDistance,p.farDistance.value=m.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function gD(r,e,t,n){let i={},s={},o=[];const a=t.isWebGL2?r.getParameter(35375):0;function l(v,b){const x=b.program;n.uniformBlockBinding(v,x)}function u(v,b){let x=i[v.id];x===void 0&&(g(v),x=c(v),i[v.id]=x,v.addEventListener("dispose",m));const T=b.program;n.updateUBOMapping(v,T);const I=e.render.frame;s[v.id]!==I&&(f(v),s[v.id]=I)}function c(v){const b=h();v.__bindingPointIndex=b;const x=r.createBuffer(),T=v.__size,I=v.usage;return r.bindBuffer(35345,x),r.bufferData(35345,T,I),r.bindBuffer(35345,null),r.bindBufferBase(35345,b,x),x}function h(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function f(v){const b=i[v.id],x=v.uniforms,T=v.__cache;r.bindBuffer(35345,b);for(let I=0,C=x.length;I<C;I++){const S=x[I];if(d(S,I,T)===!0){const A=S.__offset,R=Array.isArray(S.value)?S.value:[S.value];let F=0;for(let q=0;q<R.length;q++){const O=R[q],z=p(O);typeof O=="number"?(S.__data[0]=O,r.bufferSubData(35345,A+F,S.__data)):O.isMatrix3?(S.__data[0]=O.elements[0],S.__data[1]=O.elements[1],S.__data[2]=O.elements[2],S.__data[3]=O.elements[0],S.__data[4]=O.elements[3],S.__data[5]=O.elements[4],S.__data[6]=O.elements[5],S.__data[7]=O.elements[0],S.__data[8]=O.elements[6],S.__data[9]=O.elements[7],S.__data[10]=O.elements[8],S.__data[11]=O.elements[0]):(O.toArray(S.__data,F),F+=z.storage/Float32Array.BYTES_PER_ELEMENT)}r.bufferSubData(35345,A,S.__data)}}r.bindBuffer(35345,null)}function d(v,b,x){const T=v.value;if(x[b]===void 0){if(typeof T=="number")x[b]=T;else{const I=Array.isArray(T)?T:[T],C=[];for(let S=0;S<I.length;S++)C.push(I[S].clone());x[b]=C}return!0}else if(typeof T=="number"){if(x[b]!==T)return x[b]=T,!0}else{const I=Array.isArray(x[b])?x[b]:[x[b]],C=Array.isArray(T)?T:[T];for(let S=0;S<I.length;S++){const A=I[S];if(A.equals(C[S])===!1)return A.copy(C[S]),!0}}return!1}function g(v){const b=v.uniforms;let x=0;const T=16;let I=0;for(let C=0,S=b.length;C<S;C++){const A=b[C],R={boundary:0,storage:0},F=Array.isArray(A.value)?A.value:[A.value];for(let q=0,O=F.length;q<O;q++){const z=F[q],H=p(z);R.boundary+=H.boundary,R.storage+=H.storage}if(A.__data=new Float32Array(R.storage/Float32Array.BYTES_PER_ELEMENT),A.__offset=x,C>0){I=x%T;const q=T-I;I!==0&&q-R.boundary<0&&(x+=T-I,A.__offset=x)}x+=R.storage}return I=x%T,I>0&&(x+=T-I),v.__size=x,v.__cache={},this}function p(v){const b={boundary:0,storage:0};return typeof v=="number"?(b.boundary=4,b.storage=4):v.isVector2?(b.boundary=8,b.storage=8):v.isVector3||v.isColor?(b.boundary=16,b.storage=12):v.isVector4?(b.boundary=16,b.storage=16):v.isMatrix3?(b.boundary=48,b.storage=48):v.isMatrix4?(b.boundary=64,b.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),b}function m(v){const b=v.target;b.removeEventListener("dispose",m);const x=o.indexOf(b.__bindingPointIndex);o.splice(x,1),r.deleteBuffer(i[b.id]),delete i[b.id],delete s[b.id]}function _(){for(const v in i)r.deleteBuffer(i[v]);o=[],i={},s={}}return{bind:l,update:u,dispose:_}}function yD(){const r=hc("canvas");return r.style.display="block",r}function jg(r={}){this.isWebGLRenderer=!0;const e=r.canvas!==void 0?r.canvas:yD(),t=r.context!==void 0?r.context:null,n=r.depth!==void 0?r.depth:!0,i=r.stencil!==void 0?r.stencil:!0,s=r.antialias!==void 0?r.antialias:!1,o=r.premultipliedAlpha!==void 0?r.premultipliedAlpha:!0,a=r.preserveDrawingBuffer!==void 0?r.preserveDrawingBuffer:!1,l=r.powerPreference!==void 0?r.powerPreference:"default",u=r.failIfMajorPerformanceCaveat!==void 0?r.failIfMajorPerformanceCaveat:!1;let c;t!==null?c=t.getContextAttributes().alpha:c=r.alpha!==void 0?r.alpha:!1;let h=null,f=null;const d=[],g=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=ba,this.useLegacyLights=!0,this.toneMapping=As,this.toneMappingExposure=1;const p=this;let m=!1,_=0,v=0,b=null,x=-1,T=null;const I=new Yt,C=new Yt;let S=null,A=e.width,R=e.height,F=1,q=null,O=null;const z=new Yt(0,0,A,R),H=new Yt(0,0,A,R);let Q=!1;const Z=new Vg;let Y=!1,fe=!1,le=null;const ve=new Ct,ee=new ie,_e={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Te(){return b===null?F:1}let ne=t;function Le($,ue){for(let he=0;he<$.length;he++){const oe=$[he],xe=e.getContext(oe,ue);if(xe!==null)return xe}return null}try{const $={alpha:!0,depth:n,stencil:i,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${zg}`),e.addEventListener("webglcontextlost",je,!1),e.addEventListener("webglcontextrestored",Xe,!1),e.addEventListener("webglcontextcreationerror",Ue,!1),ne===null){const ue=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&ue.shift(),ne=Le(ue,$),ne===null)throw Le(ue)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}ne.getShaderPrecisionFormat===void 0&&(ne.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch($){throw console.error("THREE.WebGLRenderer: "+$.message),$}let Ve,He,We,Je,nt,U,j,ae,be,de,Ee,Ae,we,ke,Se,L,N,re,pe,ge,Me,Pe,G,se;function Be(){Ve=new IP(ne),He=new wP(ne,Ve,r),Ve.init(He),Pe=new cD(ne,Ve,He),We=new lD(ne,Ve,He),Je=new NP,nt=new KL,U=new uD(ne,Ve,We,nt,He,Pe,Je),j=new TP(p),ae=new AP(p),be=new Bk(ne,He),G=new xP(ne,Ve,be,He),de=new CP(ne,be,Je,G),Ee=new DP(ne,de,be,Je),pe=new LP(ne,He,U),L=new SP(nt),Ae=new qL(p,j,ae,Ve,He,G,L),we=new mD(p,nt),ke=new YL,Se=new nD(Ve,He),re=new bP(p,j,ae,We,Ee,c,o),N=new aD(p,Ee,He),se=new gD(ne,Je,He,We),ge=new vP(ne,Ve,Je,He),Me=new kP(ne,Ve,Je,He),Je.programs=Ae.programs,p.capabilities=He,p.extensions=Ve,p.properties=nt,p.renderLists=ke,p.shadowMap=N,p.state=We,p.info=Je}Be();const De=new pD(p,ne);this.xr=De,this.getContext=function(){return ne},this.getContextAttributes=function(){return ne.getContextAttributes()},this.forceContextLoss=function(){const $=Ve.get("WEBGL_lose_context");$&&$.loseContext()},this.forceContextRestore=function(){const $=Ve.get("WEBGL_lose_context");$&&$.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function($){$!==void 0&&(F=$,this.setSize(A,R,!1))},this.getSize=function($){return $.set(A,R)},this.setSize=function($,ue,he=!0){if(De.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=$,R=ue,e.width=Math.floor($*F),e.height=Math.floor(ue*F),he===!0&&(e.style.width=$+"px",e.style.height=ue+"px"),this.setViewport(0,0,$,ue)},this.getDrawingBufferSize=function($){return $.set(A*F,R*F).floor()},this.setDrawingBufferSize=function($,ue,he){A=$,R=ue,F=he,e.width=Math.floor($*he),e.height=Math.floor(ue*he),this.setViewport(0,0,$,ue)},this.getCurrentViewport=function($){return $.copy(I)},this.getViewport=function($){return $.copy(z)},this.setViewport=function($,ue,he,oe){$.isVector4?z.set($.x,$.y,$.z,$.w):z.set($,ue,he,oe),We.viewport(I.copy(z).multiplyScalar(F).floor())},this.getScissor=function($){return $.copy(H)},this.setScissor=function($,ue,he,oe){$.isVector4?H.set($.x,$.y,$.z,$.w):H.set($,ue,he,oe),We.scissor(C.copy(H).multiplyScalar(F).floor())},this.getScissorTest=function(){return Q},this.setScissorTest=function($){We.setScissorTest(Q=$)},this.setOpaqueSort=function($){q=$},this.setTransparentSort=function($){O=$},this.getClearColor=function($){return $.copy(re.getClearColor())},this.setClearColor=function(){re.setClearColor.apply(re,arguments)},this.getClearAlpha=function(){return re.getClearAlpha()},this.setClearAlpha=function(){re.setClearAlpha.apply(re,arguments)},this.clear=function($=!0,ue=!0,he=!0){let oe=0;$&&(oe|=16384),ue&&(oe|=256),he&&(oe|=1024),ne.clear(oe)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",je,!1),e.removeEventListener("webglcontextrestored",Xe,!1),e.removeEventListener("webglcontextcreationerror",Ue,!1),ke.dispose(),Se.dispose(),nt.dispose(),j.dispose(),ae.dispose(),Ee.dispose(),G.dispose(),se.dispose(),Ae.dispose(),De.dispose(),De.removeEventListener("sessionstart",Ne),De.removeEventListener("sessionend",qe),le&&(le.dispose(),le=null),Ke.stop()};function je($){$.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Xe(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1;const $=Je.autoReset,ue=N.enabled,he=N.autoUpdate,oe=N.needsUpdate,xe=N.type;Be(),Je.autoReset=$,N.enabled=ue,N.autoUpdate=he,N.needsUpdate=oe,N.type=xe}function Ue($){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",$.statusMessage)}function ot($){const ue=$.target;ue.removeEventListener("dispose",ot),xt(ue)}function xt($){Ot($),nt.remove($)}function Ot($){const ue=nt.get($).programs;ue!==void 0&&(ue.forEach(function(he){Ae.releaseProgram(he)}),$.isShaderMaterial&&Ae.releaseShaderCache($))}this.renderBufferDirect=function($,ue,he,oe,xe,rt){ue===null&&(ue=_e);const at=xe.isMesh&&xe.matrixWorld.determinant()<0,dt=Hs($,ue,he,oe,xe);We.setMaterial(oe,at);let pt=he.index,Tt=1;oe.wireframe===!0&&(pt=de.getWireframeAttribute(he),Tt=2);const At=he.drawRange,Et=he.attributes.position;let cn=At.start*Tt,qn=(At.start+At.count)*Tt;rt!==null&&(cn=Math.max(cn,rt.start*Tt),qn=Math.min(qn,(rt.start+rt.count)*Tt)),pt!==null?(cn=Math.max(cn,0),qn=Math.min(qn,pt.count)):Et!=null&&(cn=Math.max(cn,0),qn=Math.min(qn,Et.count));const bn=qn-cn;if(bn<0||bn===1/0)return;G.setup(xe,oe,dt,he,pt);let Ln,en=ge;if(pt!==null&&(Ln=be.get(pt),en=Me,en.setIndex(Ln)),xe.isMesh)oe.wireframe===!0?(We.setLineWidth(oe.wireframeLinewidth*Te()),en.setMode(1)):en.setMode(4);else if(xe.isLine){let Mt=oe.linewidth;Mt===void 0&&(Mt=1),We.setLineWidth(Mt*Te()),xe.isLineSegments?en.setMode(1):xe.isLineLoop?en.setMode(2):en.setMode(3)}else xe.isPoints?en.setMode(0):xe.isSprite&&en.setMode(4);if(xe.isInstancedMesh)en.renderInstances(cn,bn,xe.count);else if(he.isInstancedBufferGeometry){const Mt=he._maxInstanceCount!==void 0?he._maxInstanceCount:1/0,Ro=Math.min(he.instanceCount,Mt);en.renderInstances(cn,bn,Ro)}else en.render(cn,bn)},this.compile=function($,ue){function he(oe,xe,rt){oe.transparent===!0&&oe.side===ws&&oe.forceSinglePass===!1?(oe.side=Vr,oe.needsUpdate=!0,Bn(oe,xe,rt),oe.side=Rs,oe.needsUpdate=!0,Bn(oe,xe,rt),oe.side=ws):Bn(oe,xe,rt)}f=Se.get($),f.init(),g.push(f),$.traverseVisible(function(oe){oe.isLight&&oe.layers.test(ue.layers)&&(f.pushLight(oe),oe.castShadow&&f.pushShadow(oe))}),f.setupLights(p.useLegacyLights),$.traverse(function(oe){const xe=oe.material;if(xe)if(Array.isArray(xe))for(let rt=0;rt<xe.length;rt++){const at=xe[rt];he(at,$,oe)}else he(xe,$,oe)}),g.pop(),f=null};let te=null;function me($){te&&te($)}function Ne(){Ke.stop()}function qe(){Ke.start()}const Ke=new zw;Ke.setAnimationLoop(me),typeof self<"u"&&Ke.setContext(self),this.setAnimationLoop=function($){te=$,De.setAnimationLoop($),$===null?Ke.stop():Ke.start()},De.addEventListener("sessionstart",Ne),De.addEventListener("sessionend",qe),this.render=function($,ue){if(ue!==void 0&&ue.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;$.matrixWorldAutoUpdate===!0&&$.updateMatrixWorld(),ue.parent===null&&ue.matrixWorldAutoUpdate===!0&&ue.updateMatrixWorld(),De.enabled===!0&&De.isPresenting===!0&&(De.cameraAutoUpdate===!0&&De.updateCamera(ue),ue=De.getCamera()),$.isScene===!0&&$.onBeforeRender(p,$,ue,b),f=Se.get($,g.length),f.init(),g.push(f),ve.multiplyMatrices(ue.projectionMatrix,ue.matrixWorldInverse),Z.setFromProjectionMatrix(ve),fe=this.localClippingEnabled,Y=L.init(this.clippingPlanes,fe),h=ke.get($,d.length),h.init(),d.push(h),Gt($,ue,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(q,O),Y===!0&&L.beginShadows();const he=f.state.shadowsArray;if(N.render(he,$,ue),Y===!0&&L.endShadows(),this.info.autoReset===!0&&this.info.reset(),re.render(h,$),f.setupLights(p.useLegacyLights),ue.isArrayCamera){const oe=ue.cameras;for(let xe=0,rt=oe.length;xe<rt;xe++){const at=oe[xe];Qt(h,$,at,at.viewport)}}else Qt(h,$,ue);b!==null&&(U.updateMultisampleRenderTarget(b),U.updateRenderTargetMipmap(b)),$.isScene===!0&&$.onAfterRender(p,$,ue),G.resetDefaultState(),x=-1,T=null,g.pop(),g.length>0?f=g[g.length-1]:f=null,d.pop(),d.length>0?h=d[d.length-1]:h=null};function Gt($,ue,he,oe){if($.visible===!1)return;if($.layers.test(ue.layers)){if($.isGroup)he=$.renderOrder;else if($.isLOD)$.autoUpdate===!0&&$.update(ue);else if($.isLight)f.pushLight($),$.castShadow&&f.pushShadow($);else if($.isSprite){if(!$.frustumCulled||Z.intersectsSprite($)){oe&&ee.setFromMatrixPosition($.matrixWorld).applyMatrix4(ve);const at=Ee.update($),dt=$.material;dt.visible&&h.push($,at,dt,he,ee.z,null)}}else if(($.isMesh||$.isLine||$.isPoints)&&($.isSkinnedMesh&&$.skeleton.frame!==Je.render.frame&&($.skeleton.update(),$.skeleton.frame=Je.render.frame),!$.frustumCulled||Z.intersectsObject($))){oe&&ee.setFromMatrixPosition($.matrixWorld).applyMatrix4(ve);const at=Ee.update($),dt=$.material;if(Array.isArray(dt)){const pt=at.groups;for(let Tt=0,At=pt.length;Tt<At;Tt++){const Et=pt[Tt],cn=dt[Et.materialIndex];cn&&cn.visible&&h.push($,at,cn,he,ee.z,Et)}}else dt.visible&&h.push($,at,dt,he,ee.z,null)}}const rt=$.children;for(let at=0,dt=rt.length;at<dt;at++)Gt(rt[at],ue,he,oe)}function Qt($,ue,he,oe){const xe=$.opaque,rt=$.transmissive,at=$.transparent;f.setupLightsView(he),Y===!0&&L.setGlobalState(p.clippingPlanes,he),rt.length>0&&An(xe,ue,he),oe&&We.viewport(I.copy(oe)),xe.length>0&&Lr(xe,ue,he),rt.length>0&&Lr(rt,ue,he),at.length>0&&Lr(at,ue,he),We.buffers.depth.setTest(!0),We.buffers.depth.setMask(!0),We.buffers.color.setMask(!0),We.setPolygonOffset(!1)}function An($,ue,he){const oe=He.isWebGL2;le===null&&(le=new xa(1024,1024,{generateMipmaps:!0,type:Ve.has("EXT_color_buffer_half_float")?ac:_a,minFilter:ya,samples:oe&&s===!0?4:0}));const xe=p.getRenderTarget();p.setRenderTarget(le),p.clear();const rt=p.toneMapping;p.toneMapping=As,Lr($,ue,he),p.toneMapping=rt,U.updateMultisampleRenderTarget(le),U.updateRenderTargetMipmap(le),p.setRenderTarget(xe)}function Lr($,ue,he){const oe=ue.isScene===!0?ue.overrideMaterial:null;for(let xe=0,rt=$.length;xe<rt;xe++){const at=$[xe],dt=at.object,pt=at.geometry,Tt=oe===null?at.material:oe,At=at.group;dt.layers.test(he.layers)&&Jt(dt,ue,he,pt,Tt,At)}}function Jt($,ue,he,oe,xe,rt){$.onBeforeRender(p,ue,he,oe,xe,rt),$.modelViewMatrix.multiplyMatrices(he.matrixWorldInverse,$.matrixWorld),$.normalMatrix.getNormalMatrix($.modelViewMatrix),xe.onBeforeRender(p,ue,he,oe,$,rt),xe.transparent===!0&&xe.side===ws&&xe.forceSinglePass===!1?(xe.side=Vr,xe.needsUpdate=!0,p.renderBufferDirect(he,ue,oe,xe,$,rt),xe.side=Rs,xe.needsUpdate=!0,p.renderBufferDirect(he,ue,oe,xe,$,rt),xe.side=ws):p.renderBufferDirect(he,ue,oe,xe,$,rt),$.onAfterRender(p,ue,he,oe,xe,rt)}function Bn($,ue,he){ue.isScene!==!0&&(ue=_e);const oe=nt.get($),xe=f.state.lights,rt=f.state.shadowsArray,at=xe.state.version,dt=Ae.getParameters($,xe.state,rt,ue,he),pt=Ae.getProgramCacheKey(dt);let Tt=oe.programs;oe.environment=$.isMeshStandardMaterial?ue.environment:null,oe.fog=ue.fog,oe.envMap=($.isMeshStandardMaterial?ae:j).get($.envMap||oe.environment),Tt===void 0&&($.addEventListener("dispose",ot),Tt=new Map,oe.programs=Tt);let At=Tt.get(pt);if(At!==void 0){if(oe.currentProgram===At&&oe.lightsStateVersion===at)return Jr($,dt),At}else dt.uniforms=Ae.getUniforms($),$.onBuild(he,dt,p),$.onBeforeCompile(dt,p),At=Ae.acquireProgram(dt,pt),Tt.set(pt,At),oe.uniforms=dt.uniforms;const Et=oe.uniforms;(!$.isShaderMaterial&&!$.isRawShaderMaterial||$.clipping===!0)&&(Et.clippingPlanes=L.uniform),Jr($,dt),oe.needsLights=Si($),oe.lightsStateVersion=at,oe.needsLights&&(Et.ambientLightColor.value=xe.state.ambient,Et.lightProbe.value=xe.state.probe,Et.directionalLights.value=xe.state.directional,Et.directionalLightShadows.value=xe.state.directionalShadow,Et.spotLights.value=xe.state.spot,Et.spotLightShadows.value=xe.state.spotShadow,Et.rectAreaLights.value=xe.state.rectArea,Et.ltc_1.value=xe.state.rectAreaLTC1,Et.ltc_2.value=xe.state.rectAreaLTC2,Et.pointLights.value=xe.state.point,Et.pointLightShadows.value=xe.state.pointShadow,Et.hemisphereLights.value=xe.state.hemi,Et.directionalShadowMap.value=xe.state.directionalShadowMap,Et.directionalShadowMatrix.value=xe.state.directionalShadowMatrix,Et.spotShadowMap.value=xe.state.spotShadowMap,Et.spotLightMatrix.value=xe.state.spotLightMatrix,Et.spotLightMap.value=xe.state.spotLightMap,Et.pointShadowMap.value=xe.state.pointShadowMap,Et.pointShadowMatrix.value=xe.state.pointShadowMatrix);const cn=At.getUniforms(),qn=Ch.seqWithValue(cn.seq,Et);return oe.currentProgram=At,oe.uniformsList=qn,At}function Jr($,ue){const he=nt.get($);he.outputEncoding=ue.outputEncoding,he.instancing=ue.instancing,he.skinning=ue.skinning,he.morphTargets=ue.morphTargets,he.morphNormals=ue.morphNormals,he.morphColors=ue.morphColors,he.morphTargetsCount=ue.morphTargetsCount,he.numClippingPlanes=ue.numClippingPlanes,he.numIntersection=ue.numClipIntersection,he.vertexAlphas=ue.vertexAlphas,he.vertexTangents=ue.vertexTangents,he.toneMapping=ue.toneMapping}function Hs($,ue,he,oe,xe){ue.isScene!==!0&&(ue=_e),U.resetTextureUnits();const rt=ue.fog,at=oe.isMeshStandardMaterial?ue.environment:null,dt=b===null?p.outputEncoding:b.isXRRenderTarget===!0?b.texture.encoding:ba,pt=(oe.isMeshStandardMaterial?ae:j).get(oe.envMap||at),Tt=oe.vertexColors===!0&&!!he.attributes.color&&he.attributes.color.itemSize===4,At=!!oe.normalMap&&!!he.attributes.tangent,Et=!!he.morphAttributes.position,cn=!!he.morphAttributes.normal,qn=!!he.morphAttributes.color,bn=oe.toneMapped?p.toneMapping:As,Ln=he.morphAttributes.position||he.morphAttributes.normal||he.morphAttributes.color,en=Ln!==void 0?Ln.length:0,Mt=nt.get(oe),Ro=f.state.lights;if(Y===!0&&(fe===!0||$!==T)){const Kn=$===T&&oe.id===x;L.setState(oe,$,Kn)}let xn=!1;oe.version===Mt.__version?(Mt.needsLights&&Mt.lightsStateVersion!==Ro.state.version||Mt.outputEncoding!==dt||xe.isInstancedMesh&&Mt.instancing===!1||!xe.isInstancedMesh&&Mt.instancing===!0||xe.isSkinnedMesh&&Mt.skinning===!1||!xe.isSkinnedMesh&&Mt.skinning===!0||Mt.envMap!==pt||oe.fog===!0&&Mt.fog!==rt||Mt.numClippingPlanes!==void 0&&(Mt.numClippingPlanes!==L.numPlanes||Mt.numIntersection!==L.numIntersection)||Mt.vertexAlphas!==Tt||Mt.vertexTangents!==At||Mt.morphTargets!==Et||Mt.morphNormals!==cn||Mt.morphColors!==qn||Mt.toneMapping!==bn||He.isWebGL2===!0&&Mt.morphTargetsCount!==en)&&(xn=!0):(xn=!0,Mt.__version=oe.version);let Ti=Mt.currentProgram;xn===!0&&(Ti=Bn(oe,ue,xe));let Dr=!1,js=!1,qs=!1;const tn=Ti.getUniforms(),ei=Mt.uniforms;if(We.useProgram(Ti.program)&&(Dr=!0,js=!0,qs=!0),oe.id!==x&&(x=oe.id,js=!0),Dr||T!==$){if(tn.setValue(ne,"projectionMatrix",$.projectionMatrix),He.logarithmicDepthBuffer&&tn.setValue(ne,"logDepthBufFC",2/(Math.log($.far+1)/Math.LN2)),T!==$&&(T=$,js=!0,qs=!0),oe.isShaderMaterial||oe.isMeshPhongMaterial||oe.isMeshToonMaterial||oe.isMeshStandardMaterial||oe.envMap){const Kn=tn.map.cameraPosition;Kn!==void 0&&Kn.setValue(ne,ee.setFromMatrixPosition($.matrixWorld))}(oe.isMeshPhongMaterial||oe.isMeshToonMaterial||oe.isMeshLambertMaterial||oe.isMeshBasicMaterial||oe.isMeshStandardMaterial||oe.isShaderMaterial)&&tn.setValue(ne,"isOrthographic",$.isOrthographicCamera===!0),(oe.isMeshPhongMaterial||oe.isMeshToonMaterial||oe.isMeshLambertMaterial||oe.isMeshBasicMaterial||oe.isMeshStandardMaterial||oe.isShaderMaterial||oe.isShadowMaterial||xe.isSkinnedMesh)&&tn.setValue(ne,"viewMatrix",$.matrixWorldInverse)}if(xe.isSkinnedMesh){tn.setOptional(ne,xe,"bindMatrix"),tn.setOptional(ne,xe,"bindMatrixInverse");const Kn=xe.skeleton;Kn&&(He.floatVertexTextures?(Kn.boneTexture===null&&Kn.computeBoneTexture(),tn.setValue(ne,"boneTexture",Kn.boneTexture,U),tn.setValue(ne,"boneTextureSize",Kn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const pu=he.morphAttributes;if((pu.position!==void 0||pu.normal!==void 0||pu.color!==void 0&&He.isWebGL2===!0)&&pe.update(xe,he,Ti),(js||Mt.receiveShadow!==xe.receiveShadow)&&(Mt.receiveShadow=xe.receiveShadow,tn.setValue(ne,"receiveShadow",xe.receiveShadow)),oe.isMeshGouraudMaterial&&oe.envMap!==null&&(ei.envMap.value=pt,ei.flipEnvMap.value=pt.isCubeTexture&&pt.isRenderTargetTexture===!1?-1:1),js&&(tn.setValue(ne,"toneMappingExposure",p.toneMappingExposure),Mt.needsLights&&nd(ei,qs),rt&&oe.fog===!0&&we.refreshFogUniforms(ei,rt),we.refreshMaterialUniforms(ei,oe,F,R,le),Ch.upload(ne,Mt.uniformsList,ei,U)),oe.isShaderMaterial&&oe.uniformsNeedUpdate===!0&&(Ch.upload(ne,Mt.uniformsList,ei,U),oe.uniformsNeedUpdate=!1),oe.isSpriteMaterial&&tn.setValue(ne,"center",xe.center),tn.setValue(ne,"modelViewMatrix",xe.modelViewMatrix),tn.setValue(ne,"normalMatrix",xe.normalMatrix),tn.setValue(ne,"modelMatrix",xe.matrixWorld),oe.isShaderMaterial||oe.isRawShaderMaterial){const Kn=oe.uniformsGroups;for(let Po=0,rd=Kn.length;Po<rd;Po++)if(He.isWebGL2){const $c=Kn[Po];se.update($c,Ti),se.bind($c,Ti)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Ti}function nd($,ue){$.ambientLightColor.needsUpdate=ue,$.lightProbe.needsUpdate=ue,$.directionalLights.needsUpdate=ue,$.directionalLightShadows.needsUpdate=ue,$.pointLights.needsUpdate=ue,$.pointLightShadows.needsUpdate=ue,$.spotLights.needsUpdate=ue,$.spotLightShadows.needsUpdate=ue,$.rectAreaLights.needsUpdate=ue,$.hemisphereLights.needsUpdate=ue}function Si($){return $.isMeshLambertMaterial||$.isMeshToonMaterial||$.isMeshPhongMaterial||$.isMeshStandardMaterial||$.isShadowMaterial||$.isShaderMaterial&&$.lights===!0}this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return b},this.setRenderTargetTextures=function($,ue,he){nt.get($.texture).__webglTexture=ue,nt.get($.depthTexture).__webglTexture=he;const oe=nt.get($);oe.__hasExternalTextures=!0,oe.__hasExternalTextures&&(oe.__autoAllocateDepthBuffer=he===void 0,oe.__autoAllocateDepthBuffer||Ve.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),oe.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function($,ue){const he=nt.get($);he.__webglFramebuffer=ue,he.__useDefaultFramebuffer=ue===void 0},this.setRenderTarget=function($,ue=0,he=0){b=$,_=ue,v=he;let oe=!0,xe=null,rt=!1,at=!1;if($){const pt=nt.get($);pt.__useDefaultFramebuffer!==void 0?(We.bindFramebuffer(36160,null),oe=!1):pt.__webglFramebuffer===void 0?U.setupRenderTarget($):pt.__hasExternalTextures&&U.rebindTextures($,nt.get($.texture).__webglTexture,nt.get($.depthTexture).__webglTexture);const Tt=$.texture;(Tt.isData3DTexture||Tt.isDataArrayTexture||Tt.isCompressedArrayTexture)&&(at=!0);const At=nt.get($).__webglFramebuffer;$.isWebGLCubeRenderTarget?(xe=At[ue],rt=!0):He.isWebGL2&&$.samples>0&&U.useMultisampledRTT($)===!1?xe=nt.get($).__webglMultisampledFramebuffer:xe=At,I.copy($.viewport),C.copy($.scissor),S=$.scissorTest}else I.copy(z).multiplyScalar(F).floor(),C.copy(H).multiplyScalar(F).floor(),S=Q;if(We.bindFramebuffer(36160,xe)&&He.drawBuffers&&oe&&We.drawBuffers($,xe),We.viewport(I),We.scissor(C),We.setScissorTest(S),rt){const pt=nt.get($.texture);ne.framebufferTexture2D(36160,36064,34069+ue,pt.__webglTexture,he)}else if(at){const pt=nt.get($.texture),Tt=ue||0;ne.framebufferTextureLayer(36160,36064,pt.__webglTexture,he||0,Tt)}x=-1},this.readRenderTargetPixels=function($,ue,he,oe,xe,rt,at){if(!($&&$.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let dt=nt.get($).__webglFramebuffer;if($.isWebGLCubeRenderTarget&&at!==void 0&&(dt=dt[at]),dt){We.bindFramebuffer(36160,dt);try{const pt=$.texture,Tt=pt.format,At=pt.type;if(Tt!==fi&&Pe.convert(Tt)!==ne.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Et=At===ac&&(Ve.has("EXT_color_buffer_half_float")||He.isWebGL2&&Ve.has("EXT_color_buffer_float"));if(At!==_a&&Pe.convert(At)!==ne.getParameter(35738)&&!(At===io&&(He.isWebGL2||Ve.has("OES_texture_float")||Ve.has("WEBGL_color_buffer_float")))&&!Et){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ue>=0&&ue<=$.width-oe&&he>=0&&he<=$.height-xe&&ne.readPixels(ue,he,oe,xe,Pe.convert(Tt),Pe.convert(At),rt)}finally{const pt=b!==null?nt.get(b).__webglFramebuffer:null;We.bindFramebuffer(36160,pt)}}},this.copyFramebufferToTexture=function($,ue,he=0){const oe=Math.pow(2,-he),xe=Math.floor(ue.image.width*oe),rt=Math.floor(ue.image.height*oe);U.setTexture2D(ue,0),ne.copyTexSubImage2D(3553,he,0,0,$.x,$.y,xe,rt),We.unbindTexture()},this.copyTextureToTexture=function($,ue,he,oe=0){const xe=ue.image.width,rt=ue.image.height,at=Pe.convert(he.format),dt=Pe.convert(he.type);U.setTexture2D(he,0),ne.pixelStorei(37440,he.flipY),ne.pixelStorei(37441,he.premultiplyAlpha),ne.pixelStorei(3317,he.unpackAlignment),ue.isDataTexture?ne.texSubImage2D(3553,oe,$.x,$.y,xe,rt,at,dt,ue.image.data):ue.isCompressedTexture?ne.compressedTexSubImage2D(3553,oe,$.x,$.y,ue.mipmaps[0].width,ue.mipmaps[0].height,at,ue.mipmaps[0].data):ne.texSubImage2D(3553,oe,$.x,$.y,at,dt,ue.image),oe===0&&he.generateMipmaps&&ne.generateMipmap(3553),We.unbindTexture()},this.copyTextureToTexture3D=function($,ue,he,oe,xe=0){if(p.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const rt=$.max.x-$.min.x+1,at=$.max.y-$.min.y+1,dt=$.max.z-$.min.z+1,pt=Pe.convert(oe.format),Tt=Pe.convert(oe.type);let At;if(oe.isData3DTexture)U.setTexture3D(oe,0),At=32879;else if(oe.isDataArrayTexture)U.setTexture2DArray(oe,0),At=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ne.pixelStorei(37440,oe.flipY),ne.pixelStorei(37441,oe.premultiplyAlpha),ne.pixelStorei(3317,oe.unpackAlignment);const Et=ne.getParameter(3314),cn=ne.getParameter(32878),qn=ne.getParameter(3316),bn=ne.getParameter(3315),Ln=ne.getParameter(32877),en=he.isCompressedTexture?he.mipmaps[0]:he.image;ne.pixelStorei(3314,en.width),ne.pixelStorei(32878,en.height),ne.pixelStorei(3316,$.min.x),ne.pixelStorei(3315,$.min.y),ne.pixelStorei(32877,$.min.z),he.isDataTexture||he.isData3DTexture?ne.texSubImage3D(At,xe,ue.x,ue.y,ue.z,rt,at,dt,pt,Tt,en.data):he.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ne.compressedTexSubImage3D(At,xe,ue.x,ue.y,ue.z,rt,at,dt,pt,en.data)):ne.texSubImage3D(At,xe,ue.x,ue.y,ue.z,rt,at,dt,pt,Tt,en),ne.pixelStorei(3314,Et),ne.pixelStorei(32878,cn),ne.pixelStorei(3316,qn),ne.pixelStorei(3315,bn),ne.pixelStorei(32877,Ln),xe===0&&oe.generateMipmaps&&ne.generateMipmap(At),We.unbindTexture()},this.initTexture=function($){$.isCubeTexture?U.setTextureCube($,0):$.isData3DTexture?U.setTexture3D($,0):$.isDataArrayTexture||$.isCompressedArrayTexture?U.setTexture2DArray($,0):U.setTexture2D($,0),We.unbindTexture()},this.resetState=function(){_=0,v=0,b=null,We.reset(),G.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Object.defineProperties(jg.prototype,{physicallyCorrectLights:{get:function(){return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights},set:function(r){console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!r}}});class _D extends jg{}_D.prototype.isWebGL1Renderer=!0;class bD extends gn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(e){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=e}}class xD{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Xp,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Fi()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const cr=new ie;class qg{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)cr.fromBufferAttribute(this,t),cr.applyMatrix4(e),this.setXYZ(t,cr.x,cr.y,cr.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)cr.fromBufferAttribute(this,t),cr.applyNormalMatrix(e),this.setXYZ(t,cr.x,cr.y,cr.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)cr.fromBufferAttribute(this,t),cr.transformDirection(e),this.setXYZ(t,cr.x,cr.y,cr.z);return this}setX(e,t){return this.normalized&&(t=qt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Ss(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Ss(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Ss(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Ss(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array),i=qt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=qt(t,this.array),n=qt(n,this.array),i=qt(i,this.array),s=qt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new _r(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new qg(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const lb=new ie,ub=new Yt,cb=new Yt,vD=new ie,hb=new Ct;class wD extends Ur{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ct,this.bindMatrixInverse=new Ct}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Yt,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;ub.fromBufferAttribute(i.attributes.skinIndex,e),cb.fromBufferAttribute(i.attributes.skinWeight,e),lb.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=cb.getComponent(s);if(o!==0){const a=ub.getComponent(s);hb.multiplyMatrices(n.bones[a].matrixWorld,n.boneInverses[a]),t.addScaledVector(vD.copy(lb).applyMatrix4(hb),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}class Gw extends gn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class SD extends Hn{constructor(e=null,t=1,n=1,i,s,o,a,l,u=Fn,c=Fn,h,f){super(null,o,a,l,u,c,i,s,h,f),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const fb=new Ct,TD=new Ct;class Kg{constructor(e=[],t=[]){this.uuid=Fi(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Ct)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Ct;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:TD;fb.multiplyMatrices(a,t[s]),fb.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new Kg(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Mw(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new SD(t,e,e,fi,io);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const s=e.bones[n];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new Gw),this.bones.push(o),this.boneInverses.push(new Ct().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const o=t[i];e.bones.push(o.uuid);const a=n[i];e.boneInverses.push(a.toArray())}return e}}class db extends _r{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const pb=new Ct,mb=new Ct,ph=[],ED=new Ct,Mu=new Ur;class MD extends Ur{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new db(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1;for(let i=0;i<n;i++)this.setMatrixAt(i,ED)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(Mu.geometry=this.geometry,Mu.material=this.material,Mu.material!==void 0)for(let s=0;s<i;s++){this.getMatrixAt(s,pb),mb.multiplyMatrices(n,pb),Mu.matrixWorld=mb,Mu.raycast(e,ph);for(let o=0,a=ph.length;o<a;o++){const l=ph[o];l.instanceId=s,l.object=this,t.push(l)}ph.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new db(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class Rf extends Qi{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new gt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const gb=new ie,yb=new ie,_b=new Ct,Yd=new Ug,mh=new iu;class Xg extends gn{constructor(e=new Kr,t=new Rf){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,s=t.count;i<s;i++)gb.fromBufferAttribute(t,i-1),yb.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=gb.distanceTo(yb);e.setAttribute("lineDistance",new sr(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),mh.copy(n.boundingSphere),mh.applyMatrix4(i),mh.radius+=s,e.ray.intersectsSphere(mh)===!1)return;_b.copy(i).invert(),Yd.copy(e.ray).applyMatrix4(_b);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=new ie,c=new ie,h=new ie,f=new ie,d=this.isLineSegments?2:1,g=n.index,m=n.attributes.position;if(g!==null){const _=Math.max(0,o.start),v=Math.min(g.count,o.start+o.count);for(let b=_,x=v-1;b<x;b+=d){const T=g.getX(b),I=g.getX(b+1);if(u.fromBufferAttribute(m,T),c.fromBufferAttribute(m,I),Yd.distanceSqToSegment(u,c,f,h)>l)continue;f.applyMatrix4(this.matrixWorld);const S=e.ray.origin.distanceTo(f);S<e.near||S>e.far||t.push({distance:S,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}else{const _=Math.max(0,o.start),v=Math.min(m.count,o.start+o.count);for(let b=_,x=v-1;b<x;b+=d){if(u.fromBufferAttribute(m,b),c.fromBufferAttribute(m,b+1),Yd.distanceSqToSegment(u,c,f,h)>l)continue;f.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(f);I<e.near||I>e.far||t.push({distance:I,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const bb=new ie,xb=new ie;class Yg extends Xg{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,s=t.count;i<s;i+=2)bb.fromBufferAttribute(t,i),xb.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+bb.distanceTo(xb);e.setAttribute("lineDistance",new sr(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class AD extends Xg{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class Hw extends Qi{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new gt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const vb=new Ct,Jp=new Ug,gh=new iu,yh=new ie;class ID extends gn{constructor(e=new Kr,t=new Hw){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),gh.copy(n.boundingSphere),gh.applyMatrix4(i),gh.radius+=s,e.ray.intersectsSphere(gh)===!1)return;vb.copy(i).invert(),Jp.copy(e.ray).applyMatrix4(vb);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=n.index,h=n.attributes.position;if(u!==null){const f=Math.max(0,o.start),d=Math.min(u.count,o.start+o.count);for(let g=f,p=d;g<p;g++){const m=u.getX(g);yh.fromBufferAttribute(h,m),wb(yh,m,l,i,e,t,this)}}else{const f=Math.max(0,o.start),d=Math.min(h.count,o.start+o.count);for(let g=f,p=d;g<p;g++)yh.fromBufferAttribute(h,g),wb(yh,g,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function wb(r,e,t,n,i,s,o){const a=Jp.distanceSqToPoint(r);if(a<t){const l=new ie;Jp.closestPointToPoint(r,l),l.applyMatrix4(n);const u=i.ray.origin.distanceTo(l);if(u<i.near||u>i.far)return;s.push({distance:u,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class Zg extends Kr{constructor(e=1,t=32,n=16,i=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(o+a,Math.PI);let u=0;const c=[],h=new ie,f=new ie,d=[],g=[],p=[],m=[];for(let _=0;_<=n;_++){const v=[],b=_/n;let x=0;_==0&&o==0?x=.5/t:_==n&&l==Math.PI&&(x=-.5/t);for(let T=0;T<=t;T++){const I=T/t;h.x=-e*Math.cos(i+I*s)*Math.sin(o+b*a),h.y=e*Math.cos(o+b*a),h.z=e*Math.sin(i+I*s)*Math.sin(o+b*a),g.push(h.x,h.y,h.z),f.copy(h).normalize(),p.push(f.x,f.y,f.z),m.push(I+x,1-b),v.push(u++)}c.push(v)}for(let _=0;_<n;_++)for(let v=0;v<t;v++){const b=c[_][v+1],x=c[_][v],T=c[_+1][v],I=c[_+1][v+1];(_!==0||o>0)&&d.push(b,x,I),(_!==n-1||l<Math.PI)&&d.push(x,T,I)}this.setIndex(d),this.setAttribute("position",new sr(g,3)),this.setAttribute("normal",new sr(p,3)),this.setAttribute("uv",new sr(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Zg(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Pf extends Qi{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new gt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Tw,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Pa extends Pf{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new mt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Jn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new gt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new gt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new gt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function eo(r,e,t){return jw(r)?new r.constructor(r.subarray(e,t!==void 0?t:r.length)):r.slice(e,t)}function _h(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)}function jw(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function CD(r){function e(i,s){return r[i]-r[s]}const t=r.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function Sb(r,e,t){const n=r.length,i=new r.constructor(n);for(let s=0,o=0;o!==n;++s){const a=t[s]*e;for(let l=0;l!==e;++l)i[o++]=r[a+l]}return i}function qw(r,e,t,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let o=s[n];if(o!==void 0)if(Array.isArray(o))do o=s[n],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=r[i++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[n],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=r[i++];while(s!==void 0);else do o=s[n],o!==void 0&&(e.push(s.time),t.push(o)),s=r[i++];while(s!==void 0)}class Rc{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],s=t[n-1];e:{t:{let o;n:{r:if(!(e<i)){for(let a=n+2;;){if(i===void 0){if(e<s)break r;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===a)break;if(s=i,i=t[++n],e<i)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(n=2,s=a);for(let l=n-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===l)break;if(i=s,s=t[--n-1],e>=s)break t}o=n,n=0;break n}break e}for(;n<o;){const a=n+o>>>1;e<t[a]?o=a:n=a+1}if(i=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i;for(let o=0;o!==i;++o)t[o]=n[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class kD extends Rc{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:T_,endingEnd:T_}}intervalChanged_(e,t,n){const i=this.parameterPositions;let s=e-2,o=e+1,a=i[s],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case E_:s=e,a=2*t-n;break;case M_:s=i.length-2,a=t+i[s]-i[s+1];break;default:s=e,a=n}if(l===void 0)switch(this.getSettings_().endingEnd){case E_:o=e,l=2*n-t;break;case M_:o=1,l=n+i[1]-i[0];break;default:o=e-1,l=t}const u=(n-t)*.5,c=this.valueSize;this._weightPrev=u/(t-a),this._weightNext=u/(l-n),this._offsetPrev=s*c,this._offsetNext=o*c}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=this._offsetPrev,h=this._offsetNext,f=this._weightPrev,d=this._weightNext,g=(n-t)/(i-t),p=g*g,m=p*g,_=-f*m+2*f*p-f*g,v=(1+f)*m+(-1.5-2*f)*p+(-.5+f)*g+1,b=(-1-d)*m+(1.5+d)*p+.5*g,x=d*m-d*p;for(let T=0;T!==a;++T)s[T]=_*o[c+T]+v*o[u+T]+b*o[l+T]+x*o[h+T];return s}}class ND extends Rc{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=(n-t)/(i-t),h=1-c;for(let f=0;f!==a;++f)s[f]=o[u+f]*h+o[l+f]*c;return s}}class RD extends Rc{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class os{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=_h(t,this.TimeBufferType),this.values=_h(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:_h(e.times,Array),values:_h(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new RD(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new ND(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new kD(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case lc:t=this.InterpolantFactoryMethodDiscrete;break;case Ol:t=this.InterpolantFactoryMethodLinear;break;case Ed:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return lc;case this.InterpolantFactoryMethodLinear:return Ol;case this.InterpolantFactoryMethodSmooth:return Ed}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let s=0,o=i-1;for(;s!==i&&n[s]<e;)++s;for(;o!==-1&&n[o]>t;)--o;if(++o,s!==0||o!==i){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=eo(n,s,o),this.values=eo(this.values,s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=n[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&jw(i))for(let a=0,l=i.length;a!==l;++a){const u=i[a];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,u),e=!1;break}}return e}optimize(){const e=eo(this.times),t=eo(this.values),n=this.getValueSize(),i=this.getInterpolation()===Ed,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const u=e[a],c=e[a+1];if(u!==c&&(a!==1||u!==e[0]))if(i)l=!0;else{const h=a*n,f=h-n,d=h+n;for(let g=0;g!==n;++g){const p=t[h+g];if(p!==t[f+g]||p!==t[d+g]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*n,f=o*n;for(let d=0;d!==n;++d)t[f+d]=t[h+d]}++o}}if(s>0){e[o]=e[s];for(let a=s*n,l=o*n,u=0;u!==n;++u)t[l+u]=t[a+u];++o}return o!==e.length?(this.times=eo(e,0,o),this.values=eo(t,0,o*n)):(this.times=e,this.values=t),this}clone(){const e=eo(this.times,0),t=eo(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}os.prototype.TimeBufferType=Float32Array;os.prototype.ValueBufferType=Float32Array;os.prototype.DefaultInterpolation=Ol;class ou extends os{}ou.prototype.ValueTypeName="bool";ou.prototype.ValueBufferType=Array;ou.prototype.DefaultInterpolation=lc;ou.prototype.InterpolantFactoryMethodLinear=void 0;ou.prototype.InterpolantFactoryMethodSmooth=void 0;class Kw extends os{}Kw.prototype.ValueTypeName="color";class fc extends os{}fc.prototype.ValueTypeName="number";class PD extends Rc{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(n-t)/(i-t);let u=e*a;for(let c=u+a;u!==c;u+=4)rs.slerpFlat(s,0,o,u-a,o,u,l);return s}}class wa extends os{InterpolantFactoryMethodLinear(e){return new PD(this.times,this.values,this.getValueSize(),e)}}wa.prototype.ValueTypeName="quaternion";wa.prototype.DefaultInterpolation=Ol;wa.prototype.InterpolantFactoryMethodSmooth=void 0;class au extends os{}au.prototype.ValueTypeName="string";au.prototype.ValueBufferType=Array;au.prototype.DefaultInterpolation=lc;au.prototype.InterpolantFactoryMethodLinear=void 0;au.prototype.InterpolantFactoryMethodSmooth=void 0;class dc extends os{}dc.prototype.ValueTypeName="vector";class LD{constructor(e,t=-1,n,i=KC){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Fi(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let o=0,a=n.length;o!==a;++o)t.push(OD(n[o]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=n.length;s!==o;++s)t.push(os.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const s=t.length,o=[];for(let a=0;a<s;a++){let l=[],u=[];l.push((a+s-1)%s,a,(a+1)%s),u.push(0,1,0);const c=CD(l);l=Sb(l,1,c),u=Sb(u,1,c),!i&&l[0]===0&&(l.push(s),u.push(u[0])),o.push(new fc(".morphTargetInfluences["+t[a].name+"]",l,u).scale(1/n))}return new this(e,-1,o)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const u=e[a],c=u.name.match(s);if(c&&c.length>1){const h=c[1];let f=i[h];f||(i[h]=f=[]),f.push(u)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,n));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,f,d,g,p){if(d.length!==0){const m=[],_=[];qw(d,m,_,g),m.length!==0&&p.push(new h(f,m,_))}},i=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let h=0;h<u.length;h++){const f=u[h].keys;if(!(!f||f.length===0))if(f[0].morphTargets){const d={};let g;for(g=0;g<f.length;g++)if(f[g].morphTargets)for(let p=0;p<f[g].morphTargets.length;p++)d[f[g].morphTargets[p]]=-1;for(const p in d){const m=[],_=[];for(let v=0;v!==f[g].morphTargets.length;++v){const b=f[g];m.push(b.time),_.push(b.morphTarget===p?1:0)}i.push(new fc(".morphTargetInfluence["+p+"]",m,_))}l=d.length*o}else{const d=".bones["+t[h].name+"]";n(dc,d+".position",f,"pos",i),n(wa,d+".quaternion",f,"rot",i),n(dc,d+".scale",f,"scl",i)}}return i.length===0?null:new this(s,l,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function DD(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return fc;case"vector":case"vector2":case"vector3":case"vector4":return dc;case"color":return Kw;case"quaternion":return wa;case"bool":case"boolean":return ou;case"string":return au}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function OD(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=DD(r.type);if(r.times===void 0){const t=[],n=[];qw(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const $l={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class FD{constructor(e,t,n){const i=this;let s=!1,o=0,a=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){a++,s===!1&&i.onStart!==void 0&&i.onStart(c,o,a),s=!0},this.itemEnd=function(c){o++,i.onProgress!==void 0&&i.onProgress(c,o,a),o===a&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,h){return u.push(c,h),this},this.removeHandler=function(c){const h=u.indexOf(c);return h!==-1&&u.splice(h,2),this},this.getHandler=function(c){for(let h=0,f=u.length;h<f;h+=2){const d=u[h],g=u[h+1];if(d.global&&(d.lastIndex=0),d.test(c))return g}return null}}}const $D=new FD;class Pc{constructor(e){this.manager=e!==void 0?e:$D,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,s){n.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const ds={};class zD extends Error{constructor(e,t){super(e),this.response=t}}class Xw extends Pc{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=$l.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(ds[e]!==void 0){ds[e].push({onLoad:t,onProgress:n,onError:i});return}ds[e]=[],ds[e].push({onLoad:t,onProgress:n,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=ds[e],h=u.body.getReader(),f=u.headers.get("Content-Length")||u.headers.get("X-File-Size"),d=f?parseInt(f):0,g=d!==0;let p=0;const m=new ReadableStream({start(_){v();function v(){h.read().then(({done:b,value:x})=>{if(b)_.close();else{p+=x.byteLength;const T=new ProgressEvent("progress",{lengthComputable:g,loaded:p,total:d});for(let I=0,C=c.length;I<C;I++){const S=c[I];S.onProgress&&S.onProgress(T)}_.enqueue(x),v()}})}}});return new Response(m)}else throw new zD(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,a));case"json":return u.json();default:if(a===void 0)return u.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),f=h&&h[1]?h[1].toLowerCase():void 0,d=new TextDecoder(f);return u.arrayBuffer().then(g=>d.decode(g))}}}).then(u=>{$l.add(e,u);const c=ds[e];delete ds[e];for(let h=0,f=c.length;h<f;h++){const d=c[h];d.onLoad&&d.onLoad(u)}}).catch(u=>{const c=ds[e];if(c===void 0)throw this.manager.itemError(e),u;delete ds[e];for(let h=0,f=c.length;h<f;h++){const d=c[h];d.onError&&d.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class BD extends Pc{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=$l.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=hc("img");function l(){c(),$l.add(e,this),t&&t(this),s.manager.itemEnd(e)}function u(h){c(),i&&i(h),s.manager.itemError(e),s.manager.itemEnd(e)}function c(){a.removeEventListener("load",l,!1),a.removeEventListener("error",u,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class UD extends Pc{constructor(e){super(e)}load(e,t,n,i){const s=new Hn,o=new BD(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},n,i),s}}class Lf extends gn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new gt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}const Zd=new Ct,Tb=new ie,Eb=new ie;class Qg{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new mt(512,512),this.map=null,this.mapPass=null,this.matrix=new Ct,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Vg,this._frameExtents=new mt(1,1),this._viewportCount=1,this._viewports=[new Yt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;Tb.setFromMatrixPosition(e.matrixWorld),t.position.copy(Tb),Eb.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Eb),t.updateMatrixWorld(),Zd.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Zd),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Zd)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class VD extends Qg{constructor(){super(new dr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=cc*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class WD extends Lf{constructor(e,t,n=0,i=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(gn.DEFAULT_UP),this.updateMatrix(),this.target=new gn,this.distance=n,this.angle=i,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new VD}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const Mb=new Ct,Au=new ie,Qd=new ie;class GD extends Qg{constructor(){super(new dr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new mt(4,2),this._viewportCount=6,this._viewports=[new Yt(2,1,1,1),new Yt(0,1,1,1),new Yt(3,1,1,1),new Yt(1,1,1,1),new Yt(3,0,1,1),new Yt(1,0,1,1)],this._cubeDirections=[new ie(1,0,0),new ie(-1,0,0),new ie(0,0,1),new ie(0,0,-1),new ie(0,1,0),new ie(0,-1,0)],this._cubeUps=[new ie(0,1,0),new ie(0,1,0),new ie(0,1,0),new ie(0,1,0),new ie(0,0,1),new ie(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Au.setFromMatrixPosition(e.matrixWorld),n.position.copy(Au),Qd.copy(n.position),Qd.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(Qd),n.updateMatrixWorld(),i.makeTranslation(-Au.x,-Au.y,-Au.z),Mb.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Mb)}}class Yw extends Lf{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new GD}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class HD extends Qg{constructor(){super(new Gg(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class jD extends Lf{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(gn.DEFAULT_UP),this.updateMatrix(),this.target=new gn,this.shadow=new HD}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class qD extends Lf{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class em{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class KD extends Pc{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=$l.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){$l.add(e,l),t&&t(l),s.manager.itemEnd(e)}).catch(function(l){i&&i(l),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}class XD{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Ab(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Ab();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Ab(){return(typeof performance>"u"?Date:performance).now()}const Jg="\\[\\]\\.:\\/",YD=new RegExp("["+Jg+"]","g"),ey="[^"+Jg+"]",ZD="[^"+Jg.replace("\\.","")+"]",QD=/((?:WC+[\/:])*)/.source.replace("WC",ey),JD=/(WCOD+)?/.source.replace("WCOD",ZD),eO=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",ey),tO=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",ey),nO=new RegExp("^"+QD+JD+eO+tO+"$"),rO=["material","materials","bones","map"];class iO{constructor(e,t,n){const i=n||Ut.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class Ut{constructor(e,t,n){this.path=t,this.parsedPath=n||Ut.parseTrackName(t),this.node=Ut.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new Ut.Composite(e,t,n):new Ut(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(YD,"")}static parseTrackName(e){const t=nO.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);rO.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const l=n(a.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=Ut.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let u=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const o=e[i];if(o===void 0){const u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ut.Composite=iO;Ut.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ut.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ut.prototype.GetterByBindingType=[Ut.prototype._getValue_direct,Ut.prototype._getValue_array,Ut.prototype._getValue_arrayElement,Ut.prototype._getValue_toArray];Ut.prototype.SetterByBindingTypeAndVersioning=[[Ut.prototype._setValue_direct,Ut.prototype._setValue_direct_setNeedsUpdate,Ut.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ut.prototype._setValue_array,Ut.prototype._setValue_array_setNeedsUpdate,Ut.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ut.prototype._setValue_arrayElement,Ut.prototype._setValue_arrayElement_setNeedsUpdate,Ut.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ut.prototype._setValue_fromArray,Ut.prototype._setValue_fromArray_setNeedsUpdate,Ut.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Ib{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Jn(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class sO extends Yg{constructor(e=10,t=10,n=4473924,i=8947848){n=new gt(n),i=new gt(i);const s=t/2,o=e/t,a=e/2,l=[],u=[];for(let f=0,d=0,g=-a;f<=t;f++,g+=o){l.push(-a,0,g,a,0,g),l.push(g,0,-a,g,0,a);const p=f===s?n:i;p.toArray(u,d),d+=3,p.toArray(u,d),d+=3,p.toArray(u,d),d+=3,p.toArray(u,d),d+=3}const c=new Kr;c.setAttribute("position",new sr(l,3)),c.setAttribute("color",new sr(u,3));const h=new Rf({vertexColors:!0,toneMapped:!1});super(c,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class oO extends Yg{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Kr;i.setAttribute("position",new sr(t,3)),i.setAttribute("color",new sr(n,3));const s=new Rf({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,t,n){const i=new gt,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(t),i.toArray(s,6),i.toArray(s,9),i.set(n),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:zg}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=zg);function ms(r){if(r===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return r}function Zw(r,e){r.prototype=Object.create(e.prototype),r.prototype.constructor=r,r.__proto__=e}/*!
 * GSAP 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Wr={autoSleep:120,force3D:"auto",nullTargetWarn:1,units:{lineHeight:""}},zl={duration:.5,overwrite:!1,delay:0},ty,or,Tn,di=1e8,Xt=1/di,tm=Math.PI*2,aO=tm/4,lO=0,Qw=Math.sqrt,uO=Math.cos,cO=Math.sin,$n=function(e){return typeof e=="string"},_n=function(e){return typeof e=="function"},Ps=function(e){return typeof e=="number"},ny=function(e){return typeof e>"u"},is=function(e){return typeof e=="object"},Ir=function(e){return e!==!1},Jw=function(){return typeof window<"u"},bh=function(e){return _n(e)||$n(e)},e1=typeof ArrayBuffer=="function"&&ArrayBuffer.isView||function(){},ar=Array.isArray,nm=/(?:-?\.?\d|\.)+/gi,t1=/[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,pl=/[-+=.]*\d+[.e-]*\d*[a-z%]*/g,Jd=/[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,n1=/[+-]=-?[.\d]+/,r1=/[^,'"\[\]\s]+/gi,hO=/^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,pn,ai,rm,ry,Hr={},Gh={},i1,s1=function(e){return(Gh=Sa(e,Hr))&&jr},iy=function(e,t){return console.warn("Invalid property",e,"set to",t,"Missing plugin? gsap.registerPlugin()")},Hh=function(e,t){return!t&&console.warn(e)},o1=function(e,t){return e&&(Hr[e]=t)&&Gh&&(Gh[e]=t)||Hr},pc=function(){return 0},fO={suppressEvents:!0,isStart:!0,kill:!1},kh={suppressEvents:!0,kill:!1},dO={suppressEvents:!0},sy={},go=[],im={},a1,zr={},ep={},Cb=30,Nh=[],oy="",ay=function(e){var t=e[0],n,i;if(is(t)||_n(t)||(e=[e]),!(n=(t._gsap||{}).harness)){for(i=Nh.length;i--&&!Nh[i].targetTest(t););n=Nh[i]}for(i=e.length;i--;)e[i]&&(e[i]._gsap||(e[i]._gsap=new C1(e[i],n)))||e.splice(i,1);return e},ha=function(e){return e._gsap||ay(pi(e))[0]._gsap},l1=function(e,t,n){return(n=e[t])&&_n(n)?e[t]():ny(n)&&e.getAttribute&&e.getAttribute(t)||n},Cr=function(e,t){return(e=e.split(",")).forEach(t)||e},vn=function(e){return Math.round(e*1e5)/1e5||0},Gn=function(e){return Math.round(e*1e7)/1e7||0},Sl=function(e,t){var n=t.charAt(0),i=parseFloat(t.substr(2));return e=parseFloat(e),n==="+"?e+i:n==="-"?e-i:n==="*"?e*i:e/i},pO=function(e,t){for(var n=t.length,i=0;e.indexOf(t[i])<0&&++i<n;);return i<n},jh=function(){var e=go.length,t=go.slice(0),n,i;for(im={},go.length=0,n=0;n<e;n++)i=t[n],i&&i._lazy&&(i.render(i._lazy[0],i._lazy[1],!0)._lazy=0)},u1=function(e,t,n,i){go.length&&!or&&jh(),e.render(t,n,i||or&&t<0&&(e._initted||e._startAt)),go.length&&!or&&jh()},c1=function(e){var t=parseFloat(e);return(t||t===0)&&(e+"").match(r1).length<2?t:$n(e)?e.trim():e},h1=function(e){return e},wi=function(e,t){for(var n in t)n in e||(e[n]=t[n]);return e},mO=function(e){return function(t,n){for(var i in n)i in t||i==="duration"&&e||i==="ease"||(t[i]=n[i])}},Sa=function(e,t){for(var n in t)e[n]=t[n];return e},kb=function r(e,t){for(var n in t)n!=="__proto__"&&n!=="constructor"&&n!=="prototype"&&(e[n]=is(t[n])?r(e[n]||(e[n]={}),t[n]):t[n]);return e},qh=function(e,t){var n={},i;for(i in e)i in t||(n[i]=e[i]);return n},Yu=function(e){var t=e.parent||pn,n=e.keyframes?mO(ar(e.keyframes)):wi;if(Ir(e.inherit))for(;t;)n(e,t.vars.defaults),t=t.parent||t._dp;return e},gO=function(e,t){for(var n=e.length,i=n===t.length;i&&n--&&e[n]===t[n];);return n<0},f1=function(e,t,n,i,s){n===void 0&&(n="_first"),i===void 0&&(i="_last");var o=e[i],a;if(s)for(a=t[s];o&&o[s]>a;)o=o._prev;return o?(t._next=o._next,o._next=t):(t._next=e[n],e[n]=t),t._next?t._next._prev=t:e[i]=t,t._prev=o,t.parent=t._dp=e,t},Df=function(e,t,n,i){n===void 0&&(n="_first"),i===void 0&&(i="_last");var s=t._prev,o=t._next;s?s._next=o:e[n]===t&&(e[n]=o),o?o._prev=s:e[i]===t&&(e[i]=s),t._next=t._prev=t.parent=null},So=function(e,t){e.parent&&(!t||e.parent.autoRemoveChildren)&&e.parent.remove(e),e._act=0},fa=function(e,t){if(e&&(!t||t._end>e._dur||t._start<0))for(var n=e;n;)n._dirty=1,n=n.parent;return e},yO=function(e){for(var t=e.parent;t&&t.parent;)t._dirty=1,t.totalDuration(),t=t.parent;return e},sm=function(e,t,n,i){return e._startAt&&(or?e._startAt.revert(kh):e.vars.immediateRender&&!e.vars.autoRevert||e._startAt.render(t,!0,i))},_O=function r(e){return!e||e._ts&&r(e.parent)},Nb=function(e){return e._repeat?Bl(e._tTime,e=e.duration()+e._rDelay)*e:0},Bl=function(e,t){var n=Math.floor(e/=t);return e&&n===e?n-1:n},Kh=function(e,t){return(e-t._start)*t._ts+(t._ts>=0?0:t._dirty?t.totalDuration():t._tDur)},Of=function(e){return e._end=Gn(e._start+(e._tDur/Math.abs(e._ts||e._rts||Xt)||0))},Ff=function(e,t){var n=e._dp;return n&&n.smoothChildTiming&&e._ts&&(e._start=Gn(n._time-(e._ts>0?t/e._ts:((e._dirty?e.totalDuration():e._tDur)-t)/-e._ts)),Of(e),n._dirty||fa(n,e)),e},d1=function(e,t){var n;if((t._time||t._initted&&!t._dur)&&(n=Kh(e.rawTime(),t),(!t._dur||Lc(0,t.totalDuration(),n)-t._tTime>Xt)&&t.render(n,!0)),fa(e,t)._dp&&e._initted&&e._time>=e._dur&&e._ts){if(e._dur<e.duration())for(n=e;n._dp;)n.rawTime()>=0&&n.totalTime(n._tTime),n=n._dp;e._zTime=-Xt}},Yi=function(e,t,n,i){return t.parent&&So(t),t._start=Gn((Ps(n)?n:n||e!==pn?si(e,n,t):e._time)+t._delay),t._end=Gn(t._start+(t.totalDuration()/Math.abs(t.timeScale())||0)),f1(e,t,"_first","_last",e._sort?"_start":0),om(t)||(e._recent=t),i||d1(e,t),e._ts<0&&Ff(e,e._tTime),e},p1=function(e,t){return(Hr.ScrollTrigger||iy("scrollTrigger",t))&&Hr.ScrollTrigger.create(t,e)},m1=function(e,t,n,i,s){if(uy(e,t,s),!e._initted)return 1;if(!n&&e._pt&&!or&&(e._dur&&e.vars.lazy!==!1||!e._dur&&e.vars.lazy)&&a1!==Br.frame)return go.push(e),e._lazy=[s,i],1},bO=function r(e){var t=e.parent;return t&&t._ts&&t._initted&&!t._lock&&(t.rawTime()<0||r(t))},om=function(e){var t=e.data;return t==="isFromStart"||t==="isStart"},xO=function(e,t,n,i){var s=e.ratio,o=t<0||!t&&(!e._start&&bO(e)&&!(!e._initted&&om(e))||(e._ts<0||e._dp._ts<0)&&!om(e))?0:1,a=e._rDelay,l=0,u,c,h;if(a&&e._repeat&&(l=Lc(0,e._tDur,t),c=Bl(l,a),e._yoyo&&c&1&&(o=1-o),c!==Bl(e._tTime,a)&&(s=1-o,e.vars.repeatRefresh&&e._initted&&e.invalidate())),o!==s||or||i||e._zTime===Xt||!t&&e._zTime){if(!e._initted&&m1(e,t,i,n,l))return;for(h=e._zTime,e._zTime=t||(n?Xt:0),n||(n=t&&!h),e.ratio=o,e._from&&(o=1-o),e._time=0,e._tTime=l,u=e._pt;u;)u.r(o,u.d),u=u._next;t<0&&sm(e,t,n,!0),e._onUpdate&&!n&&mi(e,"onUpdate"),l&&e._repeat&&!n&&e.parent&&mi(e,"onRepeat"),(t>=e._tDur||t<0)&&e.ratio===o&&(o&&So(e,1),!n&&!or&&(mi(e,o?"onComplete":"onReverseComplete",!0),e._prom&&e._prom()))}else e._zTime||(e._zTime=t)},vO=function(e,t,n){var i;if(n>t)for(i=e._first;i&&i._start<=n;){if(i.data==="isPause"&&i._start>t)return i;i=i._next}else for(i=e._last;i&&i._start>=n;){if(i.data==="isPause"&&i._start<t)return i;i=i._prev}},Ul=function(e,t,n,i){var s=e._repeat,o=Gn(t)||0,a=e._tTime/e._tDur;return a&&!i&&(e._time*=o/e._dur),e._dur=o,e._tDur=s?s<0?1e10:Gn(o*(s+1)+e._rDelay*s):o,a>0&&!i&&Ff(e,e._tTime=e._tDur*a),e.parent&&Of(e),n||fa(e.parent,e),e},Rb=function(e){return e instanceof Mr?fa(e):Ul(e,e._dur)},wO={_start:0,endTime:pc,totalDuration:pc},si=function r(e,t,n){var i=e.labels,s=e._recent||wO,o=e.duration()>=di?s.endTime(!1):e._dur,a,l,u;return $n(t)&&(isNaN(t)||t in i)?(l=t.charAt(0),u=t.substr(-1)==="%",a=t.indexOf("="),l==="<"||l===">"?(a>=0&&(t=t.replace(/=/,"")),(l==="<"?s._start:s.endTime(s._repeat>=0))+(parseFloat(t.substr(1))||0)*(u?(a<0?s:n).totalDuration()/100:1)):a<0?(t in i||(i[t]=o),i[t]):(l=parseFloat(t.charAt(a-1)+t.substr(a+1)),u&&n&&(l=l/100*(ar(n)?n[0]:n).totalDuration()),a>1?r(e,t.substr(0,a-1),n)+l:o+l)):t==null?o:+t},Zu=function(e,t,n){var i=Ps(t[1]),s=(i?2:1)+(e<2?0:1),o=t[s],a,l;if(i&&(o.duration=t[1]),o.parent=n,e){for(a=o,l=n;l&&!("immediateRender"in a);)a=l.vars.defaults||{},l=Ir(l.vars.inherit)&&l.parent;o.immediateRender=Ir(a.immediateRender),e<2?o.runBackwards=1:o.startAt=t[s-1]}return new In(t[0],o,t[s+1])},Io=function(e,t){return e||e===0?t(e):t},Lc=function(e,t,n){return n<e?e:n>t?t:n},nr=function(e,t){return!$n(e)||!(t=hO.exec(e))?"":t[1]},SO=function(e,t,n){return Io(n,function(i){return Lc(e,t,i)})},am=[].slice,g1=function(e,t){return e&&is(e)&&"length"in e&&(!t&&!e.length||e.length-1 in e&&is(e[0]))&&!e.nodeType&&e!==ai},TO=function(e,t,n){return n===void 0&&(n=[]),e.forEach(function(i){var s;return $n(i)&&!t||g1(i,1)?(s=n).push.apply(s,pi(i)):n.push(i)})||n},pi=function(e,t,n){return Tn&&!t&&Tn.selector?Tn.selector(e):$n(e)&&!n&&(rm||!Vl())?am.call((t||ry).querySelectorAll(e),0):ar(e)?TO(e,n):g1(e)?am.call(e,0):e?[e]:[]},lm=function(e){return e=pi(e)[0]||Hh("Invalid scope")||{},function(t){var n=e.current||e.nativeElement||e;return pi(t,n.querySelectorAll?n:n===e?Hh("Invalid scope")||ry.createElement("div"):e)}},y1=function(e){return e.sort(function(){return .5-Math.random()})},_1=function(e){if(_n(e))return e;var t=is(e)?e:{each:e},n=da(t.ease),i=t.from||0,s=parseFloat(t.base)||0,o={},a=i>0&&i<1,l=isNaN(i)||a,u=t.axis,c=i,h=i;return $n(i)?c=h={center:.5,edges:.5,end:1}[i]||0:!a&&l&&(c=i[0],h=i[1]),function(f,d,g){var p=(g||t).length,m=o[p],_,v,b,x,T,I,C,S,A;if(!m){if(A=t.grid==="auto"?0:(t.grid||[1,di])[1],!A){for(C=-di;C<(C=g[A++].getBoundingClientRect().left)&&A<p;);A--}for(m=o[p]=[],_=l?Math.min(A,p)*c-.5:i%A,v=A===di?0:l?p*h/A-.5:i/A|0,C=0,S=di,I=0;I<p;I++)b=I%A-_,x=v-(I/A|0),m[I]=T=u?Math.abs(u==="y"?x:b):Qw(b*b+x*x),T>C&&(C=T),T<S&&(S=T);i==="random"&&y1(m),m.max=C-S,m.min=S,m.v=p=(parseFloat(t.amount)||parseFloat(t.each)*(A>p?p-1:u?u==="y"?p/A:A:Math.max(A,p/A))||0)*(i==="edges"?-1:1),m.b=p<0?s-p:s,m.u=nr(t.amount||t.each)||0,n=n&&p<0?M1(n):n}return p=(m[f]-m.min)/m.max||0,Gn(m.b+(n?n(p):p)*m.v)+m.u}},um=function(e){var t=Math.pow(10,((e+"").split(".")[1]||"").length);return function(n){var i=Gn(Math.round(parseFloat(n)/e)*e*t);return(i-i%1)/t+(Ps(n)?0:nr(n))}},b1=function(e,t){var n=ar(e),i,s;return!n&&is(e)&&(i=n=e.radius||di,e.values?(e=pi(e.values),(s=!Ps(e[0]))&&(i*=i)):e=um(e.increment)),Io(t,n?_n(e)?function(o){return s=e(o),Math.abs(s-o)<=i?s:o}:function(o){for(var a=parseFloat(s?o.x:o),l=parseFloat(s?o.y:0),u=di,c=0,h=e.length,f,d;h--;)s?(f=e[h].x-a,d=e[h].y-l,f=f*f+d*d):f=Math.abs(e[h]-a),f<u&&(u=f,c=h);return c=!i||u<=i?e[c]:o,s||c===o||Ps(o)?c:c+nr(o)}:um(e))},x1=function(e,t,n,i){return Io(ar(e)?!t:n===!0?!!(n=0):!i,function(){return ar(e)?e[~~(Math.random()*e.length)]:(n=n||1e-5)&&(i=n<1?Math.pow(10,(n+"").length-2):1)&&Math.floor(Math.round((e-n/2+Math.random()*(t-e+n*.99))/n)*n*i)/i})},EO=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(i){return t.reduce(function(s,o){return o(s)},i)}},MO=function(e,t){return function(n){return e(parseFloat(n))+(t||nr(n))}},AO=function(e,t,n){return w1(e,t,0,1,n)},v1=function(e,t,n){return Io(n,function(i){return e[~~t(i)]})},IO=function r(e,t,n){var i=t-e;return ar(e)?v1(e,r(0,e.length),t):Io(n,function(s){return(i+(s-e)%i)%i+e})},CO=function r(e,t,n){var i=t-e,s=i*2;return ar(e)?v1(e,r(0,e.length-1),t):Io(n,function(o){return o=(s+(o-e)%s)%s||0,e+(o>i?s-o:o)})},mc=function(e){for(var t=0,n="",i,s,o,a;~(i=e.indexOf("random(",t));)o=e.indexOf(")",i),a=e.charAt(i+7)==="[",s=e.substr(i+7,o-i-7).match(a?r1:nm),n+=e.substr(t,i-t)+x1(a?s:+s[0],a?0:+s[1],+s[2]||1e-5),t=o+1;return n+e.substr(t,e.length-t)},w1=function(e,t,n,i,s){var o=t-e,a=i-n;return Io(s,function(l){return n+((l-e)/o*a||0)})},kO=function r(e,t,n,i){var s=isNaN(e+t)?0:function(d){return(1-d)*e+d*t};if(!s){var o=$n(e),a={},l,u,c,h,f;if(n===!0&&(i=1)&&(n=null),o)e={p:e},t={p:t};else if(ar(e)&&!ar(t)){for(c=[],h=e.length,f=h-2,u=1;u<h;u++)c.push(r(e[u-1],e[u]));h--,s=function(g){g*=h;var p=Math.min(f,~~g);return c[p](g-p)},n=t}else i||(e=Sa(ar(e)?[]:{},e));if(!c){for(l in t)ly.call(a,e,l,"get",t[l]);s=function(g){return fy(g,a)||(o?e.p:e)}}}return Io(n,s)},Pb=function(e,t,n){var i=e.labels,s=di,o,a,l;for(o in i)a=i[o]-t,a<0==!!n&&a&&s>(a=Math.abs(a))&&(l=o,s=a);return l},mi=function(e,t,n){var i=e.vars,s=i[t],o=Tn,a=e._ctx,l,u,c;if(s)return l=i[t+"Params"],u=i.callbackScope||e,n&&go.length&&jh(),a&&(Tn=a),c=l?s.apply(u,l):s.call(u),Tn=o,c},$u=function(e){return So(e),e.scrollTrigger&&e.scrollTrigger.kill(!!or),e.progress()<1&&mi(e,"onInterrupt"),e},ml,NO=function(e){e=!e.name&&e.default||e;var t=e.name,n=_n(e),i=t&&!n&&e.init?function(){this._props=[]}:e,s={init:pc,render:fy,add:ly,kill:qO,modifier:jO,rawVars:0},o={targetTest:0,get:0,getSetter:hy,aliases:{},register:0};if(Vl(),e!==i){if(zr[t])return;wi(i,wi(qh(e,s),o)),Sa(i.prototype,Sa(s,qh(e,o))),zr[i.prop=t]=i,e.targetTest&&(Nh.push(i),sy[t]=1),t=(t==="css"?"CSS":t.charAt(0).toUpperCase()+t.substr(1))+"Plugin"}o1(t,i),e.register&&e.register(jr,i,kr)},jt=255,zu={aqua:[0,jt,jt],lime:[0,jt,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,jt],navy:[0,0,128],white:[jt,jt,jt],olive:[128,128,0],yellow:[jt,jt,0],orange:[jt,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[jt,0,0],pink:[jt,192,203],cyan:[0,jt,jt],transparent:[jt,jt,jt,0]},tp=function(e,t,n){return e+=e<0?1:e>1?-1:0,(e*6<1?t+(n-t)*e*6:e<.5?n:e*3<2?t+(n-t)*(2/3-e)*6:t)*jt+.5|0},S1=function(e,t,n){var i=e?Ps(e)?[e>>16,e>>8&jt,e&jt]:0:zu.black,s,o,a,l,u,c,h,f,d,g;if(!i){if(e.substr(-1)===","&&(e=e.substr(0,e.length-1)),zu[e])i=zu[e];else if(e.charAt(0)==="#"){if(e.length<6&&(s=e.charAt(1),o=e.charAt(2),a=e.charAt(3),e="#"+s+s+o+o+a+a+(e.length===5?e.charAt(4)+e.charAt(4):"")),e.length===9)return i=parseInt(e.substr(1,6),16),[i>>16,i>>8&jt,i&jt,parseInt(e.substr(7),16)/255];e=parseInt(e.substr(1),16),i=[e>>16,e>>8&jt,e&jt]}else if(e.substr(0,3)==="hsl"){if(i=g=e.match(nm),!t)l=+i[0]%360/360,u=+i[1]/100,c=+i[2]/100,o=c<=.5?c*(u+1):c+u-c*u,s=c*2-o,i.length>3&&(i[3]*=1),i[0]=tp(l+1/3,s,o),i[1]=tp(l,s,o),i[2]=tp(l-1/3,s,o);else if(~e.indexOf("="))return i=e.match(t1),n&&i.length<4&&(i[3]=1),i}else i=e.match(nm)||zu.transparent;i=i.map(Number)}return t&&!g&&(s=i[0]/jt,o=i[1]/jt,a=i[2]/jt,h=Math.max(s,o,a),f=Math.min(s,o,a),c=(h+f)/2,h===f?l=u=0:(d=h-f,u=c>.5?d/(2-h-f):d/(h+f),l=h===s?(o-a)/d+(o<a?6:0):h===o?(a-s)/d+2:(s-o)/d+4,l*=60),i[0]=~~(l+.5),i[1]=~~(u*100+.5),i[2]=~~(c*100+.5)),n&&i.length<4&&(i[3]=1),i},T1=function(e){var t=[],n=[],i=-1;return e.split(yo).forEach(function(s){var o=s.match(pl)||[];t.push.apply(t,o),n.push(i+=o.length+1)}),t.c=n,t},Lb=function(e,t,n){var i="",s=(e+i).match(yo),o=t?"hsla(":"rgba(",a=0,l,u,c,h;if(!s)return e;if(s=s.map(function(f){return(f=S1(f,t,1))&&o+(t?f[0]+","+f[1]+"%,"+f[2]+"%,"+f[3]:f.join(","))+")"}),n&&(c=T1(e),l=n.c,l.join(i)!==c.c.join(i)))for(u=e.replace(yo,"1").split(pl),h=u.length-1;a<h;a++)i+=u[a]+(~l.indexOf(a)?s.shift()||o+"0,0,0,0)":(c.length?c:s.length?s:n).shift());if(!u)for(u=e.split(yo),h=u.length-1;a<h;a++)i+=u[a]+s[a];return i+u[h]},yo=function(){var r="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",e;for(e in zu)r+="|"+e+"\\b";return new RegExp(r+")","gi")}(),RO=/hsl[a]?\(/,E1=function(e){var t=e.join(" "),n;if(yo.lastIndex=0,yo.test(t))return n=RO.test(t),e[1]=Lb(e[1],n),e[0]=Lb(e[0],n,T1(e[1])),!0},gc,Br=function(){var r=Date.now,e=500,t=33,n=r(),i=n,s=1e3/240,o=s,a=[],l,u,c,h,f,d,g=function p(m){var _=r()-i,v=m===!0,b,x,T,I;if(_>e&&(n+=_-t),i+=_,T=i-n,b=T-o,(b>0||v)&&(I=++h.frame,f=T-h.time*1e3,h.time=T=T/1e3,o+=b+(b>=s?4:s-b),x=1),v||(l=u(p)),x)for(d=0;d<a.length;d++)a[d](T,f,I,m)};return h={time:0,frame:0,tick:function(){g(!0)},deltaRatio:function(m){return f/(1e3/(m||60))},wake:function(){i1&&(!rm&&Jw()&&(ai=rm=window,ry=ai.document||{},Hr.gsap=jr,(ai.gsapVersions||(ai.gsapVersions=[])).push(jr.version),s1(Gh||ai.GreenSockGlobals||!ai.gsap&&ai||{}),c=ai.requestAnimationFrame),l&&h.sleep(),u=c||function(m){return setTimeout(m,o-h.time*1e3+1|0)},gc=1,g(2))},sleep:function(){(c?ai.cancelAnimationFrame:clearTimeout)(l),gc=0,u=pc},lagSmoothing:function(m,_){e=m||1/0,t=Math.min(_||33,e)},fps:function(m){s=1e3/(m||240),o=h.time*1e3+s},add:function(m,_,v){var b=_?function(x,T,I,C){m(x,T,I,C),h.remove(b)}:m;return h.remove(m),a[v?"unshift":"push"](b),Vl(),b},remove:function(m,_){~(_=a.indexOf(m))&&a.splice(_,1)&&d>=_&&d--},_listeners:a},h}(),Vl=function(){return!gc&&Br.wake()},Rt={},PO=/^[\d.\-M][\d.\-,\s]/,LO=/["']/g,DO=function(e){for(var t={},n=e.substr(1,e.length-3).split(":"),i=n[0],s=1,o=n.length,a,l,u;s<o;s++)l=n[s],a=s!==o-1?l.lastIndexOf(","):l.length,u=l.substr(0,a),t[i]=isNaN(u)?u.replace(LO,"").trim():+u,i=l.substr(a+1).trim();return t},OO=function(e){var t=e.indexOf("(")+1,n=e.indexOf(")"),i=e.indexOf("(",t);return e.substring(t,~i&&i<n?e.indexOf(")",n+1):n)},FO=function(e){var t=(e+"").split("("),n=Rt[t[0]];return n&&t.length>1&&n.config?n.config.apply(null,~e.indexOf("{")?[DO(t[1])]:OO(e).split(",").map(c1)):Rt._CE&&PO.test(e)?Rt._CE("",e):n},M1=function(e){return function(t){return 1-e(1-t)}},A1=function r(e,t){for(var n=e._first,i;n;)n instanceof Mr?r(n,t):n.vars.yoyoEase&&(!n._yoyo||!n._repeat)&&n._yoyo!==t&&(n.timeline?r(n.timeline,t):(i=n._ease,n._ease=n._yEase,n._yEase=i,n._yoyo=t)),n=n._next},da=function(e,t){return e&&(_n(e)?e:Rt[e]||FO(e))||t},La=function(e,t,n,i){n===void 0&&(n=function(l){return 1-t(1-l)}),i===void 0&&(i=function(l){return l<.5?t(l*2)/2:1-t((1-l)*2)/2});var s={easeIn:t,easeOut:n,easeInOut:i},o;return Cr(e,function(a){Rt[a]=Hr[a]=s,Rt[o=a.toLowerCase()]=n;for(var l in s)Rt[o+(l==="easeIn"?".in":l==="easeOut"?".out":".inOut")]=Rt[a+"."+l]=s[l]}),s},I1=function(e){return function(t){return t<.5?(1-e(1-t*2))/2:.5+e((t-.5)*2)/2}},np=function r(e,t,n){var i=t>=1?t:1,s=(n||(e?.3:.45))/(t<1?t:1),o=s/tm*(Math.asin(1/i)||0),a=function(c){return c===1?1:i*Math.pow(2,-10*c)*cO((c-o)*s)+1},l=e==="out"?a:e==="in"?function(u){return 1-a(1-u)}:I1(a);return s=tm/s,l.config=function(u,c){return r(e,u,c)},l},rp=function r(e,t){t===void 0&&(t=1.70158);var n=function(o){return o?--o*o*((t+1)*o+t)+1:0},i=e==="out"?n:e==="in"?function(s){return 1-n(1-s)}:I1(n);return i.config=function(s){return r(e,s)},i};Cr("Linear,Quad,Cubic,Quart,Quint,Strong",function(r,e){var t=e<5?e+1:e;La(r+",Power"+(t-1),e?function(n){return Math.pow(n,t)}:function(n){return n},function(n){return 1-Math.pow(1-n,t)},function(n){return n<.5?Math.pow(n*2,t)/2:1-Math.pow((1-n)*2,t)/2})});Rt.Linear.easeNone=Rt.none=Rt.Linear.easeIn;La("Elastic",np("in"),np("out"),np());(function(r,e){var t=1/e,n=2*t,i=2.5*t,s=function(a){return a<t?r*a*a:a<n?r*Math.pow(a-1.5/e,2)+.75:a<i?r*(a-=2.25/e)*a+.9375:r*Math.pow(a-2.625/e,2)+.984375};La("Bounce",function(o){return 1-s(1-o)},s)})(7.5625,2.75);La("Expo",function(r){return r?Math.pow(2,10*(r-1)):0});La("Circ",function(r){return-(Qw(1-r*r)-1)});La("Sine",function(r){return r===1?1:-uO(r*aO)+1});La("Back",rp("in"),rp("out"),rp());Rt.SteppedEase=Rt.steps=Hr.SteppedEase={config:function(e,t){e===void 0&&(e=1);var n=1/e,i=e+(t?0:1),s=t?1:0,o=1-Xt;return function(a){return((i*Lc(0,o,a)|0)+s)*n}}};zl.ease=Rt["quad.out"];Cr("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",function(r){return oy+=r+","+r+"Params,"});var C1=function(e,t){this.id=lO++,e._gsap=this,this.target=e,this.harness=t,this.get=t?t.get:l1,this.set=t?t.getSetter:hy},Wl=function(){function r(t){this.vars=t,this._delay=+t.delay||0,(this._repeat=t.repeat===1/0?-2:t.repeat||0)&&(this._rDelay=t.repeatDelay||0,this._yoyo=!!t.yoyo||!!t.yoyoEase),this._ts=1,Ul(this,+t.duration,1,1),this.data=t.data,Tn&&(this._ctx=Tn,Tn.data.push(this)),gc||Br.wake()}var e=r.prototype;return e.delay=function(n){return n||n===0?(this.parent&&this.parent.smoothChildTiming&&this.startTime(this._start+n-this._delay),this._delay=n,this):this._delay},e.duration=function(n){return arguments.length?this.totalDuration(this._repeat>0?n+(n+this._rDelay)*this._repeat:n):this.totalDuration()&&this._dur},e.totalDuration=function(n){return arguments.length?(this._dirty=0,Ul(this,this._repeat<0?n:(n-this._repeat*this._rDelay)/(this._repeat+1))):this._tDur},e.totalTime=function(n,i){if(Vl(),!arguments.length)return this._tTime;var s=this._dp;if(s&&s.smoothChildTiming&&this._ts){for(Ff(this,n),!s._dp||s.parent||d1(s,this);s&&s.parent;)s.parent._time!==s._start+(s._ts>=0?s._tTime/s._ts:(s.totalDuration()-s._tTime)/-s._ts)&&s.totalTime(s._tTime,!0),s=s.parent;!this.parent&&this._dp.autoRemoveChildren&&(this._ts>0&&n<this._tDur||this._ts<0&&n>0||!this._tDur&&!n)&&Yi(this._dp,this,this._start-this._delay)}return(this._tTime!==n||!this._dur&&!i||this._initted&&Math.abs(this._zTime)===Xt||!n&&!this._initted&&(this.add||this._ptLookup))&&(this._ts||(this._pTime=n),u1(this,n,i)),this},e.time=function(n,i){return arguments.length?this.totalTime(Math.min(this.totalDuration(),n+Nb(this))%(this._dur+this._rDelay)||(n?this._dur:0),i):this._time},e.totalProgress=function(n,i){return arguments.length?this.totalTime(this.totalDuration()*n,i):this.totalDuration()?Math.min(1,this._tTime/this._tDur):this.ratio},e.progress=function(n,i){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&!(this.iteration()&1)?1-n:n)+Nb(this),i):this.duration()?Math.min(1,this._time/this._dur):this.ratio},e.iteration=function(n,i){var s=this.duration()+this._rDelay;return arguments.length?this.totalTime(this._time+(n-1)*s,i):this._repeat?Bl(this._tTime,s)+1:1},e.timeScale=function(n){if(!arguments.length)return this._rts===-Xt?0:this._rts;if(this._rts===n)return this;var i=this.parent&&this._ts?Kh(this.parent._time,this):this._tTime;return this._rts=+n||0,this._ts=this._ps||n===-Xt?0:this._rts,this.totalTime(Lc(-this._delay,this._tDur,i),!0),Of(this),yO(this)},e.paused=function(n){return arguments.length?(this._ps!==n&&(this._ps=n,n?(this._pTime=this._tTime||Math.max(-this._delay,this.rawTime()),this._ts=this._act=0):(Vl(),this._ts=this._rts,this.totalTime(this.parent&&!this.parent.smoothChildTiming?this.rawTime():this._tTime||this._pTime,this.progress()===1&&Math.abs(this._zTime)!==Xt&&(this._tTime-=Xt)))),this):this._ps},e.startTime=function(n){if(arguments.length){this._start=n;var i=this.parent||this._dp;return i&&(i._sort||!this.parent)&&Yi(i,this,n-this._delay),this}return this._start},e.endTime=function(n){return this._start+(Ir(n)?this.totalDuration():this.duration())/Math.abs(this._ts||1)},e.rawTime=function(n){var i=this.parent||this._dp;return i?n&&(!this._ts||this._repeat&&this._time&&this.totalProgress()<1)?this._tTime%(this._dur+this._rDelay):this._ts?Kh(i.rawTime(n),this):this._tTime:this._tTime},e.revert=function(n){n===void 0&&(n=dO);var i=or;return or=n,(this._initted||this._startAt)&&(this.timeline&&this.timeline.revert(n),this.totalTime(-.01,n.suppressEvents)),this.data!=="nested"&&n.kill!==!1&&this.kill(),or=i,this},e.globalTime=function(n){for(var i=this,s=arguments.length?n:i.rawTime();i;)s=i._start+s/(i._ts||1),i=i._dp;return!this.parent&&this._sat?this._sat.vars.immediateRender?-1:this._sat.globalTime(n):s},e.repeat=function(n){return arguments.length?(this._repeat=n===1/0?-2:n,Rb(this)):this._repeat===-2?1/0:this._repeat},e.repeatDelay=function(n){if(arguments.length){var i=this._time;return this._rDelay=n,Rb(this),i?this.time(i):this}return this._rDelay},e.yoyo=function(n){return arguments.length?(this._yoyo=n,this):this._yoyo},e.seek=function(n,i){return this.totalTime(si(this,n),Ir(i))},e.restart=function(n,i){return this.play().totalTime(n?-this._delay:0,Ir(i))},e.play=function(n,i){return n!=null&&this.seek(n,i),this.reversed(!1).paused(!1)},e.reverse=function(n,i){return n!=null&&this.seek(n||this.totalDuration(),i),this.reversed(!0).paused(!1)},e.pause=function(n,i){return n!=null&&this.seek(n,i),this.paused(!0)},e.resume=function(){return this.paused(!1)},e.reversed=function(n){return arguments.length?(!!n!==this.reversed()&&this.timeScale(-this._rts||(n?-Xt:0)),this):this._rts<0},e.invalidate=function(){return this._initted=this._act=0,this._zTime=-Xt,this},e.isActive=function(){var n=this.parent||this._dp,i=this._start,s;return!!(!n||this._ts&&this._initted&&n.isActive()&&(s=n.rawTime(!0))>=i&&s<this.endTime(!0)-Xt)},e.eventCallback=function(n,i,s){var o=this.vars;return arguments.length>1?(i?(o[n]=i,s&&(o[n+"Params"]=s),n==="onUpdate"&&(this._onUpdate=i)):delete o[n],this):o[n]},e.then=function(n){var i=this;return new Promise(function(s){var o=_n(n)?n:h1,a=function(){var u=i.then;i.then=null,_n(o)&&(o=o(i))&&(o.then||o===i)&&(i.then=u),s(o),i.then=u};i._initted&&i.totalProgress()===1&&i._ts>=0||!i._tTime&&i._ts<0?a():i._prom=a})},e.kill=function(){$u(this)},r}();wi(Wl.prototype,{_time:0,_start:0,_end:0,_tTime:0,_tDur:0,_dirty:0,_repeat:0,_yoyo:!1,parent:null,_initted:!1,_rDelay:0,_ts:1,_dp:0,ratio:0,_zTime:-Xt,_prom:0,_ps:!1,_rts:1});var Mr=function(r){Zw(e,r);function e(n,i){var s;return n===void 0&&(n={}),s=r.call(this,n)||this,s.labels={},s.smoothChildTiming=!!n.smoothChildTiming,s.autoRemoveChildren=!!n.autoRemoveChildren,s._sort=Ir(n.sortChildren),pn&&Yi(n.parent||pn,ms(s),i),n.reversed&&s.reverse(),n.paused&&s.paused(!0),n.scrollTrigger&&p1(ms(s),n.scrollTrigger),s}var t=e.prototype;return t.to=function(i,s,o){return Zu(0,arguments,this),this},t.from=function(i,s,o){return Zu(1,arguments,this),this},t.fromTo=function(i,s,o,a){return Zu(2,arguments,this),this},t.set=function(i,s,o){return s.duration=0,s.parent=this,Yu(s).repeatDelay||(s.repeat=0),s.immediateRender=!!s.immediateRender,new In(i,s,si(this,o),1),this},t.call=function(i,s,o){return Yi(this,In.delayedCall(0,i,s),o)},t.staggerTo=function(i,s,o,a,l,u,c){return o.duration=s,o.stagger=o.stagger||a,o.onComplete=u,o.onCompleteParams=c,o.parent=this,new In(i,o,si(this,l)),this},t.staggerFrom=function(i,s,o,a,l,u,c){return o.runBackwards=1,Yu(o).immediateRender=Ir(o.immediateRender),this.staggerTo(i,s,o,a,l,u,c)},t.staggerFromTo=function(i,s,o,a,l,u,c,h){return a.startAt=o,Yu(a).immediateRender=Ir(a.immediateRender),this.staggerTo(i,s,a,l,u,c,h)},t.render=function(i,s,o){var a=this._time,l=this._dirty?this.totalDuration():this._tDur,u=this._dur,c=i<=0?0:Gn(i),h=this._zTime<0!=i<0&&(this._initted||!u),f,d,g,p,m,_,v,b,x,T,I,C;if(this!==pn&&c>l&&i>=0&&(c=l),c!==this._tTime||o||h){if(a!==this._time&&u&&(c+=this._time-a,i+=this._time-a),f=c,x=this._start,b=this._ts,_=!b,h&&(u||(a=this._zTime),(i||!s)&&(this._zTime=i)),this._repeat){if(I=this._yoyo,m=u+this._rDelay,this._repeat<-1&&i<0)return this.totalTime(m*100+i,s,o);if(f=Gn(c%m),c===l?(p=this._repeat,f=u):(p=~~(c/m),p&&p===c/m&&(f=u,p--),f>u&&(f=u)),T=Bl(this._tTime,m),!a&&this._tTime&&T!==p&&(T=p),I&&p&1&&(f=u-f,C=1),p!==T&&!this._lock){var S=I&&T&1,A=S===(I&&p&1);if(p<T&&(S=!S),a=S?0:u,this._lock=1,this.render(a||(C?0:Gn(p*m)),s,!u)._lock=0,this._tTime=c,!s&&this.parent&&mi(this,"onRepeat"),this.vars.repeatRefresh&&!C&&(this.invalidate()._lock=1),a&&a!==this._time||_!==!this._ts||this.vars.onRepeat&&!this.parent&&!this._act)return this;if(u=this._dur,l=this._tDur,A&&(this._lock=2,a=S?u:-1e-4,this.render(a,!0),this.vars.repeatRefresh&&!C&&this.invalidate()),this._lock=0,!this._ts&&!_)return this;A1(this,C)}}if(this._hasPause&&!this._forcing&&this._lock<2&&(v=vO(this,Gn(a),Gn(f)),v&&(c-=f-(f=v._start))),this._tTime=c,this._time=f,this._act=!b,this._initted||(this._onUpdate=this.vars.onUpdate,this._initted=1,this._zTime=i,a=0),!a&&f&&!s&&(mi(this,"onStart"),this._tTime!==c))return this;if(f>=a&&i>=0)for(d=this._first;d;){if(g=d._next,(d._act||f>=d._start)&&d._ts&&v!==d){if(d.parent!==this)return this.render(i,s,o);if(d.render(d._ts>0?(f-d._start)*d._ts:(d._dirty?d.totalDuration():d._tDur)+(f-d._start)*d._ts,s,o),f!==this._time||!this._ts&&!_){v=0,g&&(c+=this._zTime=-Xt);break}}d=g}else{d=this._last;for(var R=i<0?i:f;d;){if(g=d._prev,(d._act||R<=d._end)&&d._ts&&v!==d){if(d.parent!==this)return this.render(i,s,o);if(d.render(d._ts>0?(R-d._start)*d._ts:(d._dirty?d.totalDuration():d._tDur)+(R-d._start)*d._ts,s,o||or&&(d._initted||d._startAt)),f!==this._time||!this._ts&&!_){v=0,g&&(c+=this._zTime=R?-Xt:Xt);break}}d=g}}if(v&&!s&&(this.pause(),v.render(f>=a?0:-Xt)._zTime=f>=a?1:-1,this._ts))return this._start=x,Of(this),this.render(i,s,o);this._onUpdate&&!s&&mi(this,"onUpdate",!0),(c===l&&this._tTime>=this.totalDuration()||!c&&a)&&(x===this._start||Math.abs(b)!==Math.abs(this._ts))&&(this._lock||((i||!u)&&(c===l&&this._ts>0||!c&&this._ts<0)&&So(this,1),!s&&!(i<0&&!a)&&(c||a||!l)&&(mi(this,c===l&&i>=0?"onComplete":"onReverseComplete",!0),this._prom&&!(c<l&&this.timeScale()>0)&&this._prom())))}return this},t.add=function(i,s){var o=this;if(Ps(s)||(s=si(this,s,i)),!(i instanceof Wl)){if(ar(i))return i.forEach(function(a){return o.add(a,s)}),this;if($n(i))return this.addLabel(i,s);if(_n(i))i=In.delayedCall(0,i);else return this}return this!==i?Yi(this,i,s):this},t.getChildren=function(i,s,o,a){i===void 0&&(i=!0),s===void 0&&(s=!0),o===void 0&&(o=!0),a===void 0&&(a=-di);for(var l=[],u=this._first;u;)u._start>=a&&(u instanceof In?s&&l.push(u):(o&&l.push(u),i&&l.push.apply(l,u.getChildren(!0,s,o)))),u=u._next;return l},t.getById=function(i){for(var s=this.getChildren(1,1,1),o=s.length;o--;)if(s[o].vars.id===i)return s[o]},t.remove=function(i){return $n(i)?this.removeLabel(i):_n(i)?this.killTweensOf(i):(Df(this,i),i===this._recent&&(this._recent=this._last),fa(this))},t.totalTime=function(i,s){return arguments.length?(this._forcing=1,!this._dp&&this._ts&&(this._start=Gn(Br.time-(this._ts>0?i/this._ts:(this.totalDuration()-i)/-this._ts))),r.prototype.totalTime.call(this,i,s),this._forcing=0,this):this._tTime},t.addLabel=function(i,s){return this.labels[i]=si(this,s),this},t.removeLabel=function(i){return delete this.labels[i],this},t.addPause=function(i,s,o){var a=In.delayedCall(0,s||pc,o);return a.data="isPause",this._hasPause=1,Yi(this,a,si(this,i))},t.removePause=function(i){var s=this._first;for(i=si(this,i);s;)s._start===i&&s.data==="isPause"&&So(s),s=s._next},t.killTweensOf=function(i,s,o){for(var a=this.getTweensOf(i,o),l=a.length;l--;)oo!==a[l]&&a[l].kill(i,s);return this},t.getTweensOf=function(i,s){for(var o=[],a=pi(i),l=this._first,u=Ps(s),c;l;)l instanceof In?pO(l._targets,a)&&(u?(!oo||l._initted&&l._ts)&&l.globalTime(0)<=s&&l.globalTime(l.totalDuration())>s:!s||l.isActive())&&o.push(l):(c=l.getTweensOf(a,s)).length&&o.push.apply(o,c),l=l._next;return o},t.tweenTo=function(i,s){s=s||{};var o=this,a=si(o,i),l=s,u=l.startAt,c=l.onStart,h=l.onStartParams,f=l.immediateRender,d,g=In.to(o,wi({ease:s.ease||"none",lazy:!1,immediateRender:!1,time:a,overwrite:"auto",duration:s.duration||Math.abs((a-(u&&"time"in u?u.time:o._time))/o.timeScale())||Xt,onStart:function(){if(o.pause(),!d){var m=s.duration||Math.abs((a-(u&&"time"in u?u.time:o._time))/o.timeScale());g._dur!==m&&Ul(g,m,0,1).render(g._time,!0,!0),d=1}c&&c.apply(g,h||[])}},s));return f?g.render(0):g},t.tweenFromTo=function(i,s,o){return this.tweenTo(s,wi({startAt:{time:si(this,i)}},o))},t.recent=function(){return this._recent},t.nextLabel=function(i){return i===void 0&&(i=this._time),Pb(this,si(this,i))},t.previousLabel=function(i){return i===void 0&&(i=this._time),Pb(this,si(this,i),1)},t.currentLabel=function(i){return arguments.length?this.seek(i,!0):this.previousLabel(this._time+Xt)},t.shiftChildren=function(i,s,o){o===void 0&&(o=0);for(var a=this._first,l=this.labels,u;a;)a._start>=o&&(a._start+=i,a._end+=i),a=a._next;if(s)for(u in l)l[u]>=o&&(l[u]+=i);return fa(this)},t.invalidate=function(i){var s=this._first;for(this._lock=0;s;)s.invalidate(i),s=s._next;return r.prototype.invalidate.call(this,i)},t.clear=function(i){i===void 0&&(i=!0);for(var s=this._first,o;s;)o=s._next,this.remove(s),s=o;return this._dp&&(this._time=this._tTime=this._pTime=0),i&&(this.labels={}),fa(this)},t.totalDuration=function(i){var s=0,o=this,a=o._last,l=di,u,c,h;if(arguments.length)return o.timeScale((o._repeat<0?o.duration():o.totalDuration())/(o.reversed()?-i:i));if(o._dirty){for(h=o.parent;a;)u=a._prev,a._dirty&&a.totalDuration(),c=a._start,c>l&&o._sort&&a._ts&&!o._lock?(o._lock=1,Yi(o,a,c-a._delay,1)._lock=0):l=c,c<0&&a._ts&&(s-=c,(!h&&!o._dp||h&&h.smoothChildTiming)&&(o._start+=c/o._ts,o._time-=c,o._tTime-=c),o.shiftChildren(-c,!1,-1/0),l=0),a._end>s&&a._ts&&(s=a._end),a=u;Ul(o,o===pn&&o._time>s?o._time:s,1,1),o._dirty=0}return o._tDur},e.updateRoot=function(i){if(pn._ts&&(u1(pn,Kh(i,pn)),a1=Br.frame),Br.frame>=Cb){Cb+=Wr.autoSleep||120;var s=pn._first;if((!s||!s._ts)&&Wr.autoSleep&&Br._listeners.length<2){for(;s&&!s._ts;)s=s._next;s||Br.sleep()}}},e}(Wl);wi(Mr.prototype,{_lock:0,_hasPause:0,_forcing:0});var $O=function(e,t,n,i,s,o,a){var l=new kr(this._pt,e,t,0,1,D1,null,s),u=0,c=0,h,f,d,g,p,m,_,v;for(l.b=n,l.e=i,n+="",i+="",(_=~i.indexOf("random("))&&(i=mc(i)),o&&(v=[n,i],o(v,e,t),n=v[0],i=v[1]),f=n.match(Jd)||[];h=Jd.exec(i);)g=h[0],p=i.substring(u,h.index),d?d=(d+1)%5:p.substr(-5)==="rgba("&&(d=1),g!==f[c++]&&(m=parseFloat(f[c-1])||0,l._pt={_next:l._pt,p:p||c===1?p:",",s:m,c:g.charAt(1)==="="?Sl(m,g)-m:parseFloat(g)-m,m:d&&d<4?Math.round:0},u=Jd.lastIndex);return l.c=u<i.length?i.substring(u,i.length):"",l.fp=a,(n1.test(i)||_)&&(l.e=0),this._pt=l,l},ly=function(e,t,n,i,s,o,a,l,u,c){_n(i)&&(i=i(s||0,e,o));var h=e[t],f=n!=="get"?n:_n(h)?u?e[t.indexOf("set")||!_n(e["get"+t.substr(3)])?t:"get"+t.substr(3)](u):e[t]():h,d=_n(h)?u?WO:P1:cy,g;if($n(i)&&(~i.indexOf("random(")&&(i=mc(i)),i.charAt(1)==="="&&(g=Sl(f,i)+(nr(f)||0),(g||g===0)&&(i=g))),!c||f!==i||cm)return!isNaN(f*i)&&i!==""?(g=new kr(this._pt,e,t,+f||0,i-(f||0),typeof h=="boolean"?HO:L1,0,d),u&&(g.fp=u),a&&g.modifier(a,this,e),this._pt=g):(!h&&!(t in e)&&iy(t,i),$O.call(this,e,t,f,i,d,l||Wr.stringFilter,u))},zO=function(e,t,n,i,s){if(_n(e)&&(e=Qu(e,s,t,n,i)),!is(e)||e.style&&e.nodeType||ar(e)||e1(e))return $n(e)?Qu(e,s,t,n,i):e;var o={},a;for(a in e)o[a]=Qu(e[a],s,t,n,i);return o},k1=function(e,t,n,i,s,o){var a,l,u,c;if(zr[e]&&(a=new zr[e]).init(s,a.rawVars?t[e]:zO(t[e],i,s,o,n),n,i,o)!==!1&&(n._pt=l=new kr(n._pt,s,e,0,1,a.render,a,0,a.priority),n!==ml))for(u=n._ptLookup[n._targets.indexOf(s)],c=a._props.length;c--;)u[a._props[c]]=l;return a},oo,cm,uy=function r(e,t,n){var i=e.vars,s=i.ease,o=i.startAt,a=i.immediateRender,l=i.lazy,u=i.onUpdate,c=i.onUpdateParams,h=i.callbackScope,f=i.runBackwards,d=i.yoyoEase,g=i.keyframes,p=i.autoRevert,m=e._dur,_=e._startAt,v=e._targets,b=e.parent,x=b&&b.data==="nested"?b.vars.targets:v,T=e._overwrite==="auto"&&!ty,I=e.timeline,C,S,A,R,F,q,O,z,H,Q,Z,Y,fe;if(I&&(!g||!s)&&(s="none"),e._ease=da(s,zl.ease),e._yEase=d?M1(da(d===!0?s:d,zl.ease)):0,d&&e._yoyo&&!e._repeat&&(d=e._yEase,e._yEase=e._ease,e._ease=d),e._from=!I&&!!i.runBackwards,!I||g&&!i.stagger){if(z=v[0]?ha(v[0]).harness:0,Y=z&&i[z.prop],C=qh(i,sy),_&&(_._zTime<0&&_.progress(1),t<0&&f&&a&&!p?_.render(-1,!0):_.revert(f&&m?kh:fO),_._lazy=0),o){if(So(e._startAt=In.set(v,wi({data:"isStart",overwrite:!1,parent:b,immediateRender:!0,lazy:!_&&Ir(l),startAt:null,delay:0,onUpdate:u,onUpdateParams:c,callbackScope:h,stagger:0},o))),e._startAt._dp=0,e._startAt._sat=e,t<0&&(or||!a&&!p)&&e._startAt.revert(kh),a&&m&&t<=0&&n<=0){t&&(e._zTime=t);return}}else if(f&&m&&!_){if(t&&(a=!1),A=wi({overwrite:!1,data:"isFromStart",lazy:a&&!_&&Ir(l),immediateRender:a,stagger:0,parent:b},C),Y&&(A[z.prop]=Y),So(e._startAt=In.set(v,A)),e._startAt._dp=0,e._startAt._sat=e,t<0&&(or?e._startAt.revert(kh):e._startAt.render(-1,!0)),e._zTime=t,!a)r(e._startAt,Xt,Xt);else if(!t)return}for(e._pt=e._ptCache=0,l=m&&Ir(l)||l&&!m,S=0;S<v.length;S++){if(F=v[S],O=F._gsap||ay(v)[S]._gsap,e._ptLookup[S]=Q={},im[O.id]&&go.length&&jh(),Z=x===v?S:x.indexOf(F),z&&(H=new z).init(F,Y||C,e,Z,x)!==!1&&(e._pt=R=new kr(e._pt,F,H.name,0,1,H.render,H,0,H.priority),H._props.forEach(function(le){Q[le]=R}),H.priority&&(q=1)),!z||Y)for(A in C)zr[A]&&(H=k1(A,C,e,Z,F,x))?H.priority&&(q=1):Q[A]=R=ly.call(e,F,A,"get",C[A],Z,x,0,i.stringFilter);e._op&&e._op[S]&&e.kill(F,e._op[S]),T&&e._pt&&(oo=e,pn.killTweensOf(F,Q,e.globalTime(t)),fe=!e.parent,oo=0),e._pt&&l&&(im[O.id]=1)}q&&O1(e),e._onInit&&e._onInit(e)}e._onUpdate=u,e._initted=(!e._op||e._pt)&&!fe,g&&t<=0&&I.render(di,!0,!0)},BO=function(e,t,n,i,s,o,a){var l=(e._pt&&e._ptCache||(e._ptCache={}))[t],u,c,h,f;if(!l)for(l=e._ptCache[t]=[],h=e._ptLookup,f=e._targets.length;f--;){if(u=h[f][t],u&&u.d&&u.d._pt)for(u=u.d._pt;u&&u.p!==t&&u.fp!==t;)u=u._next;if(!u)return cm=1,e.vars[t]="+=0",uy(e,a),cm=0,1;l.push(u)}for(f=l.length;f--;)c=l[f],u=c._pt||c,u.s=(i||i===0)&&!s?i:u.s+(i||0)+o*u.c,u.c=n-u.s,c.e&&(c.e=vn(n)+nr(c.e)),c.b&&(c.b=u.s+nr(c.b))},UO=function(e,t){var n=e[0]?ha(e[0]).harness:0,i=n&&n.aliases,s,o,a,l;if(!i)return t;s=Sa({},t);for(o in i)if(o in s)for(l=i[o].split(","),a=l.length;a--;)s[l[a]]=s[o];return s},VO=function(e,t,n,i){var s=t.ease||i||"power1.inOut",o,a;if(ar(t))a=n[e]||(n[e]=[]),t.forEach(function(l,u){return a.push({t:u/(t.length-1)*100,v:l,e:s})});else for(o in t)a=n[o]||(n[o]=[]),o==="ease"||a.push({t:parseFloat(e),v:t[o],e:s})},Qu=function(e,t,n,i,s){return _n(e)?e.call(t,n,i,s):$n(e)&&~e.indexOf("random(")?mc(e):e},N1=oy+"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",R1={};Cr(N1+",id,stagger,delay,duration,paused,scrollTrigger",function(r){return R1[r]=1});var In=function(r){Zw(e,r);function e(n,i,s,o){var a;typeof i=="number"&&(s.duration=i,i=s,s=null),a=r.call(this,o?i:Yu(i))||this;var l=a.vars,u=l.duration,c=l.delay,h=l.immediateRender,f=l.stagger,d=l.overwrite,g=l.keyframes,p=l.defaults,m=l.scrollTrigger,_=l.yoyoEase,v=i.parent||pn,b=(ar(n)||e1(n)?Ps(n[0]):"length"in i)?[n]:pi(n),x,T,I,C,S,A,R,F;if(a._targets=b.length?ay(b):Hh("GSAP target "+n+" not found. https://greensock.com",!Wr.nullTargetWarn)||[],a._ptLookup=[],a._overwrite=d,g||f||bh(u)||bh(c)){if(i=a.vars,x=a.timeline=new Mr({data:"nested",defaults:p||{},targets:v&&v.data==="nested"?v.vars.targets:b}),x.kill(),x.parent=x._dp=ms(a),x._start=0,f||bh(u)||bh(c)){if(C=b.length,R=f&&_1(f),is(f))for(S in f)~N1.indexOf(S)&&(F||(F={}),F[S]=f[S]);for(T=0;T<C;T++)I=qh(i,R1),I.stagger=0,_&&(I.yoyoEase=_),F&&Sa(I,F),A=b[T],I.duration=+Qu(u,ms(a),T,A,b),I.delay=(+Qu(c,ms(a),T,A,b)||0)-a._delay,!f&&C===1&&I.delay&&(a._delay=c=I.delay,a._start+=c,I.delay=0),x.to(A,I,R?R(T,A,b):0),x._ease=Rt.none;x.duration()?u=c=0:a.timeline=0}else if(g){Yu(wi(x.vars.defaults,{ease:"none"})),x._ease=da(g.ease||i.ease||"none");var q=0,O,z,H;if(ar(g))g.forEach(function(Q){return x.to(b,Q,">")}),x.duration();else{I={};for(S in g)S==="ease"||S==="easeEach"||VO(S,g[S],I,g.easeEach);for(S in I)for(O=I[S].sort(function(Q,Z){return Q.t-Z.t}),q=0,T=0;T<O.length;T++)z=O[T],H={ease:z.e,duration:(z.t-(T?O[T-1].t:0))/100*u},H[S]=z.v,x.to(b,H,q),q+=H.duration;x.duration()<u&&x.to({},{duration:u-x.duration()})}}u||a.duration(u=x.duration())}else a.timeline=0;return d===!0&&!ty&&(oo=ms(a),pn.killTweensOf(b),oo=0),Yi(v,ms(a),s),i.reversed&&a.reverse(),i.paused&&a.paused(!0),(h||!u&&!g&&a._start===Gn(v._time)&&Ir(h)&&_O(ms(a))&&v.data!=="nested")&&(a._tTime=-Xt,a.render(Math.max(0,-c)||0)),m&&p1(ms(a),m),a}var t=e.prototype;return t.render=function(i,s,o){var a=this._time,l=this._tDur,u=this._dur,c=i<0,h=i>l-Xt&&!c?l:i<Xt?0:i,f,d,g,p,m,_,v,b,x;if(!u)xO(this,i,s,o);else if(h!==this._tTime||!i||o||!this._initted&&this._tTime||this._startAt&&this._zTime<0!==c){if(f=h,b=this.timeline,this._repeat){if(p=u+this._rDelay,this._repeat<-1&&c)return this.totalTime(p*100+i,s,o);if(f=Gn(h%p),h===l?(g=this._repeat,f=u):(g=~~(h/p),g&&g===h/p&&(f=u,g--),f>u&&(f=u)),_=this._yoyo&&g&1,_&&(x=this._yEase,f=u-f),m=Bl(this._tTime,p),f===a&&!o&&this._initted)return this._tTime=h,this;g!==m&&(b&&this._yEase&&A1(b,_),this.vars.repeatRefresh&&!_&&!this._lock&&(this._lock=o=1,this.render(Gn(p*g),!0).invalidate()._lock=0))}if(!this._initted){if(m1(this,c?i:f,o,s,h))return this._tTime=0,this;if(a!==this._time)return this;if(u!==this._dur)return this.render(i,s,o)}if(this._tTime=h,this._time=f,!this._act&&this._ts&&(this._act=1,this._lazy=0),this.ratio=v=(x||this._ease)(f/u),this._from&&(this.ratio=v=1-v),f&&!a&&!s&&(mi(this,"onStart"),this._tTime!==h))return this;for(d=this._pt;d;)d.r(v,d.d),d=d._next;b&&b.render(i<0?i:!f&&_?-Xt:b._dur*b._ease(f/this._dur),s,o)||this._startAt&&(this._zTime=i),this._onUpdate&&!s&&(c&&sm(this,i,s,o),mi(this,"onUpdate")),this._repeat&&g!==m&&this.vars.onRepeat&&!s&&this.parent&&mi(this,"onRepeat"),(h===this._tDur||!h)&&this._tTime===h&&(c&&!this._onUpdate&&sm(this,i,!0,!0),(i||!u)&&(h===this._tDur&&this._ts>0||!h&&this._ts<0)&&So(this,1),!s&&!(c&&!a)&&(h||a||_)&&(mi(this,h===l?"onComplete":"onReverseComplete",!0),this._prom&&!(h<l&&this.timeScale()>0)&&this._prom()))}return this},t.targets=function(){return this._targets},t.invalidate=function(i){return(!i||!this.vars.runBackwards)&&(this._startAt=0),this._pt=this._op=this._onUpdate=this._lazy=this.ratio=0,this._ptLookup=[],this.timeline&&this.timeline.invalidate(i),r.prototype.invalidate.call(this,i)},t.resetTo=function(i,s,o,a){gc||Br.wake(),this._ts||this.play();var l=Math.min(this._dur,(this._dp._time-this._start)*this._ts),u;return this._initted||uy(this,l),u=this._ease(l/this._dur),BO(this,i,s,o,a,u,l)?this.resetTo(i,s,o,a):(Ff(this,0),this.parent||f1(this._dp,this,"_first","_last",this._dp._sort?"_start":0),this.render(0))},t.kill=function(i,s){if(s===void 0&&(s="all"),!i&&(!s||s==="all"))return this._lazy=this._pt=0,this.parent?$u(this):this;if(this.timeline){var o=this.timeline.totalDuration();return this.timeline.killTweensOf(i,s,oo&&oo.vars.overwrite!==!0)._first||$u(this),this.parent&&o!==this.timeline.totalDuration()&&Ul(this,this._dur*this.timeline._tDur/o,0,1),this}var a=this._targets,l=i?pi(i):a,u=this._ptLookup,c=this._pt,h,f,d,g,p,m,_;if((!s||s==="all")&&gO(a,l))return s==="all"&&(this._pt=0),$u(this);for(h=this._op=this._op||[],s!=="all"&&($n(s)&&(p={},Cr(s,function(v){return p[v]=1}),s=p),s=UO(a,s)),_=a.length;_--;)if(~l.indexOf(a[_])){f=u[_],s==="all"?(h[_]=s,g=f,d={}):(d=h[_]=h[_]||{},g=s);for(p in g)m=f&&f[p],m&&((!("kill"in m.d)||m.d.kill(p)===!0)&&Df(this,m,"_pt"),delete f[p]),d!=="all"&&(d[p]=1)}return this._initted&&!this._pt&&c&&$u(this),this},e.to=function(i,s){return new e(i,s,arguments[2])},e.from=function(i,s){return Zu(1,arguments)},e.delayedCall=function(i,s,o,a){return new e(s,0,{immediateRender:!1,lazy:!1,overwrite:!1,delay:i,onComplete:s,onReverseComplete:s,onCompleteParams:o,onReverseCompleteParams:o,callbackScope:a})},e.fromTo=function(i,s,o){return Zu(2,arguments)},e.set=function(i,s){return s.duration=0,s.repeatDelay||(s.repeat=0),new e(i,s)},e.killTweensOf=function(i,s,o){return pn.killTweensOf(i,s,o)},e}(Wl);wi(In.prototype,{_targets:[],_lazy:0,_startAt:0,_op:0,_onInit:0});Cr("staggerTo,staggerFrom,staggerFromTo",function(r){In[r]=function(){var e=new Mr,t=am.call(arguments,0);return t.splice(r==="staggerFromTo"?5:4,0,0),e[r].apply(e,t)}});var cy=function(e,t,n){return e[t]=n},P1=function(e,t,n){return e[t](n)},WO=function(e,t,n,i){return e[t](i.fp,n)},GO=function(e,t,n){return e.setAttribute(t,n)},hy=function(e,t){return _n(e[t])?P1:ny(e[t])&&e.setAttribute?GO:cy},L1=function(e,t){return t.set(t.t,t.p,Math.round((t.s+t.c*e)*1e6)/1e6,t)},HO=function(e,t){return t.set(t.t,t.p,!!(t.s+t.c*e),t)},D1=function(e,t){var n=t._pt,i="";if(!e&&t.b)i=t.b;else if(e===1&&t.e)i=t.e;else{for(;n;)i=n.p+(n.m?n.m(n.s+n.c*e):Math.round((n.s+n.c*e)*1e4)/1e4)+i,n=n._next;i+=t.c}t.set(t.t,t.p,i,t)},fy=function(e,t){for(var n=t._pt;n;)n.r(e,n.d),n=n._next},jO=function(e,t,n,i){for(var s=this._pt,o;s;)o=s._next,s.p===i&&s.modifier(e,t,n),s=o},qO=function(e){for(var t=this._pt,n,i;t;)i=t._next,t.p===e&&!t.op||t.op===e?Df(this,t,"_pt"):t.dep||(n=1),t=i;return!n},KO=function(e,t,n,i){i.mSet(e,t,i.m.call(i.tween,n,i.mt),i)},O1=function(e){for(var t=e._pt,n,i,s,o;t;){for(n=t._next,i=s;i&&i.pr>t.pr;)i=i._next;(t._prev=i?i._prev:o)?t._prev._next=t:s=t,(t._next=i)?i._prev=t:o=t,t=n}e._pt=s},kr=function(){function r(t,n,i,s,o,a,l,u,c){this.t=n,this.s=s,this.c=o,this.p=i,this.r=a||L1,this.d=l||this,this.set=u||cy,this.pr=c||0,this._next=t,t&&(t._prev=this)}var e=r.prototype;return e.modifier=function(n,i,s){this.mSet=this.mSet||this.set,this.set=KO,this.m=n,this.mt=s,this.tween=i},r}();Cr(oy+"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",function(r){return sy[r]=1});Hr.TweenMax=Hr.TweenLite=In;Hr.TimelineLite=Hr.TimelineMax=Mr;pn=new Mr({sortChildren:!1,defaults:zl,autoRemoveChildren:!0,id:"root",smoothChildTiming:!0});Wr.stringFilter=E1;var Gl=[],Rh={},XO=[],Db=0,ip=function(e){return(Rh[e]||XO).map(function(t){return t()})},hm=function(){var e=Date.now(),t=[];e-Db>2&&(ip("matchMediaInit"),Gl.forEach(function(n){var i=n.queries,s=n.conditions,o,a,l,u;for(a in i)o=ai.matchMedia(i[a]).matches,o&&(l=1),o!==s[a]&&(s[a]=o,u=1);u&&(n.revert(),l&&t.push(n))}),ip("matchMediaRevert"),t.forEach(function(n){return n.onMatch(n)}),Db=e,ip("matchMedia"))},F1=function(){function r(t,n){this.selector=n&&lm(n),this.data=[],this._r=[],this.isReverted=!1,t&&this.add(t)}var e=r.prototype;return e.add=function(n,i,s){_n(n)&&(s=i,i=n,n=_n);var o=this,a=function(){var u=Tn,c=o.selector,h;return u&&u!==o&&u.data.push(o),s&&(o.selector=lm(s)),Tn=o,h=i.apply(o,arguments),_n(h)&&o._r.push(h),Tn=u,o.selector=c,o.isReverted=!1,h};return o.last=a,n===_n?a(o):n?o[n]=a:a},e.ignore=function(n){var i=Tn;Tn=null,n(this),Tn=i},e.getTweens=function(){var n=[];return this.data.forEach(function(i){return i instanceof r?n.push.apply(n,i.getTweens()):i instanceof In&&!(i.parent&&i.parent.data==="nested")&&n.push(i)}),n},e.clear=function(){this._r.length=this.data.length=0},e.kill=function(n,i){var s=this;if(n){var o=this.getTweens();this.data.forEach(function(l){l.data==="isFlip"&&(l.revert(),l.getChildren(!0,!0,!1).forEach(function(u){return o.splice(o.indexOf(u),1)}))}),o.map(function(l){return{g:l.globalTime(0),t:l}}).sort(function(l,u){return u.g-l.g||-1}).forEach(function(l){return l.t.revert(n)}),this.data.forEach(function(l){return!(l instanceof Wl)&&l.revert&&l.revert(n)}),this._r.forEach(function(l){return l(n,s)}),this.isReverted=!0}else this.data.forEach(function(l){return l.kill&&l.kill()});if(this.clear(),i){var a=Gl.indexOf(this);~a&&Gl.splice(a,1)}},e.revert=function(n){this.kill(n||{})},r}(),YO=function(){function r(t){this.contexts=[],this.scope=t}var e=r.prototype;return e.add=function(n,i,s){is(n)||(n={matches:n});var o=new F1(0,s||this.scope),a=o.conditions={},l,u,c;this.contexts.push(o),i=o.add("onMatch",i),o.queries=n;for(u in n)u==="all"?c=1:(l=ai.matchMedia(n[u]),l&&(Gl.indexOf(o)<0&&Gl.push(o),(a[u]=l.matches)&&(c=1),l.addListener?l.addListener(hm):l.addEventListener("change",hm)));return c&&i(o),this},e.revert=function(n){this.kill(n||{})},e.kill=function(n){this.contexts.forEach(function(i){return i.kill(n,!0)})},r}(),Xh={registerPlugin:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];t.forEach(function(i){return NO(i)})},timeline:function(e){return new Mr(e)},getTweensOf:function(e,t){return pn.getTweensOf(e,t)},getProperty:function(e,t,n,i){$n(e)&&(e=pi(e)[0]);var s=ha(e||{}).get,o=n?h1:c1;return n==="native"&&(n=""),e&&(t?o((zr[t]&&zr[t].get||s)(e,t,n,i)):function(a,l,u){return o((zr[a]&&zr[a].get||s)(e,a,l,u))})},quickSetter:function(e,t,n){if(e=pi(e),e.length>1){var i=e.map(function(c){return jr.quickSetter(c,t,n)}),s=i.length;return function(c){for(var h=s;h--;)i[h](c)}}e=e[0]||{};var o=zr[t],a=ha(e),l=a.harness&&(a.harness.aliases||{})[t]||t,u=o?function(c){var h=new o;ml._pt=0,h.init(e,n?c+n:c,ml,0,[e]),h.render(1,h),ml._pt&&fy(1,ml)}:a.set(e,l);return o?u:function(c){return u(e,l,n?c+n:c,a,1)}},quickTo:function(e,t,n){var i,s=jr.to(e,Sa((i={},i[t]="+=0.1",i.paused=!0,i),n||{})),o=function(l,u,c){return s.resetTo(t,l,u,c)};return o.tween=s,o},isTweening:function(e){return pn.getTweensOf(e,!0).length>0},defaults:function(e){return e&&e.ease&&(e.ease=da(e.ease,zl.ease)),kb(zl,e||{})},config:function(e){return kb(Wr,e||{})},registerEffect:function(e){var t=e.name,n=e.effect,i=e.plugins,s=e.defaults,o=e.extendTimeline;(i||"").split(",").forEach(function(a){return a&&!zr[a]&&!Hr[a]&&Hh(t+" effect requires "+a+" plugin.")}),ep[t]=function(a,l,u){return n(pi(a),wi(l||{},s),u)},o&&(Mr.prototype[t]=function(a,l,u){return this.add(ep[t](a,is(l)?l:(u=l)&&{},this),u)})},registerEase:function(e,t){Rt[e]=da(t)},parseEase:function(e,t){return arguments.length?da(e,t):Rt},getById:function(e){return pn.getById(e)},exportRoot:function(e,t){e===void 0&&(e={});var n=new Mr(e),i,s;for(n.smoothChildTiming=Ir(e.smoothChildTiming),pn.remove(n),n._dp=0,n._time=n._tTime=pn._time,i=pn._first;i;)s=i._next,(t||!(!i._dur&&i instanceof In&&i.vars.onComplete===i._targets[0]))&&Yi(n,i,i._start-i._delay),i=s;return Yi(pn,n,0),n},context:function(e,t){return e?new F1(e,t):Tn},matchMedia:function(e){return new YO(e)},matchMediaRefresh:function(){return Gl.forEach(function(e){var t=e.conditions,n,i;for(i in t)t[i]&&(t[i]=!1,n=1);n&&e.revert()})||hm()},addEventListener:function(e,t){var n=Rh[e]||(Rh[e]=[]);~n.indexOf(t)||n.push(t)},removeEventListener:function(e,t){var n=Rh[e],i=n&&n.indexOf(t);i>=0&&n.splice(i,1)},utils:{wrap:IO,wrapYoyo:CO,distribute:_1,random:x1,snap:b1,normalize:AO,getUnit:nr,clamp:SO,splitColor:S1,toArray:pi,selector:lm,mapRange:w1,pipe:EO,unitize:MO,interpolate:kO,shuffle:y1},install:s1,effects:ep,ticker:Br,updateRoot:Mr.updateRoot,plugins:zr,globalTimeline:pn,core:{PropTween:kr,globals:o1,Tween:In,Timeline:Mr,Animation:Wl,getCache:ha,_removeLinkedListItem:Df,reverting:function(){return or},context:function(e){return e&&Tn&&(Tn.data.push(e),e._ctx=Tn),Tn},suppressOverwrites:function(e){return ty=e}}};Cr("to,from,fromTo,delayedCall,set,killTweensOf",function(r){return Xh[r]=In[r]});Br.add(Mr.updateRoot);ml=Xh.to({},{duration:0});var ZO=function(e,t){for(var n=e._pt;n&&n.p!==t&&n.op!==t&&n.fp!==t;)n=n._next;return n},QO=function(e,t){var n=e._targets,i,s,o;for(i in t)for(s=n.length;s--;)o=e._ptLookup[s][i],o&&(o=o.d)&&(o._pt&&(o=ZO(o,i)),o&&o.modifier&&o.modifier(t[i],e,n[s],i))},sp=function(e,t){return{name:e,rawVars:1,init:function(i,s,o){o._onInit=function(a){var l,u;if($n(s)&&(l={},Cr(s,function(c){return l[c]=1}),s=l),t){l={};for(u in s)l[u]=t(s[u]);s=l}QO(a,s)}}}},jr=Xh.registerPlugin({name:"attr",init:function(e,t,n,i,s){var o,a,l;this.tween=n;for(o in t)l=e.getAttribute(o)||"",a=this.add(e,"setAttribute",(l||0)+"",t[o],i,s,0,0,o),a.op=o,a.b=l,this._props.push(o)},render:function(e,t){for(var n=t._pt;n;)or?n.set(n.t,n.p,n.b,n):n.r(e,n.d),n=n._next}},{name:"endArray",init:function(e,t){for(var n=t.length;n--;)this.add(e,n,e[n]||0,t[n],0,0,0,0,0,1)}},sp("roundProps",um),sp("modifiers"),sp("snap",b1))||Xh;In.version=Mr.version=jr.version="3.11.4";i1=1;Jw()&&Vl();Rt.Power0;Rt.Power1;Rt.Power2;Rt.Power3;Rt.Power4;Rt.Linear;Rt.Quad;Rt.Cubic;Rt.Quart;Rt.Quint;Rt.Strong;Rt.Elastic;Rt.Back;Rt.SteppedEase;Rt.Bounce;Rt.Sine;Rt.Expo;Rt.Circ;/*!
 * CSSPlugin 3.11.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Ob,ao,Tl,dy,ra,Fb,py,JO=function(){return typeof window<"u"},Ls={},Ho=180/Math.PI,El=Math.PI/180,il=Math.atan2,$b=1e8,my=/([A-Z])/g,eF=/(left|right|width|margin|padding|x)/i,tF=/[\s,\(]\S/,Ts={autoAlpha:"opacity,visibility",scale:"scaleX,scaleY",alpha:"opacity"},fm=function(e,t){return t.set(t.t,t.p,Math.round((t.s+t.c*e)*1e4)/1e4+t.u,t)},nF=function(e,t){return t.set(t.t,t.p,e===1?t.e:Math.round((t.s+t.c*e)*1e4)/1e4+t.u,t)},rF=function(e,t){return t.set(t.t,t.p,e?Math.round((t.s+t.c*e)*1e4)/1e4+t.u:t.b,t)},iF=function(e,t){var n=t.s+t.c*e;t.set(t.t,t.p,~~(n+(n<0?-.5:.5))+t.u,t)},$1=function(e,t){return t.set(t.t,t.p,e?t.e:t.b,t)},z1=function(e,t){return t.set(t.t,t.p,e!==1?t.b:t.e,t)},sF=function(e,t,n){return e.style[t]=n},oF=function(e,t,n){return e.style.setProperty(t,n)},aF=function(e,t,n){return e._gsap[t]=n},lF=function(e,t,n){return e._gsap.scaleX=e._gsap.scaleY=n},uF=function(e,t,n,i,s){var o=e._gsap;o.scaleX=o.scaleY=n,o.renderTransform(s,o)},cF=function(e,t,n,i,s){var o=e._gsap;o[t]=n,o.renderTransform(s,o)},mn="transform",$i=mn+"Origin",hF=function(e,t){var n=this,i=this.target,s=i.style;if(e in Ls){if(this.tfm=this.tfm||{},e!=="transform"&&(e=Ts[e]||e,~e.indexOf(",")?e.split(",").forEach(function(o){return n.tfm[o]=gs(i,o)}):this.tfm[e]=i._gsap.x?i._gsap[e]:gs(i,e)),this.props.indexOf(mn)>=0)return;i._gsap.svg&&(this.svgo=i.getAttribute("data-svg-origin"),this.props.push($i,t,"")),e=mn}(s||t)&&this.props.push(e,t,s[e])},B1=function(e){e.translate&&(e.removeProperty("translate"),e.removeProperty("scale"),e.removeProperty("rotate"))},fF=function(){var e=this.props,t=this.target,n=t.style,i=t._gsap,s,o;for(s=0;s<e.length;s+=3)e[s+1]?t[e[s]]=e[s+2]:e[s+2]?n[e[s]]=e[s+2]:n.removeProperty(e[s].replace(my,"-$1").toLowerCase());if(this.tfm){for(o in this.tfm)i[o]=this.tfm[o];i.svg&&(i.renderTransform(),t.setAttribute("data-svg-origin",this.svgo||"")),s=py(),s&&!s.isStart&&!n[mn]&&(B1(n),i.uncache=1)}},U1=function(e,t){var n={target:e,props:[],revert:fF,save:hF};return t&&t.split(",").forEach(function(i){return n.save(i)}),n},V1,dm=function(e,t){var n=ao.createElementNS?ao.createElementNS((t||"http://www.w3.org/1999/xhtml").replace(/^https/,"http"),e):ao.createElement(e);return n.style?n:ao.createElement(e)},Ji=function r(e,t,n){var i=getComputedStyle(e);return i[t]||i.getPropertyValue(t.replace(my,"-$1").toLowerCase())||i.getPropertyValue(t)||!n&&r(e,Hl(t)||t,1)||""},zb="O,Moz,ms,Ms,Webkit".split(","),Hl=function(e,t,n){var i=t||ra,s=i.style,o=5;if(e in s&&!n)return e;for(e=e.charAt(0).toUpperCase()+e.substr(1);o--&&!(zb[o]+e in s););return o<0?null:(o===3?"ms":o>=0?zb[o]:"")+e},pm=function(){JO()&&window.document&&(Ob=window,ao=Ob.document,Tl=ao.documentElement,ra=dm("div")||{style:{}},dm("div"),mn=Hl(mn),$i=mn+"Origin",ra.style.cssText="border-width:0;line-height:0;position:absolute;padding:0",V1=!!Hl("perspective"),py=jr.core.reverting,dy=1)},op=function r(e){var t=dm("svg",this.ownerSVGElement&&this.ownerSVGElement.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),n=this.parentNode,i=this.nextSibling,s=this.style.cssText,o;if(Tl.appendChild(t),t.appendChild(this),this.style.display="block",e)try{o=this.getBBox(),this._gsapBBox=this.getBBox,this.getBBox=r}catch{}else this._gsapBBox&&(o=this._gsapBBox());return n&&(i?n.insertBefore(this,i):n.appendChild(this)),Tl.removeChild(t),this.style.cssText=s,o},Bb=function(e,t){for(var n=t.length;n--;)if(e.hasAttribute(t[n]))return e.getAttribute(t[n])},W1=function(e){var t;try{t=e.getBBox()}catch{t=op.call(e,!0)}return t&&(t.width||t.height)||e.getBBox===op||(t=op.call(e,!0)),t&&!t.width&&!t.x&&!t.y?{x:+Bb(e,["x","cx","x1"])||0,y:+Bb(e,["y","cy","y1"])||0,width:0,height:0}:t},G1=function(e){return!!(e.getCTM&&(!e.parentNode||e.ownerSVGElement)&&W1(e))},yc=function(e,t){if(t){var n=e.style;t in Ls&&t!==$i&&(t=mn),n.removeProperty?((t.substr(0,2)==="ms"||t.substr(0,6)==="webkit")&&(t="-"+t),n.removeProperty(t.replace(my,"-$1").toLowerCase())):n.removeAttribute(t)}},lo=function(e,t,n,i,s,o){var a=new kr(e._pt,t,n,0,1,o?z1:$1);return e._pt=a,a.b=i,a.e=s,e._props.push(n),a},Ub={deg:1,rad:1,turn:1},dF={grid:1,flex:1},To=function r(e,t,n,i){var s=parseFloat(n)||0,o=(n+"").trim().substr((s+"").length)||"px",a=ra.style,l=eF.test(t),u=e.tagName.toLowerCase()==="svg",c=(u?"client":"offset")+(l?"Width":"Height"),h=100,f=i==="px",d=i==="%",g,p,m,_;return i===o||!s||Ub[i]||Ub[o]?s:(o!=="px"&&!f&&(s=r(e,t,n,"px")),_=e.getCTM&&G1(e),(d||o==="%")&&(Ls[t]||~t.indexOf("adius"))?(g=_?e.getBBox()[l?"width":"height"]:e[c],vn(d?s/g*h:s/100*g)):(a[l?"width":"height"]=h+(f?o:i),p=~t.indexOf("adius")||i==="em"&&e.appendChild&&!u?e:e.parentNode,_&&(p=(e.ownerSVGElement||{}).parentNode),(!p||p===ao||!p.appendChild)&&(p=ao.body),m=p._gsap,m&&d&&m.width&&l&&m.time===Br.time&&!m.uncache?vn(s/m.width*h):((d||o==="%")&&!dF[Ji(p,"display")]&&(a.position=Ji(e,"position")),p===e&&(a.position="static"),p.appendChild(ra),g=ra[c],p.removeChild(ra),a.position="absolute",l&&d&&(m=ha(p),m.time=Br.time,m.width=p[c]),vn(f?g*s/h:g&&s?h/g*s:0))))},gs=function(e,t,n,i){var s;return dy||pm(),t in Ts&&t!=="transform"&&(t=Ts[t],~t.indexOf(",")&&(t=t.split(",")[0])),Ls[t]&&t!=="transform"?(s=bc(e,i),s=t!=="transformOrigin"?s[t]:s.svg?s.origin:Zh(Ji(e,$i))+" "+s.zOrigin+"px"):(s=e.style[t],(!s||s==="auto"||i||~(s+"").indexOf("calc("))&&(s=Yh[t]&&Yh[t](e,t,n)||Ji(e,t)||l1(e,t)||(t==="opacity"?1:0))),n&&!~(s+"").trim().indexOf(" ")?To(e,t,s,n)+n:s},pF=function(e,t,n,i){if(!n||n==="none"){var s=Hl(t,e,1),o=s&&Ji(e,s,1);o&&o!==n?(t=s,n=o):t==="borderColor"&&(n=Ji(e,"borderTopColor"))}var a=new kr(this._pt,e.style,t,0,1,D1),l=0,u=0,c,h,f,d,g,p,m,_,v,b,x,T;if(a.b=n,a.e=i,n+="",i+="",i==="auto"&&(e.style[t]=i,i=Ji(e,t)||i,e.style[t]=n),c=[n,i],E1(c),n=c[0],i=c[1],f=n.match(pl)||[],T=i.match(pl)||[],T.length){for(;h=pl.exec(i);)m=h[0],v=i.substring(l,h.index),g?g=(g+1)%5:(v.substr(-5)==="rgba("||v.substr(-5)==="hsla(")&&(g=1),m!==(p=f[u++]||"")&&(d=parseFloat(p)||0,x=p.substr((d+"").length),m.charAt(1)==="="&&(m=Sl(d,m)+x),_=parseFloat(m),b=m.substr((_+"").length),l=pl.lastIndex-b.length,b||(b=b||Wr.units[t]||x,l===i.length&&(i+=b,a.e+=b)),x!==b&&(d=To(e,t,p,b)||0),a._pt={_next:a._pt,p:v||u===1?v:",",s:d,c:_-d,m:g&&g<4||t==="zIndex"?Math.round:0});a.c=l<i.length?i.substring(l,i.length):""}else a.r=t==="display"&&i==="none"?z1:$1;return n1.test(i)&&(a.e=0),this._pt=a,a},Vb={top:"0%",bottom:"100%",left:"0%",right:"100%",center:"50%"},mF=function(e){var t=e.split(" "),n=t[0],i=t[1]||"50%";return(n==="top"||n==="bottom"||i==="left"||i==="right")&&(e=n,n=i,i=e),t[0]=Vb[n]||n,t[1]=Vb[i]||i,t.join(" ")},gF=function(e,t){if(t.tween&&t.tween._time===t.tween._dur){var n=t.t,i=n.style,s=t.u,o=n._gsap,a,l,u;if(s==="all"||s===!0)i.cssText="",l=1;else for(s=s.split(","),u=s.length;--u>-1;)a=s[u],Ls[a]&&(l=1,a=a==="transformOrigin"?$i:mn),yc(n,a);l&&(yc(n,mn),o&&(o.svg&&n.removeAttribute("transform"),bc(n,1),o.uncache=1,B1(i)))}},Yh={clearProps:function(e,t,n,i,s){if(s.data!=="isFromStart"){var o=e._pt=new kr(e._pt,t,n,0,0,gF);return o.u=i,o.pr=-10,o.tween=s,e._props.push(n),1}}},_c=[1,0,0,1,0,0],H1={},j1=function(e){return e==="matrix(1, 0, 0, 1, 0, 0)"||e==="none"||!e},Wb=function(e){var t=Ji(e,mn);return j1(t)?_c:t.substr(7).match(t1).map(vn)},gy=function(e,t){var n=e._gsap||ha(e),i=e.style,s=Wb(e),o,a,l,u;return n.svg&&e.getAttribute("transform")?(l=e.transform.baseVal.consolidate().matrix,s=[l.a,l.b,l.c,l.d,l.e,l.f],s.join(",")==="1,0,0,1,0,0"?_c:s):(s===_c&&!e.offsetParent&&e!==Tl&&!n.svg&&(l=i.display,i.display="block",o=e.parentNode,(!o||!e.offsetParent)&&(u=1,a=e.nextElementSibling,Tl.appendChild(e)),s=Wb(e),l?i.display=l:yc(e,"display"),u&&(a?o.insertBefore(e,a):o?o.appendChild(e):Tl.removeChild(e))),t&&s.length>6?[s[0],s[1],s[4],s[5],s[12],s[13]]:s)},mm=function(e,t,n,i,s,o){var a=e._gsap,l=s||gy(e,!0),u=a.xOrigin||0,c=a.yOrigin||0,h=a.xOffset||0,f=a.yOffset||0,d=l[0],g=l[1],p=l[2],m=l[3],_=l[4],v=l[5],b=t.split(" "),x=parseFloat(b[0])||0,T=parseFloat(b[1])||0,I,C,S,A;n?l!==_c&&(C=d*m-g*p)&&(S=x*(m/C)+T*(-p/C)+(p*v-m*_)/C,A=x*(-g/C)+T*(d/C)-(d*v-g*_)/C,x=S,T=A):(I=W1(e),x=I.x+(~b[0].indexOf("%")?x/100*I.width:x),T=I.y+(~(b[1]||b[0]).indexOf("%")?T/100*I.height:T)),i||i!==!1&&a.smooth?(_=x-u,v=T-c,a.xOffset=h+(_*d+v*p)-_,a.yOffset=f+(_*g+v*m)-v):a.xOffset=a.yOffset=0,a.xOrigin=x,a.yOrigin=T,a.smooth=!!i,a.origin=t,a.originIsAbsolute=!!n,e.style[$i]="0px 0px",o&&(lo(o,a,"xOrigin",u,x),lo(o,a,"yOrigin",c,T),lo(o,a,"xOffset",h,a.xOffset),lo(o,a,"yOffset",f,a.yOffset)),e.setAttribute("data-svg-origin",x+" "+T)},bc=function(e,t){var n=e._gsap||new C1(e);if("x"in n&&!t&&!n.uncache)return n;var i=e.style,s=n.scaleX<0,o="px",a="deg",l=getComputedStyle(e),u=Ji(e,$i)||"0",c,h,f,d,g,p,m,_,v,b,x,T,I,C,S,A,R,F,q,O,z,H,Q,Z,Y,fe,le,ve,ee,_e,Te,ne;return c=h=f=p=m=_=v=b=x=0,d=g=1,n.svg=!!(e.getCTM&&G1(e)),l.translate&&((l.translate!=="none"||l.scale!=="none"||l.rotate!=="none")&&(i[mn]=(l.translate!=="none"?"translate3d("+(l.translate+" 0 0").split(" ").slice(0,3).join(", ")+") ":"")+(l.rotate!=="none"?"rotate("+l.rotate+") ":"")+(l.scale!=="none"?"scale("+l.scale.split(" ").join(",")+") ":"")+(l[mn]!=="none"?l[mn]:"")),i.scale=i.rotate=i.translate="none"),C=gy(e,n.svg),n.svg&&(n.uncache?(Y=e.getBBox(),u=n.xOrigin-Y.x+"px "+(n.yOrigin-Y.y)+"px",Z=""):Z=!t&&e.getAttribute("data-svg-origin"),mm(e,Z||u,!!Z||n.originIsAbsolute,n.smooth!==!1,C)),T=n.xOrigin||0,I=n.yOrigin||0,C!==_c&&(F=C[0],q=C[1],O=C[2],z=C[3],c=H=C[4],h=Q=C[5],C.length===6?(d=Math.sqrt(F*F+q*q),g=Math.sqrt(z*z+O*O),p=F||q?il(q,F)*Ho:0,v=O||z?il(O,z)*Ho+p:0,v&&(g*=Math.abs(Math.cos(v*El))),n.svg&&(c-=T-(T*F+I*O),h-=I-(T*q+I*z))):(ne=C[6],_e=C[7],le=C[8],ve=C[9],ee=C[10],Te=C[11],c=C[12],h=C[13],f=C[14],S=il(ne,ee),m=S*Ho,S&&(A=Math.cos(-S),R=Math.sin(-S),Z=H*A+le*R,Y=Q*A+ve*R,fe=ne*A+ee*R,le=H*-R+le*A,ve=Q*-R+ve*A,ee=ne*-R+ee*A,Te=_e*-R+Te*A,H=Z,Q=Y,ne=fe),S=il(-O,ee),_=S*Ho,S&&(A=Math.cos(-S),R=Math.sin(-S),Z=F*A-le*R,Y=q*A-ve*R,fe=O*A-ee*R,Te=z*R+Te*A,F=Z,q=Y,O=fe),S=il(q,F),p=S*Ho,S&&(A=Math.cos(S),R=Math.sin(S),Z=F*A+q*R,Y=H*A+Q*R,q=q*A-F*R,Q=Q*A-H*R,F=Z,H=Y),m&&Math.abs(m)+Math.abs(p)>359.9&&(m=p=0,_=180-_),d=vn(Math.sqrt(F*F+q*q+O*O)),g=vn(Math.sqrt(Q*Q+ne*ne)),S=il(H,Q),v=Math.abs(S)>2e-4?S*Ho:0,x=Te?1/(Te<0?-Te:Te):0),n.svg&&(Z=e.getAttribute("transform"),n.forceCSS=e.setAttribute("transform","")||!j1(Ji(e,mn)),Z&&e.setAttribute("transform",Z))),Math.abs(v)>90&&Math.abs(v)<270&&(s?(d*=-1,v+=p<=0?180:-180,p+=p<=0?180:-180):(g*=-1,v+=v<=0?180:-180)),t=t||n.uncache,n.x=c-((n.xPercent=c&&(!t&&n.xPercent||(Math.round(e.offsetWidth/2)===Math.round(-c)?-50:0)))?e.offsetWidth*n.xPercent/100:0)+o,n.y=h-((n.yPercent=h&&(!t&&n.yPercent||(Math.round(e.offsetHeight/2)===Math.round(-h)?-50:0)))?e.offsetHeight*n.yPercent/100:0)+o,n.z=f+o,n.scaleX=vn(d),n.scaleY=vn(g),n.rotation=vn(p)+a,n.rotationX=vn(m)+a,n.rotationY=vn(_)+a,n.skewX=v+a,n.skewY=b+a,n.transformPerspective=x+o,(n.zOrigin=parseFloat(u.split(" ")[2])||0)&&(i[$i]=Zh(u)),n.xOffset=n.yOffset=0,n.force3D=Wr.force3D,n.renderTransform=n.svg?_F:V1?q1:yF,n.uncache=0,n},Zh=function(e){return(e=e.split(" "))[0]+" "+e[1]},ap=function(e,t,n){var i=nr(t);return vn(parseFloat(t)+parseFloat(To(e,"x",n+"px",i)))+i},yF=function(e,t){t.z="0px",t.rotationY=t.rotationX="0deg",t.force3D=0,q1(e,t)},zo="0deg",Iu="0px",Bo=") ",q1=function(e,t){var n=t||this,i=n.xPercent,s=n.yPercent,o=n.x,a=n.y,l=n.z,u=n.rotation,c=n.rotationY,h=n.rotationX,f=n.skewX,d=n.skewY,g=n.scaleX,p=n.scaleY,m=n.transformPerspective,_=n.force3D,v=n.target,b=n.zOrigin,x="",T=_==="auto"&&e&&e!==1||_===!0;if(b&&(h!==zo||c!==zo)){var I=parseFloat(c)*El,C=Math.sin(I),S=Math.cos(I),A;I=parseFloat(h)*El,A=Math.cos(I),o=ap(v,o,C*A*-b),a=ap(v,a,-Math.sin(I)*-b),l=ap(v,l,S*A*-b+b)}m!==Iu&&(x+="perspective("+m+Bo),(i||s)&&(x+="translate("+i+"%, "+s+"%) "),(T||o!==Iu||a!==Iu||l!==Iu)&&(x+=l!==Iu||T?"translate3d("+o+", "+a+", "+l+") ":"translate("+o+", "+a+Bo),u!==zo&&(x+="rotate("+u+Bo),c!==zo&&(x+="rotateY("+c+Bo),h!==zo&&(x+="rotateX("+h+Bo),(f!==zo||d!==zo)&&(x+="skew("+f+", "+d+Bo),(g!==1||p!==1)&&(x+="scale("+g+", "+p+Bo),v.style[mn]=x||"translate(0, 0)"},_F=function(e,t){var n=t||this,i=n.xPercent,s=n.yPercent,o=n.x,a=n.y,l=n.rotation,u=n.skewX,c=n.skewY,h=n.scaleX,f=n.scaleY,d=n.target,g=n.xOrigin,p=n.yOrigin,m=n.xOffset,_=n.yOffset,v=n.forceCSS,b=parseFloat(o),x=parseFloat(a),T,I,C,S,A;l=parseFloat(l),u=parseFloat(u),c=parseFloat(c),c&&(c=parseFloat(c),u+=c,l+=c),l||u?(l*=El,u*=El,T=Math.cos(l)*h,I=Math.sin(l)*h,C=Math.sin(l-u)*-f,S=Math.cos(l-u)*f,u&&(c*=El,A=Math.tan(u-c),A=Math.sqrt(1+A*A),C*=A,S*=A,c&&(A=Math.tan(c),A=Math.sqrt(1+A*A),T*=A,I*=A)),T=vn(T),I=vn(I),C=vn(C),S=vn(S)):(T=h,S=f,I=C=0),(b&&!~(o+"").indexOf("px")||x&&!~(a+"").indexOf("px"))&&(b=To(d,"x",o,"px"),x=To(d,"y",a,"px")),(g||p||m||_)&&(b=vn(b+g-(g*T+p*C)+m),x=vn(x+p-(g*I+p*S)+_)),(i||s)&&(A=d.getBBox(),b=vn(b+i/100*A.width),x=vn(x+s/100*A.height)),A="matrix("+T+","+I+","+C+","+S+","+b+","+x+")",d.setAttribute("transform",A),v&&(d.style[mn]=A)},bF=function(e,t,n,i,s){var o=360,a=$n(s),l=parseFloat(s)*(a&&~s.indexOf("rad")?Ho:1),u=l-i,c=i+u+"deg",h,f;return a&&(h=s.split("_")[1],h==="short"&&(u%=o,u!==u%(o/2)&&(u+=u<0?o:-o)),h==="cw"&&u<0?u=(u+o*$b)%o-~~(u/o)*o:h==="ccw"&&u>0&&(u=(u-o*$b)%o-~~(u/o)*o)),e._pt=f=new kr(e._pt,t,n,i,u,nF),f.e=c,f.u="deg",e._props.push(n),f},Gb=function(e,t){for(var n in t)e[n]=t[n];return e},xF=function(e,t,n){var i=Gb({},n._gsap),s="perspective,force3D,transformOrigin,svgOrigin",o=n.style,a,l,u,c,h,f,d,g;i.svg?(u=n.getAttribute("transform"),n.setAttribute("transform",""),o[mn]=t,a=bc(n,1),yc(n,mn),n.setAttribute("transform",u)):(u=getComputedStyle(n)[mn],o[mn]=t,a=bc(n,1),o[mn]=u);for(l in Ls)u=i[l],c=a[l],u!==c&&s.indexOf(l)<0&&(d=nr(u),g=nr(c),h=d!==g?To(n,l,u,g):parseFloat(u),f=parseFloat(c),e._pt=new kr(e._pt,a,l,h,f-h,fm),e._pt.u=g||0,e._props.push(l));Gb(a,i)};Cr("padding,margin,Width,Radius",function(r,e){var t="Top",n="Right",i="Bottom",s="Left",o=(e<3?[t,n,i,s]:[t+s,t+n,i+n,i+s]).map(function(a){return e<2?r+a:"border"+a+r});Yh[e>1?"border"+r:r]=function(a,l,u,c,h){var f,d;if(arguments.length<4)return f=o.map(function(g){return gs(a,g,u)}),d=f.join(" "),d.split(f[0]).length===5?f[0]:d;f=(c+"").split(" "),d={},o.forEach(function(g,p){return d[g]=f[p]=f[p]||f[(p-1)/2|0]}),a.init(l,d,h)}});var K1={name:"css",register:pm,targetTest:function(e){return e.style&&e.nodeType},init:function(e,t,n,i,s){var o=this._props,a=e.style,l=n.vars.startAt,u,c,h,f,d,g,p,m,_,v,b,x,T,I,C,S;dy||pm(),this.styles=this.styles||U1(e),S=this.styles.props,this.tween=n;for(p in t)if(p!=="autoRound"&&(c=t[p],!(zr[p]&&k1(p,t,n,i,e,s)))){if(d=typeof c,g=Yh[p],d==="function"&&(c=c.call(n,i,e,s),d=typeof c),d==="string"&&~c.indexOf("random(")&&(c=mc(c)),g)g(this,e,p,c,n)&&(C=1);else if(p.substr(0,2)==="--")u=(getComputedStyle(e).getPropertyValue(p)+"").trim(),c+="",yo.lastIndex=0,yo.test(u)||(m=nr(u),_=nr(c)),_?m!==_&&(u=To(e,p,u,_)+_):m&&(c+=m),this.add(a,"setProperty",u,c,i,s,0,0,p),o.push(p),S.push(p,0,a[p]);else if(d!=="undefined"){if(l&&p in l?(u=typeof l[p]=="function"?l[p].call(n,i,e,s):l[p],$n(u)&&~u.indexOf("random(")&&(u=mc(u)),nr(u+"")||(u+=Wr.units[p]||nr(gs(e,p))||""),(u+"").charAt(1)==="="&&(u=gs(e,p))):u=gs(e,p),f=parseFloat(u),v=d==="string"&&c.charAt(1)==="="&&c.substr(0,2),v&&(c=c.substr(2)),h=parseFloat(c),p in Ts&&(p==="autoAlpha"&&(f===1&&gs(e,"visibility")==="hidden"&&h&&(f=0),S.push("visibility",0,a.visibility),lo(this,a,"visibility",f?"inherit":"hidden",h?"inherit":"hidden",!h)),p!=="scale"&&p!=="transform"&&(p=Ts[p],~p.indexOf(",")&&(p=p.split(",")[0]))),b=p in Ls,b){if(this.styles.save(p),x||(T=e._gsap,T.renderTransform&&!t.parseTransform||bc(e,t.parseTransform),I=t.smoothOrigin!==!1&&T.smooth,x=this._pt=new kr(this._pt,a,mn,0,1,T.renderTransform,T,0,-1),x.dep=1),p==="scale")this._pt=new kr(this._pt,T,"scaleY",T.scaleY,(v?Sl(T.scaleY,v+h):h)-T.scaleY||0,fm),this._pt.u=0,o.push("scaleY",p),p+="X";else if(p==="transformOrigin"){S.push($i,0,a[$i]),c=mF(c),T.svg?mm(e,c,0,I,0,this):(_=parseFloat(c.split(" ")[2])||0,_!==T.zOrigin&&lo(this,T,"zOrigin",T.zOrigin,_),lo(this,a,p,Zh(u),Zh(c)));continue}else if(p==="svgOrigin"){mm(e,c,1,I,0,this);continue}else if(p in H1){bF(this,T,p,f,v?Sl(f,v+c):c);continue}else if(p==="smoothOrigin"){lo(this,T,"smooth",T.smooth,c);continue}else if(p==="force3D"){T[p]=c;continue}else if(p==="transform"){xF(this,c,e);continue}}else p in a||(p=Hl(p)||p);if(b||(h||h===0)&&(f||f===0)&&!tF.test(c)&&p in a)m=(u+"").substr((f+"").length),h||(h=0),_=nr(c)||(p in Wr.units?Wr.units[p]:m),m!==_&&(f=To(e,p,u,_)),this._pt=new kr(this._pt,b?T:a,p,f,(v?Sl(f,v+h):h)-f,!b&&(_==="px"||p==="zIndex")&&t.autoRound!==!1?iF:fm),this._pt.u=_||0,m!==_&&_!=="%"&&(this._pt.b=u,this._pt.r=rF);else if(p in a)pF.call(this,e,p,u,v?v+c:c);else if(p in e)this.add(e,p,u||e[p],v?v+c:c,i,s);else if(p!=="parseTransform"){iy(p,c);continue}b||(p in a?S.push(p,0,a[p]):S.push(p,1,u||e[p])),o.push(p)}}C&&O1(this)},render:function(e,t){if(t.tween._time||!py())for(var n=t._pt;n;)n.r(e,n.d),n=n._next;else t.styles.revert()},get:gs,aliases:Ts,getSetter:function(e,t,n){var i=Ts[t];return i&&i.indexOf(",")<0&&(t=i),t in Ls&&t!==$i&&(e._gsap.x||gs(e,"x"))?n&&Fb===n?t==="scale"?lF:aF:(Fb=n||{})&&(t==="scale"?uF:cF):e.style&&!ny(e.style[t])?sF:~t.indexOf("-")?oF:hy(e,t)},core:{_removeProperty:yc,_getMatrix:gy}};jr.utils.checkPrefix=Hl;jr.core.getStyleSaver=U1;(function(r,e,t,n){var i=Cr(r+","+e+","+t,function(s){Ls[s]=1});Cr(e,function(s){Wr.units[s]="deg",H1[s]=1}),Ts[i[13]]=r+","+e,Cr(n,function(s){var o=s.split(":");Ts[o[1]]=i[o[0]]})})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent","rotation,rotationX,rotationY,skewX,skewY","transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective","0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");Cr("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",function(r){Wr.units[r]="px"});jr.registerPlugin(K1);var gm=jr.registerPlugin(K1)||jr;gm.core.Tween;function Hb(r,e){if(e===XC)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),r;if(e===Kp||e===Sw){let t=r.getIndex();if(t===null){const o=[],a=r.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);r.setIndex(o),t=r.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const n=t.count-2,i=[];if(e===Kp)for(let o=1;o<=n;o++)i.push(t.getX(0)),i.push(t.getX(o)),i.push(t.getX(o+1));else for(let o=0;o<n;o++)o%2===0?(i.push(t.getX(o)),i.push(t.getX(o+1)),i.push(t.getX(o+2))):(i.push(t.getX(o+2)),i.push(t.getX(o+1)),i.push(t.getX(o)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=r.clone();return s.setIndex(i),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),r}class vF extends Pc{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new MF(t)}),this.register(function(t){return new PF(t)}),this.register(function(t){return new LF(t)}),this.register(function(t){return new DF(t)}),this.register(function(t){return new IF(t)}),this.register(function(t){return new CF(t)}),this.register(function(t){return new kF(t)}),this.register(function(t){return new NF(t)}),this.register(function(t){return new EF(t)}),this.register(function(t){return new RF(t)}),this.register(function(t){return new AF(t)}),this.register(function(t){return new SF(t)}),this.register(function(t){return new OF(t)}),this.register(function(t){return new FF(t)})}load(e,t,n,i){const s=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=em.extractUrlBase(e),this.manager.itemStart(e);const a=function(u){i?i(u):console.error(u),s.manager.itemError(e),s.manager.itemEnd(e)},l=new Xw(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{s.parse(u,o,function(c){t(c),s.manager.itemEnd(e)},a)}catch(c){a(c)}},n,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){let s;const o={},a={},l=new TextDecoder;if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===X1){try{o[Lt.KHR_BINARY_GLTF]=new $F(e)}catch(h){i&&i(h);return}s=JSON.parse(o[Lt.KHR_BINARY_GLTF].content)}else s=JSON.parse(l.decode(e));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const u=new ZF(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](u);a[h.name]=h,o[h.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const h=s.extensionsUsed[c],f=s.extensionsRequired||[];switch(h){case Lt.KHR_MATERIALS_UNLIT:o[h]=new TF;break;case Lt.KHR_DRACO_MESH_COMPRESSION:o[h]=new zF(s,this.dracoLoader);break;case Lt.KHR_TEXTURE_TRANSFORM:o[h]=new BF;break;case Lt.KHR_MESH_QUANTIZATION:o[h]=new UF;break;default:f.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}u.setExtensions(o),u.setPlugins(a),u.parse(n,i)}parseAsync(e,t){const n=this;return new Promise(function(i,s){n.parse(e,t,i,s)})}}function wF(){let r={};return{get:function(e){return r[e]},add:function(e,t){r[e]=t},remove:function(e){delete r[e]},removeAll:function(){r={}}}}const Lt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class SF{constructor(e){this.parser=e,this.name=Lt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const s=t[n];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const s=t.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let u;const c=new gt(16777215);l.color!==void 0&&c.fromArray(l.color);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new jD(c),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new Yw(c),u.distance=h;break;case"spot":u=new WD(c),u.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,ro(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(u),t.cache.add(n,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,s=n.json.nodes[e],a=(s.extensions&&s.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return n._getNodeRef(t.cache,a,l)})}}class TF{constructor(){this.name=Lt.KHR_MATERIALS_UNLIT}getMaterialType(){return ta}extendParams(e,t,n){const i=[];e.color=new gt(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}s.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",s.baseColorTexture,$t))}return Promise.all(i)}}class EF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}}class MF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(n.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new mt(a,a)}return Promise.all(s)}}class AF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(n.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(n.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}class IF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new gt(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=i.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(n.assignTexture(t,"sheenColorMap",o.sheenColorTexture,$t)),o.sheenRoughnessTexture!==void 0&&s.push(n.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class CF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(n.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class kF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(n.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new gt(a[0],a[1],a[2]),Promise.all(s)}}class NF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class RF{constructor(e){this.parser=e,this.name=Lt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Pa}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(n.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new gt(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&s.push(n.assignTexture(t,"specularColorMap",o.specularColorTexture,$t)),Promise.all(s)}}class PF{constructor(e){this.parser=e,this.name=Lt.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}}class LF{constructor(e){this.parser=e,this.name=Lt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=i.images[o.source];let l=n.textureLoader;if(a.uri){const u=n.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class DF{constructor(e){this.parser=e,this.name=Lt.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=i.images[o.source];let l=n.textureLoader;if(a.uri){const u=n.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class OF{constructor(e){this.name=Lt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(a){const l=i.byteOffset||0,u=i.byteLength||0,c=i.count,h=i.byteStride,f=new Uint8Array(a,l,u);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(c,h,f,i.mode,i.filter).then(function(d){return d.buffer}):o.ready.then(function(){const d=new ArrayBuffer(c*h);return o.decodeGltfBuffer(new Uint8Array(d),c,h,f,i.mode,i.filter),d})})}else return null}}class FF{constructor(e){this.name=Lt.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=t.meshes[n.mesh];for(const u of i.primitives)if(u.mode!==li.TRIANGLES&&u.mode!==li.TRIANGLE_STRIP&&u.mode!==li.TRIANGLE_FAN&&u.mode!==void 0)return null;const o=n.extensions[this.name].attributes,a=[],l={};for(const u in o)a.push(this.parser.getDependency("accessor",o[u]).then(c=>(l[u]=c,l[u])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(u=>{const c=u.pop(),h=c.isGroup?c.children:[c],f=u[0].count,d=[];for(const g of h){const p=new Ct,m=new ie,_=new rs,v=new ie(1,1,1),b=new MD(g.geometry,g.material,f);for(let x=0;x<f;x++)l.TRANSLATION&&m.fromBufferAttribute(l.TRANSLATION,x),l.ROTATION&&_.fromBufferAttribute(l.ROTATION,x),l.SCALE&&v.fromBufferAttribute(l.SCALE,x),b.setMatrixAt(x,p.compose(m,_,v));for(const x in l)x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&g.geometry.setAttribute(x,l[x]);gn.prototype.copy.call(b,g),b.frustumCulled=!1,this.parser.assignFinalMaterial(b),d.push(b)}return c.isGroup?(c.clear(),c.add(...d),c):d[0]}))}}const X1="glTF",Cu=12,jb={JSON:1313821514,BIN:5130562};class $F{constructor(e){this.name=Lt.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Cu),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==X1)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-Cu,s=new DataView(e,Cu);let o=0;for(;o<i;){const a=s.getUint32(o,!0);o+=4;const l=s.getUint32(o,!0);if(o+=4,l===jb.JSON){const u=new Uint8Array(e,Cu+o,a);this.content=n.decode(u)}else if(l===jb.BIN){const u=Cu+o;this.body=e.slice(u,u+a)}o+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class zF{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Lt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},u={};for(const c in o){const h=ym[c]||c.toLowerCase();a[h]=o[c]}for(const c in e.attributes){const h=ym[c]||c.toLowerCase();if(o[c]!==void 0){const f=n.accessors[e.attributes[c]],d=Ml[f.componentType];u[h]=d.name,l[h]=f.normalized===!0}}return t.getDependency("bufferView",s).then(function(c){return new Promise(function(h){i.decodeDracoFile(c,function(f){for(const d in f.attributes){const g=f.attributes[d],p=l[d];p!==void 0&&(g.normalized=p)}h(f)},a,u)})})}}class BF{constructor(){this.name=Lt.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class UF{constructor(){this.name=Lt.KHR_MESH_QUANTIZATION}}class Y1 extends Rc{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let o=0;o!==i;o++)t[o]=n[s+o];return t}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,u=a*3,c=i-t,h=(n-t)/c,f=h*h,d=f*h,g=e*u,p=g-u,m=-2*d+3*f,_=d-f,v=1-m,b=_-f+h;for(let x=0;x!==a;x++){const T=o[p+x+a],I=o[p+x+l]*c,C=o[g+x+a],S=o[g+x]*c;s[x]=v*T+b*I+m*C+_*S}return s}}const VF=new rs;class WF extends Y1{interpolate_(e,t,n,i){const s=super.interpolate_(e,t,n,i);return VF.fromArray(s).normalize().toArray(s),s}}const li={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Ml={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},qb={9728:Fn,9729:Er,9984:qp,9985:vw,9986:Ih,9987:ya},Kb={33071:hi,33648:Wh,10497:Ll},lp={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ym={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},to={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},GF={CUBICSPLINE:void 0,LINEAR:Ol,STEP:lc},up={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function HF(r){return r.DefaultMaterial===void 0&&(r.DefaultMaterial=new Pf({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Rs})),r.DefaultMaterial}function ku(r,e,t){for(const n in t.extensions)r[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function ro(r,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(r.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function jF(r,e,t){let n=!1,i=!1,s=!1;for(let u=0,c=e.length;u<c;u++){const h=e[u];if(h.POSITION!==void 0&&(n=!0),h.NORMAL!==void 0&&(i=!0),h.COLOR_0!==void 0&&(s=!0),n&&i&&s)break}if(!n&&!i&&!s)return Promise.resolve(r);const o=[],a=[],l=[];for(let u=0,c=e.length;u<c;u++){const h=e[u];if(n){const f=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):r.attributes.position;o.push(f)}if(i){const f=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):r.attributes.normal;a.push(f)}if(s){const f=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):r.attributes.color;l.push(f)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(u){const c=u[0],h=u[1],f=u[2];return n&&(r.morphAttributes.position=c),i&&(r.morphAttributes.normal=h),s&&(r.morphAttributes.color=f),r.morphTargetsRelative=!0,r})}function qF(r,e){if(r.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)r.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(r.morphTargetInfluences.length===t.length){r.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)r.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function KF(r){const e=r.extensions&&r.extensions[Lt.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+Xb(e.attributes):t=r.indices+":"+Xb(r.attributes)+":"+r.mode,t}function Xb(r){let e="";const t=Object.keys(r).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+r[t[n]]+";";return e}function _m(r){switch(r){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function XF(r){return r.search(/\.jpe?g($|\?)/i)>0||r.search(/^data\:image\/jpeg/)===0?"image/jpeg":r.search(/\.webp($|\?)/i)>0||r.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const YF=new Ct;class ZF{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new wF,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=!1,s=-1;typeof navigator<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,s=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||i&&s<98?this.textureLoader=new UD(this.options.manager):this.textureLoader=new KD(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Xw(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(o){const a={scene:o[0][i.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:i.asset,parser:n,userData:{}};ku(s,a,i),ro(a,i),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,s=t.length;i<s;i++){const o=t[i].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const o=e[i];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(n[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[u,c]of o.children.entries())s(c,a.children[u])};return s(n,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const s=e(t[i]);s&&n.push(s)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(s,o){return n.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Lt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,o){n.load(em.resolveURL(t.uri,i.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,s=t.byteOffset||0;return n.slice(s,s+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const o=lp[i.type],a=Ml[i.componentType],l=i.normalized===!0,u=new a(i.count*o);return Promise.resolve(new _r(u,o,l))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=lp[i.type],u=Ml[i.componentType],c=u.BYTES_PER_ELEMENT,h=c*l,f=i.byteOffset||0,d=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,g=i.normalized===!0;let p,m;if(d&&d!==h){const _=Math.floor(f/d),v="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+_+":"+i.count;let b=t.cache.get(v);b||(p=new u(a,_*d,i.count*d/c),b=new xD(p,d/c),t.cache.add(v,b)),m=new qg(b,l,f%d/c,g)}else a===null?p=new u(i.count*l):p=new u(a,f,i.count*l),m=new _r(p,l,g);if(i.sparse!==void 0){const _=lp.SCALAR,v=Ml[i.sparse.indices.componentType],b=i.sparse.indices.byteOffset||0,x=i.sparse.values.byteOffset||0,T=new v(o[1],b,i.sparse.count*_),I=new u(o[2],x,i.sparse.count*l);a!==null&&(m=new _r(m.array.slice(),m.itemSize,m.normalized));for(let C=0,S=T.length;C<S;C++){const A=T[C];if(m.setX(A,I[C*l]),l>=2&&m.setY(A,I[C*l+1]),l>=3&&m.setZ(A,I[C*l+2]),l>=4&&m.setW(A,I[C*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(e){const t=this.json,n=this.options,s=t.textures[e].source,o=t.images[s];let a=this.textureLoader;if(o.uri){const l=n.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,t,n){const i=this,s=this.json,o=s.textures[e],a=s.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(t,n).then(function(c){c.flipY=!1,c.name=o.name||a.name||"";const f=(s.samplers||{})[o.sampler]||{};return c.magFilter=qb[f.magFilter]||Er,c.minFilter=qb[f.minFilter]||ya,c.wrapS=Kb[f.wrapS]||Ll,c.wrapT=Kb[f.wrapT]||Ll,i.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,t){const n=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const o=i.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",u=!1;if(o.bufferView!==void 0)l=n.getDependency("bufferView",o.bufferView).then(function(h){u=!0;const f=new Blob([h],{type:o.mimeType});return l=a.createObjectURL(f),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(h){return new Promise(function(f,d){let g=f;t.isImageBitmapLoader===!0&&(g=function(p){const m=new Hn(p);m.needsUpdate=!0,f(m)}),t.load(em.resolveURL(h,s.path),g,void 0,d)})}).then(function(h){return u===!0&&a.revokeObjectURL(l),h.userData.mimeType=o.mimeType||XF(o.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),h});return this.sourceCache[e]=c,c}assignTexture(e,t,n,i){const s=this;return this.getDependency("texture",n.index).then(function(o){if(!o)return null;if(n.texCoord!==void 0&&n.texCoord!=0&&!(t==="aoMap"&&n.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),s.extensions[Lt.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[Lt.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[Lt.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return i!==void 0&&(o.encoding=i),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const i=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+n.uuid;let l=this.cache.get(a);l||(l=new Hw,Qi.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,l.sizeAttenuation=!1,this.cache.add(a,l)),n=l}else if(e.isLine){const a="LineBasicMaterial:"+n.uuid;let l=this.cache.get(a);l||(l=new Rf,Qi.prototype.copy.call(l,n),l.color.copy(n.color),this.cache.add(a,l)),n=l}if(i||s||o){let a="ClonedMaterial:"+n.uuid+":";i&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=n.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(n))),n=l}n.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return Pf}loadMaterial(e){const t=this,n=this.json,i=this.extensions,s=n.materials[e];let o;const a={},l=s.extensions||{},u=[];if(l[Lt.KHR_MATERIALS_UNLIT]){const h=i[Lt.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),u.push(h.extendParams(a,s,t))}else{const h=s.pbrMetallicRoughness||{};if(a.color=new gt(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const f=h.baseColorFactor;a.color.fromArray(f),a.opacity=f[3]}h.baseColorTexture!==void 0&&u.push(t.assignTexture(a,"map",h.baseColorTexture,$t)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),u.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(f){return f.getMaterialType&&f.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(f){return f.extendMaterialParams&&f.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=ws);const c=s.alphaMode||up.OPAQUE;if(c===up.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,c===up.MASK&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==ta&&(u.push(t.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new mt(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;a.normalScale.set(h,h)}return s.occlusionTexture!==void 0&&o!==ta&&(u.push(t.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==ta&&(a.emissive=new gt().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&o!==ta&&u.push(t.assignTexture(a,"emissiveMap",s.emissiveTexture,$t)),Promise.all(u).then(function(){const h=new o(a);return s.name&&(h.name=s.name),ro(h,s),t.associations.set(h,{materials:e}),s.extensions&&ku(i,h,s),h})}createUniqueName(e){const t=Ut.sanitizeNodeName(e||"");let n=t;for(let i=1;this.nodeNamesUsed[n];++i)n=t+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function s(a){return n[Lt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return Yb(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const u=e[a],c=KF(u),h=i[c];if(h)o.push(h.promise);else{let f;u.extensions&&u.extensions[Lt.KHR_DRACO_MESH_COMPRESSION]?f=s(u):f=Yb(new Kr,u,t),i[c]={primitive:u,promise:f},o.push(f)}}return Promise.all(o)}loadMesh(e){const t=this,n=this.json,i=this.extensions,s=n.meshes[e],o=s.primitives,a=[];for(let l=0,u=o.length;l<u;l++){const c=o[l].material===void 0?HF(this.cache):this.getDependency("material",o[l].material);a.push(c)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const u=l.slice(0,l.length-1),c=l[l.length-1],h=[];for(let d=0,g=c.length;d<g;d++){const p=c[d],m=o[d];let _;const v=u[d];if(m.mode===li.TRIANGLES||m.mode===li.TRIANGLE_STRIP||m.mode===li.TRIANGLE_FAN||m.mode===void 0)_=s.isSkinnedMesh===!0?new wD(p,v):new Ur(p,v),_.isSkinnedMesh===!0&&_.normalizeSkinWeights(),m.mode===li.TRIANGLE_STRIP?_.geometry=Hb(_.geometry,Sw):m.mode===li.TRIANGLE_FAN&&(_.geometry=Hb(_.geometry,Kp));else if(m.mode===li.LINES)_=new Yg(p,v);else if(m.mode===li.LINE_STRIP)_=new Xg(p,v);else if(m.mode===li.LINE_LOOP)_=new AD(p,v);else if(m.mode===li.POINTS)_=new ID(p,v);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(_.geometry.morphAttributes).length>0&&qF(_,s),_.name=t.createUniqueName(s.name||"mesh_"+e),ro(_,s),m.extensions&&ku(i,_,m),t.assignFinalMaterial(_),h.push(_)}for(let d=0,g=h.length;d<g;d++)t.associations.set(h[d],{meshes:e,primitives:d});if(h.length===1)return h[0];const f=new na;t.associations.set(f,{meshes:e});for(let d=0,g=h.length;d<g;d++)f.add(h[d]);return f})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new dr(dk.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new Gg(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),ro(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let i=0,s=t.joints.length;i<s;i++)n.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const s=i.pop(),o=i,a=[],l=[];for(let u=0,c=o.length;u<c;u++){const h=o[u];if(h){a.push(h);const f=new Ct;s!==null&&f.fromArray(s.array,u*16),l.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new Kg(a,l)})}loadAnimation(e){const n=this.json.animations[e],i=[],s=[],o=[],a=[],l=[];for(let u=0,c=n.channels.length;u<c;u++){const h=n.channels[u],f=n.samplers[h.sampler],d=h.target,g=d.node,p=n.parameters!==void 0?n.parameters[f.input]:f.input,m=n.parameters!==void 0?n.parameters[f.output]:f.output;i.push(this.getDependency("node",g)),s.push(this.getDependency("accessor",p)),o.push(this.getDependency("accessor",m)),a.push(f),l.push(d)}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(u){const c=u[0],h=u[1],f=u[2],d=u[3],g=u[4],p=[];for(let _=0,v=c.length;_<v;_++){const b=c[_],x=h[_],T=f[_],I=d[_],C=g[_];if(b===void 0)continue;b.updateMatrix();let S;switch(to[C.path]){case to.weights:S=fc;break;case to.rotation:S=wa;break;case to.position:case to.scale:default:S=dc;break}const A=b.name?b.name:b.uuid,R=I.interpolation!==void 0?GF[I.interpolation]:Ol,F=[];to[C.path]===to.weights?b.traverse(function(O){O.morphTargetInfluences&&F.push(O.name?O.name:O.uuid)}):F.push(A);let q=T.array;if(T.normalized){const O=_m(q.constructor),z=new Float32Array(q.length);for(let H=0,Q=q.length;H<Q;H++)z[H]=q[H]*O;q=z}for(let O=0,z=F.length;O<z;O++){const H=new S(F[O]+"."+to[C.path],x.array,q,R);I.interpolation==="CUBICSPLINE"&&(H.createInterpolant=function(Z){const Y=this instanceof wa?WF:Y1;return new Y(this.times,this.values,this.getValueSize()/3,Z)},H.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),p.push(H)}}const m=n.name?n.name:"animation_"+e;return new LD(m,void 0,p)})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(s){const o=n._getNodeRef(n.meshCache,i.mesh,s);return i.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,u=i.weights.length;l<u;l++)a.morphTargetInfluences[l]=i.weights[l]}),o})}loadNode(e){const t=this.json,n=this,i=t.nodes[e],s=n._loadNodeShallow(e),o=[],a=i.children||[];for(let u=0,c=a.length;u<c;u++)o.push(n.getDependency("node",a[u]));const l=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([s,Promise.all(o),l]).then(function(u){const c=u[0],h=u[1],f=u[2];f!==null&&c.traverse(function(d){d.isSkinnedMesh&&d.bind(f,YF)});for(let d=0,g=h.length;d<g;d++)c.add(h[d]);return c})}_loadNodeShallow(e){const t=this.json,n=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],o=s.name?i.createUniqueName(s.name):"",a=[],l=i._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(i.getDependency("camera",s.camera).then(function(u){return i._getNodeRef(i.cameraCache,s.camera,u)})),i._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){a.push(u)}),this.nodeCache[e]=Promise.all(a).then(function(u){let c;if(s.isBone===!0?c=new Gw:u.length>1?c=new na:u.length===1?c=u[0]:c=new gn,c!==u[0])for(let h=0,f=u.length;h<f;h++)c.add(u[h]);if(s.name&&(c.userData.name=s.name,c.name=o),ro(c,s),s.extensions&&ku(n,c,s),s.matrix!==void 0){const h=new Ct;h.fromArray(s.matrix),c.applyMatrix4(h)}else s.translation!==void 0&&c.position.fromArray(s.translation),s.rotation!==void 0&&c.quaternion.fromArray(s.rotation),s.scale!==void 0&&c.scale.fromArray(s.scale);return i.associations.has(c)||i.associations.set(c,{}),i.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],i=this,s=new na;n.name&&(s.name=i.createUniqueName(n.name)),ro(s,n),n.extensions&&ku(t,s,n);const o=n.nodes||[],a=[];for(let l=0,u=o.length;l<u;l++)a.push(i.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let c=0,h=l.length;c<h;c++)s.add(l[c]);const u=c=>{const h=new Map;for(const[f,d]of i.associations)(f instanceof Qi||f instanceof Hn)&&h.set(f,d);return c.traverse(f=>{const d=i.associations.get(f);d!=null&&h.set(f,d)}),h};return i.associations=u(s),s})}}function QF(r,e,t){const n=e.attributes,i=new ru;if(n.POSITION!==void 0){const a=t.json.accessors[n.POSITION],l=a.min,u=a.max;if(l!==void 0&&u!==void 0){if(i.set(new ie(l[0],l[1],l[2]),new ie(u[0],u[1],u[2])),a.normalized){const c=_m(Ml[a.componentType]);i.min.multiplyScalar(c),i.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const a=new ie,l=new ie;for(let u=0,c=s.length;u<c;u++){const h=s[u];if(h.POSITION!==void 0){const f=t.json.accessors[h.POSITION],d=f.min,g=f.max;if(d!==void 0&&g!==void 0){if(l.setX(Math.max(Math.abs(d[0]),Math.abs(g[0]))),l.setY(Math.max(Math.abs(d[1]),Math.abs(g[1]))),l.setZ(Math.max(Math.abs(d[2]),Math.abs(g[2]))),f.normalized){const p=_m(Ml[f.componentType]);l.multiplyScalar(p)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(a)}r.boundingBox=i;const o=new iu;i.getCenter(o.center),o.radius=i.min.distanceTo(i.max)/2,r.boundingSphere=o}function Yb(r,e,t){const n=e.attributes,i=[];function s(o,a){return t.getDependency("accessor",o).then(function(l){r.setAttribute(a,l)})}for(const o in n){const a=ym[o]||o.toLowerCase();a in r.attributes||i.push(s(n[o],a))}if(e.indices!==void 0&&!r.index){const o=t.getDependency("accessor",e.indices).then(function(a){r.setIndex(a)});i.push(o)}return ro(r,e),QF(r,e,t),Promise.all(i).then(function(){return e.targets!==void 0?jF(r,e.targets,t):r})}const Zb={type:"change"},cp={type:"start"},Qb={type:"end"};class JF extends Ra{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new ie,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Wa.ROTATE,MIDDLE:Wa.DOLLY,RIGHT:Wa.PAN},this.touches={ONE:Ga.ROTATE,TWO:Ga.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(G){G.addEventListener("keydown",Se),this._domElementKeyEvents=G},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Se),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Zb),n.update(),s=i.NONE},this.update=function(){const G=new ie,se=new rs().setFromUnitVectors(e.up,new ie(0,1,0)),Be=se.clone().invert(),De=new ie,je=new rs,Xe=2*Math.PI;return function(){const ot=n.object.position;G.copy(ot).sub(n.target),G.applyQuaternion(se),a.setFromVector3(G),n.autoRotate&&s===i.NONE&&A(C()),n.enableDamping?(a.theta+=l.theta*n.dampingFactor,a.phi+=l.phi*n.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let xt=n.minAzimuthAngle,Ot=n.maxAzimuthAngle;return isFinite(xt)&&isFinite(Ot)&&(xt<-Math.PI?xt+=Xe:xt>Math.PI&&(xt-=Xe),Ot<-Math.PI?Ot+=Xe:Ot>Math.PI&&(Ot-=Xe),xt<=Ot?a.theta=Math.max(xt,Math.min(Ot,a.theta)):a.theta=a.theta>(xt+Ot)/2?Math.max(xt,a.theta):Math.min(Ot,a.theta)),a.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=u,a.radius=Math.max(n.minDistance,Math.min(n.maxDistance,a.radius)),n.enableDamping===!0?n.target.addScaledVector(c,n.dampingFactor):n.target.add(c),G.setFromSpherical(a),G.applyQuaternion(Be),ot.copy(n.target).add(G),n.object.lookAt(n.target),n.enableDamping===!0?(l.theta*=1-n.dampingFactor,l.phi*=1-n.dampingFactor,c.multiplyScalar(1-n.dampingFactor)):(l.set(0,0,0),c.set(0,0,0)),u=1,h||De.distanceToSquared(n.object.position)>o||8*(1-je.dot(n.object.quaternion))>o?(n.dispatchEvent(Zb),De.copy(n.object.position),je.copy(n.object.quaternion),h=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",re),n.domElement.removeEventListener("pointerdown",ae),n.domElement.removeEventListener("pointercancel",Ee),n.domElement.removeEventListener("wheel",ke),n.domElement.removeEventListener("pointermove",be),n.domElement.removeEventListener("pointerup",de),n._domElementKeyEvents!==null&&(n._domElementKeyEvents.removeEventListener("keydown",Se),n._domElementKeyEvents=null)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const o=1e-6,a=new Ib,l=new Ib;let u=1;const c=new ie;let h=!1;const f=new mt,d=new mt,g=new mt,p=new mt,m=new mt,_=new mt,v=new mt,b=new mt,x=new mt,T=[],I={};function C(){return 2*Math.PI/60/60*n.autoRotateSpeed}function S(){return Math.pow(.95,n.zoomSpeed)}function A(G){l.theta-=G}function R(G){l.phi-=G}const F=function(){const G=new ie;return function(Be,De){G.setFromMatrixColumn(De,0),G.multiplyScalar(-Be),c.add(G)}}(),q=function(){const G=new ie;return function(Be,De){n.screenSpacePanning===!0?G.setFromMatrixColumn(De,1):(G.setFromMatrixColumn(De,0),G.crossVectors(n.object.up,G)),G.multiplyScalar(Be),c.add(G)}}(),O=function(){const G=new ie;return function(Be,De){const je=n.domElement;if(n.object.isPerspectiveCamera){const Xe=n.object.position;G.copy(Xe).sub(n.target);let Ue=G.length();Ue*=Math.tan(n.object.fov/2*Math.PI/180),F(2*Be*Ue/je.clientHeight,n.object.matrix),q(2*De*Ue/je.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(F(Be*(n.object.right-n.object.left)/n.object.zoom/je.clientWidth,n.object.matrix),q(De*(n.object.top-n.object.bottom)/n.object.zoom/je.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function z(G){n.object.isPerspectiveCamera?u/=G:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*G)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function H(G){n.object.isPerspectiveCamera?u*=G:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/G)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function Q(G){f.set(G.clientX,G.clientY)}function Z(G){v.set(G.clientX,G.clientY)}function Y(G){p.set(G.clientX,G.clientY)}function fe(G){d.set(G.clientX,G.clientY),g.subVectors(d,f).multiplyScalar(n.rotateSpeed);const se=n.domElement;A(2*Math.PI*g.x/se.clientHeight),R(2*Math.PI*g.y/se.clientHeight),f.copy(d),n.update()}function le(G){b.set(G.clientX,G.clientY),x.subVectors(b,v),x.y>0?z(S()):x.y<0&&H(S()),v.copy(b),n.update()}function ve(G){m.set(G.clientX,G.clientY),_.subVectors(m,p).multiplyScalar(n.panSpeed),O(_.x,_.y),p.copy(m),n.update()}function ee(G){G.deltaY<0?H(S()):G.deltaY>0&&z(S()),n.update()}function _e(G){let se=!1;switch(G.code){case n.keys.UP:G.ctrlKey||G.metaKey||G.shiftKey?R(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):O(0,n.keyPanSpeed),se=!0;break;case n.keys.BOTTOM:G.ctrlKey||G.metaKey||G.shiftKey?R(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):O(0,-n.keyPanSpeed),se=!0;break;case n.keys.LEFT:G.ctrlKey||G.metaKey||G.shiftKey?A(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):O(n.keyPanSpeed,0),se=!0;break;case n.keys.RIGHT:G.ctrlKey||G.metaKey||G.shiftKey?A(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):O(-n.keyPanSpeed,0),se=!0;break}se&&(G.preventDefault(),n.update())}function Te(){if(T.length===1)f.set(T[0].pageX,T[0].pageY);else{const G=.5*(T[0].pageX+T[1].pageX),se=.5*(T[0].pageY+T[1].pageY);f.set(G,se)}}function ne(){if(T.length===1)p.set(T[0].pageX,T[0].pageY);else{const G=.5*(T[0].pageX+T[1].pageX),se=.5*(T[0].pageY+T[1].pageY);p.set(G,se)}}function Le(){const G=T[0].pageX-T[1].pageX,se=T[0].pageY-T[1].pageY,Be=Math.sqrt(G*G+se*se);v.set(0,Be)}function Ve(){n.enableZoom&&Le(),n.enablePan&&ne()}function He(){n.enableZoom&&Le(),n.enableRotate&&Te()}function We(G){if(T.length==1)d.set(G.pageX,G.pageY);else{const Be=Pe(G),De=.5*(G.pageX+Be.x),je=.5*(G.pageY+Be.y);d.set(De,je)}g.subVectors(d,f).multiplyScalar(n.rotateSpeed);const se=n.domElement;A(2*Math.PI*g.x/se.clientHeight),R(2*Math.PI*g.y/se.clientHeight),f.copy(d)}function Je(G){if(T.length===1)m.set(G.pageX,G.pageY);else{const se=Pe(G),Be=.5*(G.pageX+se.x),De=.5*(G.pageY+se.y);m.set(Be,De)}_.subVectors(m,p).multiplyScalar(n.panSpeed),O(_.x,_.y),p.copy(m)}function nt(G){const se=Pe(G),Be=G.pageX-se.x,De=G.pageY-se.y,je=Math.sqrt(Be*Be+De*De);b.set(0,je),x.set(0,Math.pow(b.y/v.y,n.zoomSpeed)),z(x.y),v.copy(b)}function U(G){n.enableZoom&&nt(G),n.enablePan&&Je(G)}function j(G){n.enableZoom&&nt(G),n.enableRotate&&We(G)}function ae(G){n.enabled!==!1&&(T.length===0&&(n.domElement.setPointerCapture(G.pointerId),n.domElement.addEventListener("pointermove",be),n.domElement.addEventListener("pointerup",de)),pe(G),G.pointerType==="touch"?L(G):Ae(G))}function be(G){n.enabled!==!1&&(G.pointerType==="touch"?N(G):we(G))}function de(G){ge(G),T.length===0&&(n.domElement.releasePointerCapture(G.pointerId),n.domElement.removeEventListener("pointermove",be),n.domElement.removeEventListener("pointerup",de)),n.dispatchEvent(Qb),s=i.NONE}function Ee(G){ge(G)}function Ae(G){let se;switch(G.button){case 0:se=n.mouseButtons.LEFT;break;case 1:se=n.mouseButtons.MIDDLE;break;case 2:se=n.mouseButtons.RIGHT;break;default:se=-1}switch(se){case Wa.DOLLY:if(n.enableZoom===!1)return;Z(G),s=i.DOLLY;break;case Wa.ROTATE:if(G.ctrlKey||G.metaKey||G.shiftKey){if(n.enablePan===!1)return;Y(G),s=i.PAN}else{if(n.enableRotate===!1)return;Q(G),s=i.ROTATE}break;case Wa.PAN:if(G.ctrlKey||G.metaKey||G.shiftKey){if(n.enableRotate===!1)return;Q(G),s=i.ROTATE}else{if(n.enablePan===!1)return;Y(G),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(cp)}function we(G){switch(s){case i.ROTATE:if(n.enableRotate===!1)return;fe(G);break;case i.DOLLY:if(n.enableZoom===!1)return;le(G);break;case i.PAN:if(n.enablePan===!1)return;ve(G);break}}function ke(G){n.enabled===!1||n.enableZoom===!1||s!==i.NONE||(G.preventDefault(),n.dispatchEvent(cp),ee(G),n.dispatchEvent(Qb))}function Se(G){n.enabled===!1||n.enablePan===!1||_e(G)}function L(G){switch(Me(G),T.length){case 1:switch(n.touches.ONE){case Ga.ROTATE:if(n.enableRotate===!1)return;Te(),s=i.TOUCH_ROTATE;break;case Ga.PAN:if(n.enablePan===!1)return;ne(),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(n.touches.TWO){case Ga.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Ve(),s=i.TOUCH_DOLLY_PAN;break;case Ga.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;He(),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(cp)}function N(G){switch(Me(G),s){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;We(G),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;Je(G),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;U(G),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;j(G),n.update();break;default:s=i.NONE}}function re(G){n.enabled!==!1&&G.preventDefault()}function pe(G){T.push(G)}function ge(G){delete I[G.pointerId];for(let se=0;se<T.length;se++)if(T[se].pointerId==G.pointerId){T.splice(se,1);return}}function Me(G){let se=I[G.pointerId];se===void 0&&(se=new mt,I[G.pointerId]=se),se.set(G.pageX,G.pageY)}function Pe(G){const se=G.pointerId===T[0].pointerId?T[1]:T[0];return I[se.pointerId]}n.domElement.addEventListener("contextmenu",re),n.domElement.addEventListener("pointerdown",ae),n.domElement.addEventListener("pointercancel",Ee),n.domElement.addEventListener("wheel",ke,{passive:!1}),this.update()}}var es=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function e$(r){if(r.__esModule)return r;var e=r.default;if(typeof e=="function"){var t=function n(){if(this instanceof n){var i=[null];i.push.apply(i,arguments);var s=Function.bind.apply(e,i);return new s}return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(r).forEach(function(n){var i=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return r[n]}})}),t}var t$={};(function(){var r;function e(y){var w=0;return function(){return w<y.length?{done:!1,value:y[w++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(y,w,M){return y==Array.prototype||y==Object.prototype||(y[w]=M.value),y};function n(y){y=[typeof globalThis=="object"&&globalThis,y,typeof window=="object"&&window,typeof self=="object"&&self,typeof es=="object"&&es];for(var w=0;w<y.length;++w){var M=y[w];if(M&&M.Math==Math)return M}throw Error("Cannot find global object")}var i=n(this);function s(y,w){if(w)e:{var M=i;y=y.split(".");for(var k=0;k<y.length-1;k++){var B=y[k];if(!(B in M))break e;M=M[B]}y=y[y.length-1],k=M[y],w=w(k),w!=k&&w!=null&&t(M,y,{configurable:!0,writable:!0,value:w})}}s("Symbol",function(y){function w(W){if(this instanceof w)throw new TypeError("Symbol is not a constructor");return new M(k+(W||"")+"_"+B++,W)}function M(W,V){this.h=W,t(this,"description",{configurable:!0,writable:!0,value:V})}if(y)return y;M.prototype.toString=function(){return this.h};var k="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",B=0;return w}),s("Symbol.iterator",function(y){if(y)return y;y=Symbol("Symbol.iterator");for(var w="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),M=0;M<w.length;M++){var k=i[w[M]];typeof k=="function"&&typeof k.prototype[y]!="function"&&t(k.prototype,y,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return y});function o(y){return y={next:y},y[Symbol.iterator]=function(){return this},y}function a(y){var w=typeof Symbol<"u"&&Symbol.iterator&&y[Symbol.iterator];return w?w.call(y):{next:e(y)}}function l(y){if(!(y instanceof Array)){y=a(y);for(var w,M=[];!(w=y.next()).done;)M.push(w.value);y=M}return y}var u=typeof Object.assign=="function"?Object.assign:function(y,w){for(var M=1;M<arguments.length;M++){var k=arguments[M];if(k)for(var B in k)Object.prototype.hasOwnProperty.call(k,B)&&(y[B]=k[B])}return y};s("Object.assign",function(y){return y||u});var c=typeof Object.create=="function"?Object.create:function(y){function w(){}return w.prototype=y,new w},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},g={};try{g.__proto__=d,f=g.a;break e}catch{}f=!1}h=f?function(y,w){if(y.__proto__=w,y.__proto__!==w)throw new TypeError(y+" is not extensible");return y}:null}var p=h;function m(y,w){if(y.prototype=c(w.prototype),y.prototype.constructor=y,p)p(y,w);else for(var M in w)if(M!="prototype")if(Object.defineProperties){var k=Object.getOwnPropertyDescriptor(w,M);k&&Object.defineProperty(y,M,k)}else y[M]=w[M];y.za=w.prototype}function _(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function v(y){if(y.m)throw new TypeError("Generator is already running");y.m=!0}_.prototype.u=function(y){this.i=y};function b(y,w){y.l={ma:w,na:!0},y.h=y.s||y.v}_.prototype.return=function(y){this.l={return:y},this.h=this.v};function x(y,w,M){return y.h=M,{value:w}}function T(y){this.h=new _,this.i=y}function I(y,w){v(y.h);var M=y.h.j;return M?C(y,"return"in M?M.return:function(k){return{value:k,done:!0}},w,y.h.return):(y.h.return(w),S(y))}function C(y,w,M,k){try{var B=w.call(y.h.j,M);if(!(B instanceof Object))throw new TypeError("Iterator result "+B+" is not an object");if(!B.done)return y.h.m=!1,B;var W=B.value}catch(V){return y.h.j=null,b(y.h,V),S(y)}return y.h.j=null,k.call(y.h,W),S(y)}function S(y){for(;y.h.h;)try{var w=y.i(y.h);if(w)return y.h.m=!1,{value:w.value,done:!1}}catch(M){y.h.i=void 0,b(y.h,M)}if(y.h.m=!1,y.h.l){if(w=y.h.l,y.h.l=null,w.na)throw w.ma;return{value:w.return,done:!0}}return{value:void 0,done:!0}}function A(y){this.next=function(w){return v(y.h),y.h.j?w=C(y,y.h.j.next,w,y.h.u):(y.h.u(w),w=S(y)),w},this.throw=function(w){return v(y.h),y.h.j?w=C(y,y.h.j.throw,w,y.h.u):(b(y.h,w),w=S(y)),w},this.return=function(w){return I(y,w)},this[Symbol.iterator]=function(){return this}}function R(y){function w(k){return y.next(k)}function M(k){return y.throw(k)}return new Promise(function(k,B){function W(V){V.done?k(V.value):Promise.resolve(V.value).then(w,M).then(W,B)}W(y.next())})}function F(y){return R(new A(new T(y)))}s("Promise",function(y){function w(V){this.i=0,this.j=void 0,this.h=[],this.u=!1;var J=this.l();try{V(J.resolve,J.reject)}catch(ce){J.reject(ce)}}function M(){this.h=null}function k(V){return V instanceof w?V:new w(function(J){J(V)})}if(y)return y;M.prototype.i=function(V){if(this.h==null){this.h=[];var J=this;this.j(function(){J.m()})}this.h.push(V)};var B=i.setTimeout;M.prototype.j=function(V){B(V,0)},M.prototype.m=function(){for(;this.h&&this.h.length;){var V=this.h;this.h=[];for(var J=0;J<V.length;++J){var ce=V[J];V[J]=null;try{ce()}catch(Ie){this.l(Ie)}}}this.h=null},M.prototype.l=function(V){this.j(function(){throw V})},w.prototype.l=function(){function V(Ie){return function(Oe){ce||(ce=!0,Ie.call(J,Oe))}}var J=this,ce=!1;return{resolve:V(this.I),reject:V(this.m)}},w.prototype.I=function(V){if(V===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(V instanceof w)this.L(V);else{e:switch(typeof V){case"object":var J=V!=null;break e;case"function":J=!0;break e;default:J=!1}J?this.F(V):this.s(V)}},w.prototype.F=function(V){var J=void 0;try{J=V.then}catch(ce){this.m(ce);return}typeof J=="function"?this.M(J,V):this.s(V)},w.prototype.m=function(V){this.v(2,V)},w.prototype.s=function(V){this.v(1,V)},w.prototype.v=function(V,J){if(this.i!=0)throw Error("Cannot settle("+V+", "+J+"): Promise already settled in state"+this.i);this.i=V,this.j=J,this.i===2&&this.K(),this.H()},w.prototype.K=function(){var V=this;B(function(){if(V.D()){var J=i.console;typeof J<"u"&&J.error(V.j)}},1)},w.prototype.D=function(){if(this.u)return!1;var V=i.CustomEvent,J=i.Event,ce=i.dispatchEvent;return typeof ce>"u"?!0:(typeof V=="function"?V=new V("unhandledrejection",{cancelable:!0}):typeof J=="function"?V=new J("unhandledrejection",{cancelable:!0}):(V=i.document.createEvent("CustomEvent"),V.initCustomEvent("unhandledrejection",!1,!0,V)),V.promise=this,V.reason=this.j,ce(V))},w.prototype.H=function(){if(this.h!=null){for(var V=0;V<this.h.length;++V)W.i(this.h[V]);this.h=null}};var W=new M;return w.prototype.L=function(V){var J=this.l();V.T(J.resolve,J.reject)},w.prototype.M=function(V,J){var ce=this.l();try{V.call(J,ce.resolve,ce.reject)}catch(Ie){ce.reject(Ie)}},w.prototype.then=function(V,J){function ce(tt,Ge){return typeof tt=="function"?function(ut){try{Ie(tt(ut))}catch(vt){Oe(vt)}}:Ge}var Ie,Oe,lt=new w(function(tt,Ge){Ie=tt,Oe=Ge});return this.T(ce(V,Ie),ce(J,Oe)),lt},w.prototype.catch=function(V){return this.then(void 0,V)},w.prototype.T=function(V,J){function ce(){switch(Ie.i){case 1:V(Ie.j);break;case 2:J(Ie.j);break;default:throw Error("Unexpected state: "+Ie.i)}}var Ie=this;this.h==null?W.i(ce):this.h.push(ce),this.u=!0},w.resolve=k,w.reject=function(V){return new w(function(J,ce){ce(V)})},w.race=function(V){return new w(function(J,ce){for(var Ie=a(V),Oe=Ie.next();!Oe.done;Oe=Ie.next())k(Oe.value).T(J,ce)})},w.all=function(V){var J=a(V),ce=J.next();return ce.done?k([]):new w(function(Ie,Oe){function lt(ut){return function(vt){tt[ut]=vt,Ge--,Ge==0&&Ie(tt)}}var tt=[],Ge=0;do tt.push(void 0),Ge++,k(ce.value).T(lt(tt.length-1),Oe),ce=J.next();while(!ce.done)})},w});function q(y,w){y instanceof String&&(y+="");var M=0,k=!1,B={next:function(){if(!k&&M<y.length){var W=M++;return{value:w(W,y[W]),done:!1}}return k=!0,{done:!0,value:void 0}}};return B[Symbol.iterator]=function(){return B},B}s("Array.prototype.keys",function(y){return y||function(){return q(this,function(w){return w})}}),s("Array.prototype.fill",function(y){return y||function(w,M,k){var B=this.length||0;for(0>M&&(M=Math.max(0,B+M)),(k==null||k>B)&&(k=B),k=Number(k),0>k&&(k=Math.max(0,B+k)),M=Number(M||0);M<k;M++)this[M]=w;return this}});function O(y){return y||Array.prototype.fill}s("Int8Array.prototype.fill",O),s("Uint8Array.prototype.fill",O),s("Uint8ClampedArray.prototype.fill",O),s("Int16Array.prototype.fill",O),s("Uint16Array.prototype.fill",O),s("Int32Array.prototype.fill",O),s("Uint32Array.prototype.fill",O),s("Float32Array.prototype.fill",O),s("Float64Array.prototype.fill",O),s("Object.is",function(y){return y||function(w,M){return w===M?w!==0||1/w===1/M:w!==w&&M!==M}}),s("Array.prototype.includes",function(y){return y||function(w,M){var k=this;k instanceof String&&(k=String(k));var B=k.length;for(M=M||0,0>M&&(M=Math.max(M+B,0));M<B;M++){var W=k[M];if(W===w||Object.is(W,w))return!0}return!1}}),s("String.prototype.includes",function(y){return y||function(w,M){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(w instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(w,M||0)!==-1}});var z=this||self;function H(y,w){y=y.split(".");var M=z;y[0]in M||typeof M.execScript>"u"||M.execScript("var "+y[0]);for(var k;y.length&&(k=y.shift());)y.length||w===void 0?M[k]&&M[k]!==Object.prototype[k]?M=M[k]:M=M[k]={}:M[k]=w}function Q(y){var w;e:{if((w=z.navigator)&&(w=w.userAgent))break e;w=""}return w.indexOf(y)!=-1}var Z=Array.prototype.map?function(y,w){return Array.prototype.map.call(y,w,void 0)}:function(y,w){for(var M=y.length,k=Array(M),B=typeof y=="string"?y.split(""):y,W=0;W<M;W++)W in B&&(k[W]=w.call(void 0,B[W],W,y));return k},Y={},fe=null;function le(y){var w=y.length,M=3*w/4;M%3?M=Math.floor(M):"=.".indexOf(y[w-1])!=-1&&(M="=.".indexOf(y[w-2])!=-1?M-2:M-1);var k=new Uint8Array(M),B=0;return ve(y,function(W){k[B++]=W}),B!==M?k.subarray(0,B):k}function ve(y,w){function M(ce){for(;k<y.length;){var Ie=y.charAt(k++),Oe=fe[Ie];if(Oe!=null)return Oe;if(!/^[\s\xa0]*$/.test(Ie))throw Error("Unknown base64 encoding at char: "+Ie)}return ce}ee();for(var k=0;;){var B=M(-1),W=M(0),V=M(64),J=M(64);if(J===64&&B===-1)break;w(B<<2|W>>4),V!=64&&(w(W<<4&240|V>>2),J!=64&&w(V<<6&192|J))}}function ee(){if(!fe){fe={};for(var y="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),w=["+/=","+/","-_=","-_.","-_"],M=0;5>M;M++){var k=y.concat(w[M].split(""));Y[M]=k;for(var B=0;B<k.length;B++){var W=k[B];fe[W]===void 0&&(fe[W]=B)}}}}var _e=typeof Uint8Array<"u",Te=!(Q("Trident")||Q("MSIE"))&&typeof z.btoa=="function";function ne(y){if(!Te){var w;w===void 0&&(w=0),ee(),w=Y[w];for(var M=Array(Math.floor(y.length/3)),k=w[64]||"",B=0,W=0;B<y.length-2;B+=3){var V=y[B],J=y[B+1],ce=y[B+2],Ie=w[V>>2];V=w[(V&3)<<4|J>>4],J=w[(J&15)<<2|ce>>6],ce=w[ce&63],M[W++]=Ie+V+J+ce}switch(Ie=0,ce=k,y.length-B){case 2:Ie=y[B+1],ce=w[(Ie&15)<<2]||k;case 1:y=y[B],M[W]=w[y>>2]+w[(y&3)<<4|Ie>>4]+ce+k}return M.join("")}for(w="";10240<y.length;)w+=String.fromCharCode.apply(null,y.subarray(0,10240)),y=y.subarray(10240);return w+=String.fromCharCode.apply(null,y),btoa(w)}var Le=RegExp("[-_.]","g");function Ve(y){switch(y){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function He(y){if(!Te)return le(y);Le.test(y)&&(y=y.replace(Le,Ve)),y=atob(y);for(var w=new Uint8Array(y.length),M=0;M<y.length;M++)w[M]=y.charCodeAt(M);return w}var We;function Je(){return We||(We=new Uint8Array(0))}var nt={},U=typeof Uint8Array.prototype.slice=="function",j=0,ae=0;function be(y){var w=0>y;y=Math.abs(y);var M=y>>>0;y=Math.floor((y-M)/4294967296),w&&(M=a(Ee(M,y)),w=M.next().value,y=M.next().value,M=w),j=M>>>0,ae=y>>>0}var de=typeof BigInt=="function";function Ee(y,w){return w=~w,y?y=~y+1:w+=1,[y,w]}function Ae(y,w){this.i=y>>>0,this.h=w>>>0}function we(y){if(!y)return ke||(ke=new Ae(0,0));if(!/^-?\d+$/.test(y))return null;if(16>y.length)be(Number(y));else if(de)y=BigInt(y),j=Number(y&BigInt(4294967295))>>>0,ae=Number(y>>BigInt(32)&BigInt(4294967295));else{var w=+(y[0]==="-");ae=j=0;for(var M=y.length,k=w,B=(M-w)%6+w;B<=M;k=B,B+=6)k=Number(y.slice(k,B)),ae*=1e6,j=1e6*j+k,4294967296<=j&&(ae+=j/4294967296|0,j%=4294967296);w&&(w=a(Ee(j,ae)),y=w.next().value,w=w.next().value,j=y,ae=w)}return new Ae(j,ae)}var ke;function Se(y,w){return Error("Invalid wire type: "+y+" (at position "+w+")")}function L(){return Error("Failed to read varint, encoding is invalid.")}function N(y,w){return Error("Tried to read past the end of the data "+w+" > "+y)}function re(){throw Error("Invalid UTF8")}function pe(y,w){return w=String.fromCharCode.apply(null,w),y==null?w:y+w}var ge=void 0,Me,Pe=typeof TextDecoder<"u",G,se=typeof TextEncoder<"u",Be;function De(y){if(y!==nt)throw Error("illegal external caller")}function je(y,w){if(De(w),this.V=y,y!=null&&y.length===0)throw Error("ByteString should be constructed with non-empty values")}function Xe(){return Be||(Be=new je(null,nt))}function Ue(y){De(nt);var w=y.V;return w=w==null||_e&&w!=null&&w instanceof Uint8Array?w:typeof w=="string"?He(w):null,w==null?w:y.V=w}function ot(y){if(typeof y=="string")return{buffer:He(y),C:!1};if(Array.isArray(y))return{buffer:new Uint8Array(y),C:!1};if(y.constructor===Uint8Array)return{buffer:y,C:!1};if(y.constructor===ArrayBuffer)return{buffer:new Uint8Array(y),C:!1};if(y.constructor===je)return{buffer:Ue(y)||Je(),C:!0};if(y instanceof Uint8Array)return{buffer:new Uint8Array(y.buffer,y.byteOffset,y.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function xt(y,w){this.i=null,this.m=!1,this.h=this.j=this.l=0,Ot(this,y,w)}function Ot(y,w,M){M=M===void 0?{}:M,y.S=M.S===void 0?!1:M.S,w&&(w=ot(w),y.i=w.buffer,y.m=w.C,y.l=0,y.j=y.i.length,y.h=y.l)}xt.prototype.reset=function(){this.h=this.l};function te(y,w){if(y.h=w,w>y.j)throw N(y.j,w)}function me(y){var w=y.i,M=y.h,k=w[M++],B=k&127;if(k&128&&(k=w[M++],B|=(k&127)<<7,k&128&&(k=w[M++],B|=(k&127)<<14,k&128&&(k=w[M++],B|=(k&127)<<21,k&128&&(k=w[M++],B|=k<<28,k&128&&w[M++]&128&&w[M++]&128&&w[M++]&128&&w[M++]&128&&w[M++]&128)))))throw L();return te(y,M),B}function Ne(y,w){if(0>w)throw Error("Tried to read a negative byte length: "+w);var M=y.h,k=M+w;if(k>y.j)throw N(w,y.j-M);return y.h=k,M}var qe=[];function Ke(){this.h=[]}Ke.prototype.length=function(){return this.h.length},Ke.prototype.end=function(){var y=this.h;return this.h=[],y};function Gt(y,w,M){for(;0<M||127<w;)y.h.push(w&127|128),w=(w>>>7|M<<25)>>>0,M>>>=7;y.h.push(w)}function Qt(y,w){for(;127<w;)y.h.push(w&127|128),w>>>=7;y.h.push(w)}function An(y,w){if(qe.length){var M=qe.pop();Ot(M,y,w),y=M}else y=new xt(y,w);this.h=y,this.j=this.h.h,this.i=this.l=-1,this.setOptions(w)}An.prototype.setOptions=function(y){y=y===void 0?{}:y,this.ca=y.ca===void 0?!1:y.ca},An.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Lr(y){var w=y.h;if(w.h==w.j)return!1;y.j=y.h.h;var M=me(y.h)>>>0;if(w=M>>>3,M&=7,!(0<=M&&5>=M))throw Se(M,y.j);if(1>w)throw Error("Invalid field number: "+w+" (at position "+y.j+")");return y.l=w,y.i=M,!0}function Jt(y){switch(y.i){case 0:if(y.i!=0)Jt(y);else e:{y=y.h;for(var w=y.h,M=w+10,k=y.i;w<M;)if(!(k[w++]&128)){te(y,w);break e}throw L()}break;case 1:y=y.h,te(y,y.h+8);break;case 2:y.i!=2?Jt(y):(w=me(y.h)>>>0,y=y.h,te(y,y.h+w));break;case 5:y=y.h,te(y,y.h+4);break;case 3:w=y.l;do{if(!Lr(y))throw Error("Unmatched start-group tag: stream EOF");if(y.i==4){if(y.l!=w)throw Error("Unmatched end-group tag");break}Jt(y)}while(1);break;default:throw Se(y.i,y.j)}}var Bn=[];function Jr(){this.j=[],this.i=0,this.h=new Ke}function Hs(y,w){w.length!==0&&(y.j.push(w),y.i+=w.length)}function nd(y,w){if(w=w.R){Hs(y,y.h.end());for(var M=0;M<w.length;M++)Hs(y,Ue(w[M])||Je())}}var Si=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function $(y,w){return Si?y[Si]|=w:y.A!==void 0?y.A|=w:(Object.defineProperties(y,{A:{value:w,configurable:!0,writable:!0,enumerable:!1}}),w)}function ue(y,w){Si?y[Si]&&(y[Si]&=~w):y.A!==void 0&&(y.A&=~w)}function he(y){var w;return Si?w=y[Si]:w=y.A,w??0}function oe(y,w){Si?y[Si]=w:y.A!==void 0?y.A=w:Object.defineProperties(y,{A:{value:w,configurable:!0,writable:!0,enumerable:!1}})}function xe(y){return $(y,1),y}function rt(y,w){oe(w,(y|0)&-51)}function at(y,w){oe(w,(y|18)&-41)}var dt={};function pt(y){return y!==null&&typeof y=="object"&&!Array.isArray(y)&&y.constructor===Object}var Tt,At=[];oe(At,23),Tt=Object.freeze(At);function Et(y){if(he(y.o)&2)throw Error("Cannot mutate an immutable Message")}function cn(y){var w=y.length;(w=w?y[w-1]:void 0)&&pt(w)?w.g=1:(w={},y.push((w.g=1,w)))}function qn(y){var w=y.i+y.G;return y.B||(y.B=y.o[w]={})}function bn(y,w){return w===-1?null:w>=y.i?y.B?y.B[w]:void 0:y.o[w+y.G]}function Ln(y,w,M,k){Et(y),en(y,w,M,k)}function en(y,w,M,k){y.j&&(y.j=void 0),w>=y.i||k?qn(y)[w]=M:(y.o[w+y.G]=M,(y=y.B)&&w in y&&delete y[w])}function Mt(y,w,M,k){var B=bn(y,w);Array.isArray(B)||(B=Tt);var W=he(B);if(W&1||xe(B),k)W&2||$(B,2),M&1||Object.freeze(B);else{k=!(M&2);var V=W&2;M&1||!V?k&&W&16&&!V&&ue(B,16):(B=xe(Array.prototype.slice.call(B)),en(y,w,B))}return B}function Ro(y,w){var M=bn(y,w),k=M==null?M:typeof M=="number"||M==="NaN"||M==="Infinity"||M==="-Infinity"?Number(M):void 0;return k!=null&&k!==M&&en(y,w,k),k}function xn(y,w,M,k,B){y.h||(y.h={});var W=y.h[M],V=Mt(y,M,3,B);if(!W){var J=V;W=[];var ce=!!(he(y.o)&16);V=!!(he(J)&2);var Ie=J;!B&&V&&(J=Array.prototype.slice.call(J));for(var Oe=V,lt=0;lt<J.length;lt++){var tt=J[lt],Ge=w,ut=!1;if(ut=ut===void 0?!1:ut,tt=Array.isArray(tt)?new Ge(tt):ut?new Ge:void 0,tt!==void 0){Ge=tt.o;var vt=ut=he(Ge);V&&(vt|=2),ce&&(vt|=16),vt!=ut&&oe(Ge,vt),Ge=vt,Oe=Oe||!!(2&Ge),W.push(tt)}}return y.h[M]=W,ce=he(J),w=ce|33,w=Oe?w&-9:w|8,ce!=w&&(Oe=J,Object.isFrozen(Oe)&&(Oe=Array.prototype.slice.call(Oe)),oe(Oe,w),J=Oe),Ie!==J&&en(y,M,J),(B||k&&V)&&$(W,2),k&&Object.freeze(W),W}return B||(B=Object.isFrozen(W),k&&!B?Object.freeze(W):!k&&B&&(W=Array.prototype.slice.call(W),y.h[M]=W)),W}function Ti(y,w,M){var k=!!(he(y.o)&2);if(w=xn(y,w,M,k,k),y=Mt(y,M,3,k),!(k||he(y)&8)){for(k=0;k<w.length;k++){if(M=w[k],he(M.o)&2){var B=e0(M,!1);B.j=M}else B=M;M!==B&&(w[k]=B,y[k]=B.o)}$(y,8)}return w}function Dr(y,w,M){if(M!=null&&typeof M!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof M+": "+M);Ln(y,w,M)}function js(y,w,M,k,B){Et(y);var W=xn(y,M,w,!1,!1);return M=k??new M,y=Mt(y,w,2,!1),B!=null?(W.splice(B,0,M),y.splice(B,0,M.o)):(W.push(M),y.push(M.o)),M.C()&&ue(y,8),M}function qs(y,w){return y??w}function tn(y,w,M){return M=M===void 0?0:M,qs(Ro(y,w),M)}var ei;function pu(y){switch(typeof y){case"number":return isFinite(y)?y:String(y);case"object":if(y)if(Array.isArray(y)){if(he(y)&128)return y=Array.prototype.slice.call(y),cn(y),y}else{if(_e&&y!=null&&y instanceof Uint8Array)return ne(y);if(y instanceof je){var w=y.V;return w==null?"":typeof w=="string"?w:y.V=ne(w)}}}return y}function Kn(y,w,M,k){if(y!=null){if(Array.isArray(y))y=Po(y,w,M,k!==void 0);else if(pt(y)){var B={},W;for(W in y)B[W]=Kn(y[W],w,M,k);y=B}else y=w(y,k);return y}}function Po(y,w,M,k){var B=he(y);k=k?!!(B&16):void 0,y=Array.prototype.slice.call(y);for(var W=0;W<y.length;W++)y[W]=Kn(y[W],w,M,k);return M(B,y),y}function rd(y){return y.ja===dt?y.toJSON():pu(y)}function $c(y,w){y&128&&cn(w)}function Zy(y,w,M){if(M=M===void 0?at:M,y!=null){if(_e&&y instanceof Uint8Array)return y.length?new je(new Uint8Array(y),nt):Xe();if(Array.isArray(y)){var k=he(y);return k&2?y:w&&!(k&32)&&(k&16||k===0)?(oe(y,k|2),y):(y=Po(y,Zy,k&4?at:M,!0),w=he(y),w&4&&w&2&&Object.freeze(y),y)}return y.ja===dt?Jy(y):y}}function Qy(y,w,M,k,B,W,V){if(y=y.h&&y.h[M]){if(k=he(y),k&2?k=y:(W=Z(y,Jy),at(k,W),Object.freeze(W),k=W),Et(w),V=k==null?Tt:xe([]),k!=null){for(W=!!k.length,y=0;y<k.length;y++){var J=k[y];W=W&&!(he(J.o)&2),V[y]=J.o}W=(W?8:0)|1,y=he(V),(y&W)!==W&&(Object.isFrozen(V)&&(V=Array.prototype.slice.call(V)),oe(V,y|W)),w.h||(w.h={}),w.h[M]=k}else w.h&&(w.h[M]=void 0);en(w,M,V,B)}else Ln(w,M,Zy(k,W,V),B)}function Jy(y){return he(y.o)&2||(y=e0(y,!0),$(y.o,2)),y}function e0(y,w){var M=y.o,k=[];$(k,16);var B=y.constructor.h;if(B&&k.push(B),B=y.B,B){k.length=M.length,k.fill(void 0,k.length,M.length);var W={};k[k.length-1]=W}he(M)&128&&cn(k),w=w||y.C()?at:rt,W=y.constructor,ei=k,k=new W(k),ei=void 0,y.R&&(k.R=y.R.slice()),W=!!(he(M)&16);for(var V=B?M.length-1:M.length,J=0;J<V;J++)Qy(y,k,J-y.G,M[J],!1,W,w);if(B)for(var ce in B)Qy(y,k,+ce,B[ce],!0,W,w);return k}function xr(y,w,M){y==null&&(y=ei),ei=void 0;var k=this.constructor.i||0,B=0<k,W=this.constructor.h,V=!1;if(y==null){y=W?[W]:[];var J=48,ce=!0;B&&(k=0,J|=128),oe(y,J)}else{if(!Array.isArray(y)||W&&W!==y[0])throw Error();var Ie=J=$(y,0);if((ce=(16&Ie)!==0)&&((V=(32&Ie)!==0)||(Ie|=32)),B){if(128&Ie)k=0;else if(0<y.length){var Oe=y[y.length-1];if(pt(Oe)&&"g"in Oe){k=0,Ie|=128,delete Oe.g;var lt=!0,tt;for(tt in Oe){lt=!1;break}lt&&y.pop()}}}else if(128&Ie)throw Error();J!==Ie&&oe(y,Ie)}this.G=(W?0:-1)-k,this.h=void 0,this.o=y;e:{if(W=this.o.length,k=W-1,W&&(W=this.o[k],pt(W))){this.B=W,this.i=k-this.G;break e}w!==void 0&&-1<w?(this.i=Math.max(w,k+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!B&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(M){w=ce&&!V&&!0,B=this.i;var Ge;for(ce=0;ce<M.length;ce++)V=M[ce],V<B?(V+=this.G,(k=y[V])?t0(k,w):y[V]=Tt):(Ge||(Ge=qn(this)),(k=Ge[V])?t0(k,w):Ge[V]=Tt)}}xr.prototype.toJSON=function(){return Po(this.o,rd,$c)},xr.prototype.C=function(){return!!(he(this.o)&2)};function t0(y,w){if(Array.isArray(y)){var M=he(y),k=1;!w||M&2||(k|=16),(M&k)!==k&&oe(y,M|k)}}xr.prototype.ja=dt,xr.prototype.toString=function(){return this.o.toString()};function n0(y,w,M){if(M){var k={},B;for(B in M){var W=M[B],V=W.ra;V||(k.J=W.xa||W.oa.W,W.ia?(k.aa=a0(W.ia),V=function(J){return function(ce,Ie,Oe){return J.J(ce,Ie,Oe,J.aa)}}(k)):W.ka?(k.Z=l0(W.da.P,W.ka),V=function(J){return function(ce,Ie,Oe){return J.J(ce,Ie,Oe,J.Z)}}(k)):V=k.J,W.ra=V),V(w,y,W.da),k={J:k.J,aa:k.aa,Z:k.Z}}}nd(w,y)}var zc=Symbol();function r0(y,w,M){return y[zc]||(y[zc]=function(k,B){return w(k,B,M)})}function i0(y){var w=y[zc];if(!w){var M=sd(y);w=function(k,B){return u0(k,B,M)},y[zc]=w}return w}function zM(y){var w=y.ia;if(w)return i0(w);if(w=y.wa)return r0(y.da.P,w,y.ka)}function BM(y){var w=zM(y),M=y.da,k=y.oa.U;return w?function(B,W){return k(B,W,M,w)}:function(B,W){return k(B,W,M)}}function s0(y,w){var M=y[w];return typeof M=="function"&&M.length===0&&(M=M(),y[w]=M),Array.isArray(M)&&(gu in M||mu in M||0<M.length&&typeof M[0]=="function")?M:void 0}function o0(y,w,M,k,B,W){w.P=y[0];var V=1;if(y.length>V&&typeof y[V]!="number"){var J=y[V++];M(w,J)}for(;V<y.length;){M=y[V++];for(var ce=V+1;ce<y.length&&typeof y[ce]!="number";)ce++;switch(J=y[V++],ce-=V,ce){case 0:k(w,M,J);break;case 1:(ce=s0(y,V))?(V++,B(w,M,J,ce)):k(w,M,J,y[V++]);break;case 2:ce=V++,ce=s0(y,ce),B(w,M,J,ce,y[V++]);break;case 3:W(w,M,J,y[V++],y[V++],y[V++]);break;case 4:W(w,M,J,y[V++],y[V++],y[V++],y[V++]);break;default:throw Error("unexpected number of binary field arguments: "+ce)}}return w}var Bc=Symbol();function a0(y){var w=y[Bc];if(!w){var M=id(y);w=function(k,B){return c0(k,B,M)},y[Bc]=w}return w}function l0(y,w){var M=y[Bc];return M||(M=function(k,B){return n0(k,B,w)},y[Bc]=M),M}var mu=Symbol();function UM(y,w){y.push(w)}function VM(y,w,M){y.push(w,M.W)}function WM(y,w,M,k){var B=a0(k),W=id(k).P,V=M.W;y.push(w,function(J,ce,Ie){return V(J,ce,Ie,W,B)})}function GM(y,w,M,k,B,W){var V=l0(k,W),J=M.W;y.push(w,function(ce,Ie,Oe){return J(ce,Ie,Oe,k,V)})}function id(y){var w=y[mu];return w||(w=o0(y,y[mu]=[],UM,VM,WM,GM),gu in y&&mu in y&&(y.length=0),w)}var gu=Symbol();function HM(y,w){y[0]=w}function jM(y,w,M,k){var B=M.U;y[w]=k?function(W,V,J){return B(W,V,J,k)}:B}function qM(y,w,M,k,B){var W=M.U,V=i0(k),J=sd(k).P;y[w]=function(ce,Ie,Oe){return W(ce,Ie,Oe,J,V,B)}}function KM(y,w,M,k,B,W,V){var J=M.U,ce=r0(k,B,W);y[w]=function(Ie,Oe,lt){return J(Ie,Oe,lt,k,ce,V)}}function sd(y){var w=y[gu];return w||(w=o0(y,y[gu]={},HM,jM,qM,KM),gu in y&&mu in y&&(y.length=0),w)}function u0(y,w,M){for(;Lr(w)&&w.i!=4;){var k=w.l,B=M[k];if(!B){var W=M[0];W&&(W=W[k])&&(B=M[k]=BM(W))}if(!B||!B(w,y,k)){B=w,k=y,W=B.j,Jt(B);var V=B;if(!V.ca){if(B=V.h.h-W,V.h.h=W,V=V.h,B==0)B=Xe();else{if(W=Ne(V,B),V.S&&V.m)B=V.i.subarray(W,W+B);else{V=V.i;var J=W;B=W+B,B=J===B?Je():U?V.slice(J,B):new Uint8Array(V.subarray(J,B))}B=B.length==0?Xe():new je(B,nt)}(W=k.R)?W.push(B):k.R=[B]}}}return y}function c0(y,w,M){for(var k=M.length,B=k%2==1,W=B?1:0;W<k;W+=2)(0,M[W+1])(w,y,M[W]);n0(y,w,B?M[0]:void 0)}function yu(y,w){return{U:y,W:w}}var Ei=yu(function(y,w,M){if(y.i!==5)return!1;y=y.h;var k=y.i,B=y.h,W=k[B],V=k[B+1],J=k[B+2];return k=k[B+3],te(y,y.h+4),V=(W<<0|V<<8|J<<16|k<<24)>>>0,y=2*(V>>31)+1,W=V>>>23&255,V&=8388607,Ln(w,M,W==255?V?NaN:1/0*y:W==0?y*Math.pow(2,-149)*V:y*Math.pow(2,W-150)*(V+Math.pow(2,23))),!0},function(y,w,M){if(w=Ro(w,M),w!=null){Qt(y.h,8*M+5),y=y.h;var k=+w;k===0?0<1/k?j=ae=0:(ae=0,j=2147483648):isNaN(k)?(ae=0,j=2147483647):(k=(M=0>k?-2147483648:0)?-k:k,34028234663852886e22<k?(ae=0,j=(M|2139095040)>>>0):11754943508222875e-54>k?(k=Math.round(k/Math.pow(2,-149)),ae=0,j=(M|k)>>>0):(w=Math.floor(Math.log(k)/Math.LN2),k*=Math.pow(2,-w),k=Math.round(8388608*k),16777216<=k&&++w,ae=0,j=(M|w+127<<23|k&8388607)>>>0)),M=j,y.h.push(M>>>0&255),y.h.push(M>>>8&255),y.h.push(M>>>16&255),y.h.push(M>>>24&255)}}),XM=yu(function(y,w,M){if(y.i!==0)return!1;var k=y.h,B=0,W=y=0,V=k.i,J=k.h;do{var ce=V[J++];B|=(ce&127)<<W,W+=7}while(32>W&&ce&128);for(32<W&&(y|=(ce&127)>>4),W=3;32>W&&ce&128;W+=7)ce=V[J++],y|=(ce&127)<<W;if(te(k,J),128>ce)k=B>>>0,ce=y>>>0,(y=ce&2147483648)&&(k=~k+1>>>0,ce=~ce>>>0,k==0&&(ce=ce+1>>>0)),k=4294967296*ce+(k>>>0);else throw L();return Ln(w,M,y?-k:k),!0},function(y,w,M){w=bn(w,M),w!=null&&(typeof w=="string"&&we(w),w!=null&&(Qt(y.h,8*M),typeof w=="number"?(y=y.h,be(w),Gt(y,j,ae)):(M=we(w),Gt(y.h,M.i,M.h))))}),YM=yu(function(y,w,M){return y.i!==0?!1:(Ln(w,M,me(y.h)),!0)},function(y,w,M){if(w=bn(w,M),w!=null&&w!=null)if(Qt(y.h,8*M),y=y.h,M=w,0<=M)Qt(y,M);else{for(w=0;9>w;w++)y.h.push(M&127|128),M>>=7;y.h.push(1)}}),h0=yu(function(y,w,M){if(y.i!==2)return!1;var k=me(y.h)>>>0;y=y.h;var B=Ne(y,k);if(y=y.i,Pe){var W=y,V;(V=Me)||(V=Me=new TextDecoder("utf-8",{fatal:!0})),y=B+k,W=B===0&&y===W.length?W:W.subarray(B,y);try{var J=V.decode(W)}catch(lt){if(ge===void 0){try{V.decode(new Uint8Array([128]))}catch{}try{V.decode(new Uint8Array([97])),ge=!0}catch{ge=!1}}throw!ge&&(Me=void 0),lt}}else{J=B,k=J+k,B=[];for(var ce=null,Ie,Oe;J<k;)Ie=y[J++],128>Ie?B.push(Ie):224>Ie?J>=k?re():(Oe=y[J++],194>Ie||(Oe&192)!==128?(J--,re()):B.push((Ie&31)<<6|Oe&63)):240>Ie?J>=k-1?re():(Oe=y[J++],(Oe&192)!==128||Ie===224&&160>Oe||Ie===237&&160<=Oe||((W=y[J++])&192)!==128?(J--,re()):B.push((Ie&15)<<12|(Oe&63)<<6|W&63)):244>=Ie?J>=k-2?re():(Oe=y[J++],(Oe&192)!==128||(Ie<<28)+(Oe-144)>>30||((W=y[J++])&192)!==128||((V=y[J++])&192)!==128?(J--,re()):(Ie=(Ie&7)<<18|(Oe&63)<<12|(W&63)<<6|V&63,Ie-=65536,B.push((Ie>>10&1023)+55296,(Ie&1023)+56320))):re(),8192<=B.length&&(ce=pe(ce,B),B.length=0);J=pe(ce,B)}return Ln(w,M,J),!0},function(y,w,M){if(w=bn(w,M),w!=null){var k=!1;if(k=k===void 0?!1:k,se){if(k&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(w))throw Error("Found an unpaired surrogate");w=(G||(G=new TextEncoder)).encode(w)}else{for(var B=0,W=new Uint8Array(3*w.length),V=0;V<w.length;V++){var J=w.charCodeAt(V);if(128>J)W[B++]=J;else{if(2048>J)W[B++]=J>>6|192;else{if(55296<=J&&57343>=J){if(56319>=J&&V<w.length){var ce=w.charCodeAt(++V);if(56320<=ce&&57343>=ce){J=1024*(J-55296)+ce-56320+65536,W[B++]=J>>18|240,W[B++]=J>>12&63|128,W[B++]=J>>6&63|128,W[B++]=J&63|128;continue}else V--}if(k)throw Error("Found an unpaired surrogate");J=65533}W[B++]=J>>12|224,W[B++]=J>>6&63|128}W[B++]=J&63|128}}w=B===W.length?W:W.subarray(0,B)}Qt(y.h,8*M+2),Qt(y.h,w.length),Hs(y,y.h.end()),Hs(y,w)}}),f0=yu(function(y,w,M,k,B){if(y.i!==2)return!1;w=js(w,M,k),M=y.h.j,k=me(y.h)>>>0;var W=y.h.h+k,V=W-M;if(0>=V&&(y.h.j=W,B(w,y,void 0,void 0,void 0),V=W-y.h.h),V)throw Error("Message parsing ended unexpectedly. Expected to read "+(k+" bytes, instead read "+(k-V)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return y.h.h=W,y.h.j=M,!0},function(y,w,M,k,B){if(w=Ti(w,k,M),w!=null)for(k=0;k<w.length;k++){var W=y;Qt(W.h,8*M+2);var V=W.h.end();Hs(W,V),V.push(W.i),W=V,B(w[k],y),V=y;var J=W.pop();for(J=V.i+V.h.length()-J;127<J;)W.push(J&127|128),J>>>=7,V.i++;W.push(J),V.i++}});function od(y){return function(w,M){e:{if(Bn.length){var k=Bn.pop();k.setOptions(M),Ot(k.h,w,M),w=k}else w=new An(w,M);try{var B=sd(y),W=u0(new B.P,w,B);break e}finally{B=w.h,B.i=null,B.m=!1,B.l=0,B.j=0,B.h=0,B.S=!1,w.l=-1,w.i=-1,100>Bn.length&&Bn.push(w)}W=void 0}return W}}function ad(y){return function(){var w=new Jr;c0(this,w,id(y)),Hs(w,w.h.end());for(var M=new Uint8Array(w.i),k=w.j,B=k.length,W=0,V=0;V<B;V++){var J=k[V];M.set(J,W),W+=J.length}return w.j=[M],M}}function Va(y){xr.call(this,y)}m(Va,xr);var d0=[Va,1,YM,2,Ei,3,h0,4,h0];Va.prototype.l=ad(d0);function ld(y){xr.call(this,y,-1,ZM)}m(ld,xr),ld.prototype.addClassification=function(y,w){return js(this,1,Va,y,w),this};var ZM=[1],QM=od([ld,1,f0,d0]);function _u(y){xr.call(this,y)}m(_u,xr);var p0=[_u,1,Ei,2,Ei,3,Ei,4,Ei,5,Ei];_u.prototype.l=ad(p0);function m0(y){xr.call(this,y,-1,JM)}m(m0,xr);var JM=[1],eA=od([m0,1,f0,p0]);function Uc(y){xr.call(this,y)}m(Uc,xr);var g0=[Uc,1,Ei,2,Ei,3,Ei,4,Ei,5,Ei,6,XM],tA=od(g0);Uc.prototype.l=ad(g0);function y0(y,w,M){if(M=y.createShader(M===0?y.VERTEX_SHADER:y.FRAGMENT_SHADER),y.shaderSource(M,w),y.compileShader(M),!y.getShaderParameter(M,y.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+y.getShaderInfoLog(M));return M}function nA(y){return Ti(y,Va,1).map(function(w){var M=bn(w,1);return{index:M??0,qa:tn(w,2),label:bn(w,3)!=null?qs(bn(w,3),""):void 0,displayName:bn(w,4)!=null?qs(bn(w,4),""):void 0}})}function rA(y){return{x:tn(y,1),y:tn(y,2),z:tn(y,3),visibility:Ro(y,4)!=null?tn(y,4):void 0}}function ud(y){return Ti(eA(y),_u,1).map(rA)}function cd(y,w){this.i=y,this.h=w,this.m=0}function _0(y,w,M){return iA(y,w),typeof y.h.canvas.transferToImageBitmap=="function"?Promise.resolve(y.h.canvas.transferToImageBitmap()):M?Promise.resolve(y.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(y.h.canvas):(y.j===void 0&&(y.j=document.createElement("canvas")),new Promise(function(k){y.j.height=y.h.canvas.height,y.j.width=y.h.canvas.width,y.j.getContext("2d",{}).drawImage(y.h.canvas,0,0,y.h.canvas.width,y.h.canvas.height),k(y.j)}))}function iA(y,w){var M=y.h;if(y.s===void 0){var k=y0(M,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),B=y0(M,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),W=M.createProgram();if(M.attachShader(W,k),M.attachShader(W,B),M.linkProgram(W),!M.getProgramParameter(W,M.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+M.getProgramInfoLog(W));k=y.s=W,M.useProgram(k),B=M.getUniformLocation(k,"sampler0"),y.l={O:M.getAttribLocation(k,"aVertex"),N:M.getAttribLocation(k,"aTex"),ya:B},y.v=M.createBuffer(),M.bindBuffer(M.ARRAY_BUFFER,y.v),M.enableVertexAttribArray(y.l.O),M.vertexAttribPointer(y.l.O,2,M.FLOAT,!1,0,0),M.bufferData(M.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),M.STATIC_DRAW),M.bindBuffer(M.ARRAY_BUFFER,null),y.u=M.createBuffer(),M.bindBuffer(M.ARRAY_BUFFER,y.u),M.enableVertexAttribArray(y.l.N),M.vertexAttribPointer(y.l.N,2,M.FLOAT,!1,0,0),M.bufferData(M.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),M.STATIC_DRAW),M.bindBuffer(M.ARRAY_BUFFER,null),M.uniform1i(B,0)}k=y.l,M.useProgram(y.s),M.canvas.width=w.width,M.canvas.height=w.height,M.viewport(0,0,w.width,w.height),M.activeTexture(M.TEXTURE0),y.i.bindTexture2d(w.glName),M.enableVertexAttribArray(k.O),M.bindBuffer(M.ARRAY_BUFFER,y.v),M.vertexAttribPointer(k.O,2,M.FLOAT,!1,0,0),M.enableVertexAttribArray(k.N),M.bindBuffer(M.ARRAY_BUFFER,y.u),M.vertexAttribPointer(k.N,2,M.FLOAT,!1,0,0),M.bindFramebuffer(M.DRAW_FRAMEBUFFER?M.DRAW_FRAMEBUFFER:M.FRAMEBUFFER,null),M.clearColor(0,0,0,0),M.clear(M.COLOR_BUFFER_BIT),M.colorMask(!0,!0,!0,!0),M.drawArrays(M.TRIANGLE_FAN,0,4),M.disableVertexAttribArray(k.O),M.disableVertexAttribArray(k.N),M.bindBuffer(M.ARRAY_BUFFER,null),y.i.bindTexture2d(0)}function sA(y){this.h=y}var oA=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function aA(y,w){return w+y}function b0(y,w){window[y]=w}function lA(y){var w=document.createElement("script");return w.setAttribute("src",y),w.setAttribute("crossorigin","anonymous"),new Promise(function(M){w.addEventListener("load",function(){M()},!1),w.addEventListener("error",function(){M()},!1),document.body.appendChild(w)})}function uA(){return F(function(y){switch(y.h){case 1:return y.s=2,x(y,WebAssembly.instantiate(oA),4);case 4:y.h=3,y.s=0;break;case 2:return y.s=0,y.l=null,y.return(!1);case 3:return y.return(!0)}})}function hd(y){if(this.h=y,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=y&&y.locateFile||aA,typeof window=="object")var w=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")w=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=w,y.options){w=a(Object.keys(y.options));for(var M=w.next();!M.done;M=w.next()){M=M.value;var k=y.options[M].default;k!==void 0&&(this.l[M]=typeof k=="function"?k():k)}}}r=hd.prototype,r.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function cA(y){var w,M,k,B,W,V,J,ce,Ie,Oe,lt;return F(function(tt){switch(tt.h){case 1:return y.ga?(w=y.h.files===void 0?[]:typeof y.h.files=="function"?y.h.files(y.l):y.h.files,x(tt,uA(),2)):tt.return();case 2:if(M=tt.i,typeof window=="object")return b0("createMediapipeSolutionsWasm",{locateFile:y.locateFile}),b0("createMediapipeSolutionsPackedAssets",{locateFile:y.locateFile}),V=w.filter(function(Ge){return Ge.data!==void 0}),J=w.filter(function(Ge){return Ge.data===void 0}),ce=Promise.all(V.map(function(Ge){var ut=Vc(y,Ge.url);if(Ge.path!==void 0){var vt=Ge.path;ut=ut.then(function(un){return y.overrideFile(vt,un),Promise.resolve(un)})}return ut})),Ie=Promise.all(J.map(function(Ge){return Ge.simd===void 0||Ge.simd&&M||!Ge.simd&&!M?lA(y.locateFile(Ge.url,y.ha)):Promise.resolve()})).then(function(){var Ge,ut,vt;return F(function(un){if(un.h==1)return Ge=window.createMediapipeSolutionsWasm,ut=window.createMediapipeSolutionsPackedAssets,vt=y,x(un,Ge(ut),2);vt.i=un.i,un.h=0})}),Oe=function(){return F(function(Ge){return y.h.graph&&y.h.graph.url?Ge=x(Ge,Vc(y,y.h.graph.url),0):(Ge.h=0,Ge=void 0),Ge})}(),x(tt,Promise.all([Ie,ce,Oe]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return k=w.filter(function(Ge){return Ge.simd===void 0||Ge.simd&&M||!Ge.simd&&!M}).map(function(Ge){return y.locateFile(Ge.url,y.ha)}),importScripts.apply(null,l(k)),B=y,x(tt,createMediapipeSolutionsWasm(Module),6);case 6:B.i=tt.i,y.m=new OffscreenCanvas(1,1),y.i.canvas=y.m,W=y.i.GL.createContext(y.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),y.i.GL.makeContextCurrent(W),tt.h=4;break;case 7:if(y.m=document.createElement("canvas"),lt=y.m.getContext("webgl2",{}),!lt&&(lt=y.m.getContext("webgl",{}),!lt))return alert("Failed to create WebGL canvas context when passing video frame."),tt.return();y.K=lt,y.i.canvas=y.m,y.i.createContext(y.m,!0,!0,{});case 4:y.j=new y.i.SolutionWasm,y.ga=!1,tt.h=0}})}function hA(y){var w,M,k,B,W,V,J,ce;return F(function(Ie){if(Ie.h==1){if(y.h.graph&&y.h.graph.url&&y.fa===y.h.graph.url)return Ie.return();if(y.u=!0,!y.h.graph||!y.h.graph.url){Ie.h=2;return}return y.fa=y.h.graph.url,x(Ie,Vc(y,y.h.graph.url),3)}for(Ie.h!=2&&(w=Ie.i,y.j.loadGraph(w)),M=a(Object.keys(y.D)),k=M.next();!k.done;k=M.next())B=k.value,y.j.overrideFile(B,y.D[B]);if(y.D={},y.h.listeners)for(W=a(y.h.listeners),V=W.next();!V.done;V=W.next())J=V.value,mA(y,J);ce=y.l,y.l={},y.setOptions(ce),Ie.h=0})}r.reset=function(){var y=this;return F(function(w){y.j&&(y.j.reset(),y.s={},y.v={}),w.h=0})},r.setOptions=function(y,w){var M=this;if(w=w||this.h.options){for(var k=[],B=[],W={},V=a(Object.keys(y)),J=V.next();!J.done;W={X:W.X,Y:W.Y},J=V.next())if(J=J.value,!(J in this.l&&this.l[J]===y[J])){this.l[J]=y[J];var ce=w[J];ce!==void 0&&(ce.onChange&&(W.X=ce.onChange,W.Y=y[J],k.push(function(Ie){return function(){var Oe;return F(function(lt){if(lt.h==1)return x(lt,Ie.X(Ie.Y),2);Oe=lt.i,Oe===!0&&(M.u=!0),lt.h=0})}}(W))),ce.graphOptionXref&&(J=Object.assign({},{calculatorName:"",calculatorIndex:0},ce.graphOptionXref,{valueNumber:ce.type===1?y[J]:0,valueBoolean:ce.type===0?y[J]:!1,valueString:ce.type===2?y[J]:""}),B.push(J)))}(k.length!==0||B.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(B),this.F=(this.F===void 0?[]:this.F).concat(k))}};function fA(y){var w,M,k,B,W,V,J;return F(function(ce){switch(ce.h){case 1:if(!y.u)return ce.return();if(!y.F){ce.h=2;break}w=a(y.F),M=w.next();case 3:if(M.done){ce.h=5;break}return k=M.value,x(ce,k(),4);case 4:M=w.next(),ce.h=3;break;case 5:y.F=void 0;case 2:if(y.H){for(B=new y.i.GraphOptionChangeRequestList,W=a(y.H),V=W.next();!V.done;V=W.next())J=V.value,B.push_back(J);y.j.changeOptions(B),B.delete(),y.H=void 0}y.u=!1,ce.h=0}})}r.initialize=function(){var y=this;return F(function(w){return w.h==1?x(w,cA(y),2):w.h!=3?x(w,hA(y),3):x(w,fA(y),0)})};function Vc(y,w){var M,k;return F(function(B){return w in y.L?B.return(y.L[w]):(M=y.locateFile(w,""),k=fetch(M).then(function(W){return W.arrayBuffer()}),y.L[w]=k,B.return(k))})}r.overrideFile=function(y,w){this.j?this.j.overrideFile(y,w):this.D[y]=w},r.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},r.send=function(y,w){var M=this,k,B,W,V,J,ce,Ie,Oe,lt;return F(function(tt){switch(tt.h){case 1:return M.h.inputs?(k=1e3*(w??performance.now()),x(tt,M.I,2)):tt.return();case 2:return x(tt,M.initialize(),3);case 3:for(B=new M.i.PacketDataList,W=a(Object.keys(y)),V=W.next();!V.done;V=W.next())if(J=V.value,ce=M.h.inputs[J]){e:{var Ge=y[J];switch(ce.type){case"video":var ut=M.s[ce.stream];if(ut||(ut=new cd(M.i,M.K),M.s[ce.stream]=ut),ut.m===0&&(ut.m=ut.i.createTexture()),typeof HTMLVideoElement<"u"&&Ge instanceof HTMLVideoElement)var vt=Ge.videoWidth,un=Ge.videoHeight;else typeof HTMLImageElement<"u"&&Ge instanceof HTMLImageElement?(vt=Ge.naturalWidth,un=Ge.naturalHeight):(vt=Ge.width,un=Ge.height);un={glName:ut.m,width:vt,height:un},vt=ut.h,vt.canvas.width=un.width,vt.canvas.height=un.height,vt.activeTexture(vt.TEXTURE0),ut.i.bindTexture2d(ut.m),vt.texImage2D(vt.TEXTURE_2D,0,vt.RGBA,vt.RGBA,vt.UNSIGNED_BYTE,Ge),ut.i.bindTexture2d(0),ut=un;break e;case"detections":for(ut=M.s[ce.stream],ut||(ut=new sA(M.i),M.s[ce.stream]=ut),ut.data||(ut.data=new ut.h.DetectionListData),ut.data.reset(Ge.length),un=0;un<Ge.length;++un){vt=Ge[un];var nn=ut.data,Un=nn.setBoundingBox,ti=un,vr=vt.la,Ft=new Uc;if(Dr(Ft,1,vr.sa),Dr(Ft,2,vr.ta),Dr(Ft,3,vr.height),Dr(Ft,4,vr.width),Dr(Ft,5,vr.rotation),Ln(Ft,6,vr.pa),vr=Ft.l(),Un.call(nn,ti,vr),vt.ea)for(nn=0;nn<vt.ea.length;++nn){Ft=vt.ea[nn],Un=ut.data,ti=Un.addNormalizedLandmark,vr=un,Ft=Object.assign({},Ft,{visibility:Ft.visibility?Ft.visibility:0});var Vn=new _u;Dr(Vn,1,Ft.x),Dr(Vn,2,Ft.y),Dr(Vn,3,Ft.z),Ft.visibility&&Dr(Vn,4,Ft.visibility),Ft=Vn.l(),ti.call(Un,vr,Ft)}if(vt.ba)for(nn=0;nn<vt.ba.length;++nn)Un=ut.data,ti=Un.addClassification,vr=un,Ft=vt.ba[nn],Vn=new Va,Dr(Vn,2,Ft.qa),Ft.index&&Ln(Vn,1,Ft.index),Ft.label&&Ln(Vn,3,Ft.label),Ft.displayName&&Ln(Vn,4,Ft.displayName),Ft=Vn.l(),ti.call(Un,vr,Ft)}ut=ut.data;break e;default:ut={}}}switch(Ie=ut,Oe=ce.stream,ce.type){case"video":B.pushTexture2d(Object.assign({},Ie,{stream:Oe,timestamp:k}));break;case"detections":lt=Ie,lt.stream=Oe,lt.timestamp=k,B.pushDetectionList(lt);break;default:throw Error("Unknown input config type: '"+ce.type+"'")}}return M.j.send(B),x(tt,M.I,4);case 4:B.delete(),tt.h=0}})};function dA(y,w,M){var k,B,W,V,J,ce,Ie,Oe,lt,tt,Ge,ut,vt,un;return F(function(nn){switch(nn.h){case 1:if(!M)return nn.return(w);for(k={},B=0,W=a(Object.keys(M)),V=W.next();!V.done;V=W.next())J=V.value,ce=M[J],typeof ce!="string"&&ce.type==="texture"&&w[ce.stream]!==void 0&&++B;1<B&&(y.M=!1),Ie=a(Object.keys(M)),V=Ie.next();case 2:if(V.done){nn.h=4;break}if(Oe=V.value,lt=M[Oe],typeof lt=="string")return vt=k,un=Oe,x(nn,pA(y,Oe,w[lt]),14);if(tt=w[lt.stream],lt.type==="detection_list"){if(tt){for(var Un=tt.getRectList(),ti=tt.getLandmarksList(),vr=tt.getClassificationsList(),Ft=[],Vn=0;Vn<Un.size();++Vn){var Ks=tA(Un.get(Vn)),gA=tn(Ks,1),yA=tn(Ks,2),_A=tn(Ks,3),bA=tn(Ks,4),xA=tn(Ks,5,0),Wc=void 0;Wc=Wc===void 0?0:Wc,Ks={la:{sa:gA,ta:yA,height:_A,width:bA,rotation:xA,pa:qs(bn(Ks,6),Wc)},ea:ud(ti.get(Vn)),ba:nA(QM(vr.get(Vn)))},Ft.push(Ks)}Un=Ft}else Un=[];k[Oe]=Un,nn.h=7;break}if(lt.type==="proto_list"){if(tt){for(Un=Array(tt.size()),ti=0;ti<tt.size();ti++)Un[ti]=tt.get(ti);tt.delete()}else Un=[];k[Oe]=Un,nn.h=7;break}if(tt===void 0){nn.h=3;break}if(lt.type==="float_list"){k[Oe]=tt,nn.h=7;break}if(lt.type==="proto"){k[Oe]=tt,nn.h=7;break}if(lt.type!=="texture")throw Error("Unknown output config type: '"+lt.type+"'");return Ge=y.v[Oe],Ge||(Ge=new cd(y.i,y.K),y.v[Oe]=Ge),x(nn,_0(Ge,tt,y.M),13);case 13:ut=nn.i,k[Oe]=ut;case 7:lt.transform&&k[Oe]&&(k[Oe]=lt.transform(k[Oe])),nn.h=3;break;case 14:vt[un]=nn.i;case 3:V=Ie.next(),nn.h=2;break;case 4:return nn.return(k)}})}function pA(y,w,M){var k;return F(function(B){return typeof M=="number"||M instanceof Uint8Array||M instanceof y.i.Uint8BlobList?B.return(M):M instanceof y.i.Texture2dDataOut?(k=y.v[w],k||(k=new cd(y.i,y.K),y.v[w]=k),B.return(_0(k,M,y.M))):B.return(void 0)})}function mA(y,w){for(var M=w.name||"$",k=[].concat(l(w.wants)),B=new y.i.StringList,W=a(w.wants),V=W.next();!V.done;V=W.next())B.push_back(V.value);W=y.i.PacketListener.implement({onResults:function(J){for(var ce={},Ie=0;Ie<w.wants.length;++Ie)ce[k[Ie]]=J.get(Ie);var Oe=y.listeners[M];Oe&&(y.I=dA(y,ce,w.outs).then(function(lt){lt=Oe(lt);for(var tt=0;tt<w.wants.length;++tt){var Ge=ce[k[tt]];typeof Ge=="object"&&Ge.hasOwnProperty&&Ge.hasOwnProperty("delete")&&Ge.delete()}lt&&(y.I=lt)}))}}),y.j.attachMultiListener(B,W),B.delete()}r.onResults=function(y,w){this.listeners[w||"$"]=y},H("Solution",hd),H("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function x0(y){switch(y===void 0&&(y=0),y){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function v0(y){var w=this;y=y||{},this.h=new hd({locateFile:y.locateFile,files:function(M){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:x0(M.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:ud},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:ud},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(M){var k,B,W;return F(function(V){return V.h==1?(k=x0(M),B="third_party/mediapipe/modules/pose_landmark/"+k,x(V,Vc(w.h,k),2)):(W=V.i,w.h.overrideFile(B,W),V.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}r=v0.prototype,r.reset=function(){this.h.reset()},r.close=function(){return this.h.close(),Promise.resolve()},r.onResults=function(y){this.h.onResults(y)},r.initialize=function(){var y=this;return F(function(w){return x(w,y.h.initialize(),0)})},r.send=function(y,w){var M=this;return F(function(k){return x(k,M.h.send(y,w),0)})},r.setOptions=function(y){this.h.setOptions(y)},H("Pose",v0),H("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),H("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),H("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),H("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),H("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),H("VERSION","0.5.1675469404")}).call(es);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$=1e-7,r$=1e-4;class i${constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Z1{refCount(e){return wr("refCount")}incRef(e){return wr("incRef")}timerAvailable(){return!0}time(e){return wr("time")}read(e){return wr("read")}readSync(e){return wr("readSync")}readToGPU(e,t){return wr("readToGPU")}numDataIds(){return wr("numDataIds")}disposeData(e,t){return wr("disposeData")}write(e,t,n){return wr("write")}move(e,t,n,i,s){return wr("move")}createTensorFromGPUData(e,t,n){return wr("createTensorFromGPUData")}memory(){return wr("memory")}floatPrecision(){return wr("floatPrecision")}epsilon(){return this.floatPrecision()===32?n$:r$}dispose(){return wr("dispose")}}function wr(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(r,e,t){const n=r[e];r[e]=r[t],r[t]=n}function s$(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function D(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Xr(r,e,t=""){D(br(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function lu(r){D(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ze(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function br(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function xc(r){return r%1===0}function Ph(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function o$(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=r.slice();return i[n]=e/t,i}function Yr(r,e){const t=e.length;return r=r==null?e.map((n,i)=>i):[].concat(r),D(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),D(r.every(n=>xc(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function a$(r,e){const t=[],n=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:Yr(e,r).sort();let o=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[o]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[o]==null||s[o]>a)&&r[a]===1&&(t.push(r[a]),n.push(a)),s[o]<=a&&o++}r[a]!==1&&(t.push(r[a]),n.push(a))}return{newShape:t,keptDims:n}}function Es(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Wn(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function l$(r,e){for(let t=0;t<r.length;t++){const n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function u$(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function c$(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function bm(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function h$(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function $f(r){return typeof r=="string"||r instanceof String}function f$(r){return typeof r=="boolean"}function d$(r){return typeof r=="number"}function zf(r){return Array.isArray(r)?zf(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":d$(r)?"float32":$f(r)?"string":f$(r)?"bool":"float32"}function xm(r){return!!(r&&r.constructor&&r.call&&r.apply)}function yr(r){const e=r.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function Q1(r,e,t,n=!1){const i=new Array;if(e.length===1){const s=e[0]*(n?2:1);for(let o=0;o<s;o++)i[o]=t[r+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(n?2:1);for(let l=0;l<s;l++)i[l]=Q1(r+l*a,o,t,n)}return i}function vm(r,e,t=!1){if(r.length===0)return e[0];const n=r.reduce((i,s)=>i*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Q1(0,r,e,t)}function p$(r,e){if(Array.isArray(r))return r;if(e==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(e==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${e}`)}function J1(r,e){const t=xs(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function xs(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function Zr(r){r.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function wm(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let i=0;i<r.length-1;++i)n+=t[i]*r[i];return n}function Sm(r,e,t){if(e===0)return[];if(e===1)return[r];const n=new Array(e);for(let i=0;i<n.length-1;++i)n[i]=Math.floor(r/t[i]),r-=n[i]*t[i];return n[n.length-1]=r,n}function Ta(r){return r&&r.then&&typeof r.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jb="tfjsflags";class m${constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=g$,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(it().getBool("IS_TEST")||it().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const i=this.urlFlags[e];it().getBool("IS_TEST")||it().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ta(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Jb in e&&e[Jb].split(",").forEach(n=>{const[i,s]=n.split(":");this.urlFlags[i]=_$(i,s)})}}function g$(r){const e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(y$(e,n[0],n[1]),n.join("="))),e}function y$(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function _$(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function it(){return eS}let eS=null;function b$(r){eS=r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hp;function tS(){if(hp==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");hp=r}return hp}function x$(){const r=tS();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function yy(r,e){const t=x$();if(t.has(r))return t.get(r);{const n=e();return t.set(r,n),t.get(r)}}const nS="Abs",rS="Acos",iS="Acosh",_y="Add",sS="AddN",oS="All",aS="Any",lS="ArgMax",uS="ArgMin",cS="Asin",hS="Asinh",fS="Atan",dS="Atanh",pS="Atan2",mS="AvgPool",v$="AvgPoolGrad",w$="AvgPool3D",gS="BatchMatMul",yS="BatchToSpaceND",_S="Bincount",S$="BroadcastArgs",by="Cast",bS="Ceil",xS="ClipByValue",vS="Complex",T$="ComplexAbs",wS="Concat",SS="Conv2D",TS="Conv2DBackpropFilter",ES="Conv2DBackpropInput",E$="Conv3D",M$="Conv3DBackpropInputV2",MS="Cos",AS="Cosh",IS="Cumprod",CS="Cumsum",kS="CropAndResize",NS="DenseBincount",RS="DepthToSpace",PS="DepthwiseConv2dNative",A$="DepthwiseConv2dNativeBackpropFilter",I$="DepthwiseConv2dNativeBackpropInput",LS="Diag",DS="Dilation2D",OS="RealDiv",FS="Einsum",$S="Elu",zS="Erf",BS="Equal",US="Exp",VS="ExpandDims",WS="Expm1",GS="FFT",HS="Fill",jS="FlipLeftRight",qS="Floor",KS="FloorDiv",XS="FusedBatchNorm",YS="GatherV2",ZS="GatherNd",QS="Greater",JS="GreaterEqual",xy="Identity",eT="IFFT",tT="Imag",nT="IsFinite",rT="IsInf",iT="IsNan",sT="LeakyRelu",oT="Less",aT="LessEqual",lT="LinSpace",uT="Log",cT="Log1p",hT="LogicalAnd",fT="LogicalNot",dT="LogicalOr",pT="LRN",mT="Max",gT="Maximum",yT="MaxPool",C$="MaxPool3D",k$="MaxPoolWithArgmax",_T="Mean",bT="Min",xT="Minimum",vT="MirrorPad",wT="Mod",N$="Multinomial",ST="Multiply",TT="Neg",ET="NotEqual",MT="NonMaxSuppressionV3",R$="NonMaxSuppressionV4",AT="NonMaxSuppressionV5",IT="OnesLike",CT="OneHot",kT="Pack",NT="PadV2",RT="Pow",PT="Prelu",LT="Prod",P$="RaggedGather",L$="RaggedRange",D$="RaggedTensorToTensor",DT="Range",OT="Real",FT="Reciprocal",$T="Relu",zT="Reshape",BT="ResizeNearestNeighbor",UT="ResizeBilinear",VT="Relu6",WT="Reverse",GT="Round",HT="Rsqrt",jT="ScatterNd",qT="SearchSorted",KT="Select",XT="Selu",YT="Slice",ZT="Sin",QT="Sinh",JT="Sign",e2="Sigmoid",t2="Softplus",n2="Sqrt",r2="Sum",i2="SpaceToBatchND",s2="SplitV",o2="Softmax",O$="SparseFillEmptyRows",F$="SparseReshape",$$="SparseSegmentMean",z$="SparseSegmentSum",a2="SparseToDense",l2="SquaredDifference",B$="Square",u2="StridedSlice",c2="StringNGrams",U$="StringSplit",V$="StringToHashBucketFast",h2="Sub",f2="Tan",d2="Tanh",vy="Tile",p2="TopK",m2="Transform",Lh="Transpose",W$="Unique",g2="Unpack",G$="UnsortedSegmentSum",y2="ZerosLike",_2="Step",Tm="FromPixels",b2="RotateWithOffset",Em="_FusedMatMul",Mm="FusedConv2D",Am="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(...r){it().getBool("IS_TEST")||it().getBool("PROD")||console.warn(...r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qh=yy("kernelRegistry",()=>new Map),H$=yy("gradRegistry",()=>new Map);function Im(r,e){const t=x2(r,e);return Qh.get(t)}function ex(r){return H$.get(r)}function tx(r){const e=Qh.entries(),t=[];for(;;){const{done:n,value:i}=e.next();if(n)break;const[s,o]=i,[a]=s.split("_");a===r&&t.push(o)}return t}function j$(r){const{kernelName:e,backendName:t}=r,n=x2(e,t);Qh.has(n)&&ul(`The kernel '${e}' for backend '${t}' is already registered`),Qh.set(n,r)}function x2(r,e){return`${e}_${r}`}var Cm=on,gi=null;try{gi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function on(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}on.prototype.__isLong__;Object.defineProperty(on.prototype,"__isLong__",{value:!0});function Pr(r){return(r&&r.__isLong__)===!0}on.isLong=Pr;var nx={},rx={};function Da(r,e){var t,n,i;return e?(r>>>=0,(i=0<=r&&r<256)&&(n=rx[r],n)?n:(t=an(r,(r|0)<0?-1:0,!0),i&&(rx[r]=t),t)):(r|=0,(i=-128<=r&&r<128)&&(n=nx[r],n)?n:(t=an(r,r<0?-1:0,!1),i&&(nx[r]=t),t))}on.fromInt=Da;function yi(r,e){if(isNaN(r))return e?ia:_i;if(e){if(r<0)return ia;if(r>=v2)return T2}else{if(r<=-sx)return Ar;if(r+1>=sx)return S2}return r<0?yi(-r,e).neg():an(r%jl|0,r/jl|0,e)}on.fromNumber=yi;function an(r,e,t){return new on(r,e,t)}on.fromBits=an;var Jh=Math.pow;function wy(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return _i;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return wy(r.substring(1),e,t).neg();for(var i=yi(Jh(t,8)),s=_i,o=0;o<r.length;o+=8){var a=Math.min(8,r.length-o),l=parseInt(r.substring(o,o+a),t);if(a<8){var u=yi(Jh(t,a));s=s.mul(u).add(yi(l))}else s=s.mul(i),s=s.add(yi(l))}return s.unsigned=e,s}on.fromString=wy;function Bi(r,e){return typeof r=="number"?yi(r,e):typeof r=="string"?wy(r,e):an(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}on.fromValue=Bi;var ix=1<<16,q$=1<<24,jl=ix*ix,v2=jl*jl,sx=v2/2,ox=Da(q$),_i=Da(0);on.ZERO=_i;var ia=Da(0,!0);on.UZERO=ia;var gl=Da(1);on.ONE=gl;var w2=Da(1,!0);on.UONE=w2;var km=Da(-1);on.NEG_ONE=km;var S2=an(-1,2147483647,!1);on.MAX_VALUE=S2;var T2=an(-1,-1,!0);on.MAX_UNSIGNED_VALUE=T2;var Ar=an(0,-2147483648,!1);on.MIN_VALUE=Ar;var Fe=on.prototype;Fe.toInt=function(){return this.unsigned?this.low>>>0:this.low};Fe.toNumber=function(){return this.unsigned?(this.high>>>0)*jl+(this.low>>>0):this.high*jl+(this.low>>>0)};Fe.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ar)){var t=yi(e),n=this.div(t),i=n.mul(t).sub(this);return n.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=yi(Jh(e,6),this.unsigned),o=this,a="";;){var l=o.div(s),u=o.sub(l.mul(s)).toInt()>>>0,c=u.toString(e);if(o=l,o.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};Fe.getHighBits=function(){return this.high};Fe.getHighBitsUnsigned=function(){return this.high>>>0};Fe.getLowBits=function(){return this.low};Fe.getLowBitsUnsigned=function(){return this.low>>>0};Fe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ar)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Fe.isZero=function(){return this.high===0&&this.low===0};Fe.eqz=Fe.isZero;Fe.isNegative=function(){return!this.unsigned&&this.high<0};Fe.isPositive=function(){return this.unsigned||this.high>=0};Fe.isOdd=function(){return(this.low&1)===1};Fe.isEven=function(){return(this.low&1)===0};Fe.equals=function(e){return Pr(e)||(e=Bi(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Fe.eq=Fe.equals;Fe.notEquals=function(e){return!this.eq(e)};Fe.neq=Fe.notEquals;Fe.ne=Fe.notEquals;Fe.lessThan=function(e){return this.comp(e)<0};Fe.lt=Fe.lessThan;Fe.lessThanOrEqual=function(e){return this.comp(e)<=0};Fe.lte=Fe.lessThanOrEqual;Fe.le=Fe.lessThanOrEqual;Fe.greaterThan=function(e){return this.comp(e)>0};Fe.gt=Fe.greaterThan;Fe.greaterThanOrEqual=function(e){return this.comp(e)>=0};Fe.gte=Fe.greaterThanOrEqual;Fe.ge=Fe.greaterThanOrEqual;Fe.compare=function(e){if(Pr(e)||(e=Bi(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Fe.comp=Fe.compare;Fe.negate=function(){return!this.unsigned&&this.eq(Ar)?Ar:this.not().add(gl)};Fe.neg=Fe.negate;Fe.add=function(e){Pr(e)||(e=Bi(e));var t=this.high>>>16,n=this.high&65535,i=this.low>>>16,s=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,u=e.low&65535,c=0,h=0,f=0,d=0;return d+=s+u,f+=d>>>16,d&=65535,f+=i+l,h+=f>>>16,f&=65535,h+=n+a,c+=h>>>16,h&=65535,c+=t+o,c&=65535,an(f<<16|d,c<<16|h,this.unsigned)};Fe.subtract=function(e){return Pr(e)||(e=Bi(e)),this.add(e.neg())};Fe.sub=Fe.subtract;Fe.multiply=function(e){if(this.isZero())return _i;if(Pr(e)||(e=Bi(e)),gi){var t=gi.mul(this.low,this.high,e.low,e.high);return an(t,gi.get_high(),this.unsigned)}if(e.isZero())return _i;if(this.eq(Ar))return e.isOdd()?Ar:_i;if(e.eq(Ar))return this.isOdd()?Ar:_i;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(ox)&&e.lt(ox))return yi(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,i=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,u=e.low>>>16,c=e.low&65535,h=0,f=0,d=0,g=0;return g+=o*c,d+=g>>>16,g&=65535,d+=s*c,f+=d>>>16,d&=65535,d+=o*u,f+=d>>>16,d&=65535,f+=i*c,h+=f>>>16,f&=65535,f+=s*u,h+=f>>>16,f&=65535,f+=o*l,h+=f>>>16,f&=65535,h+=n*c+i*u+s*l+o*a,h&=65535,an(d<<16|g,h<<16|f,this.unsigned)};Fe.mul=Fe.multiply;Fe.divide=function(e){if(Pr(e)||(e=Bi(e)),e.isZero())throw Error("division by zero");if(gi){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?gi.div_u:gi.div_s)(this.low,this.high,e.low,e.high);return an(t,gi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ia:_i;var n,i,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ia;if(e.gt(this.shru(1)))return w2;s=ia}else{if(this.eq(Ar)){if(e.eq(gl)||e.eq(km))return Ar;if(e.eq(Ar))return gl;var o=this.shr(1);return n=o.div(e).shl(1),n.eq(_i)?e.isNegative()?gl:km:(i=this.sub(e.mul(n)),s=n.add(i.div(e)),s)}else if(e.eq(Ar))return this.unsigned?ia:_i;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=_i}for(i=this;i.gte(e);){n=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:Jh(2,a-48),u=yi(n),c=u.mul(e);c.isNegative()||c.gt(i);)n-=l,u=yi(n,this.unsigned),c=u.mul(e);u.isZero()&&(u=gl),s=s.add(u),i=i.sub(c)}return s};Fe.div=Fe.divide;Fe.modulo=function(e){if(Pr(e)||(e=Bi(e)),gi){var t=(this.unsigned?gi.rem_u:gi.rem_s)(this.low,this.high,e.low,e.high);return an(t,gi.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Fe.mod=Fe.modulo;Fe.rem=Fe.modulo;Fe.not=function(){return an(~this.low,~this.high,this.unsigned)};Fe.and=function(e){return Pr(e)||(e=Bi(e)),an(this.low&e.low,this.high&e.high,this.unsigned)};Fe.or=function(e){return Pr(e)||(e=Bi(e)),an(this.low|e.low,this.high|e.high,this.unsigned)};Fe.xor=function(e){return Pr(e)||(e=Bi(e)),an(this.low^e.low,this.high^e.high,this.unsigned)};Fe.shiftLeft=function(e){return Pr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?an(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):an(0,this.low<<e-32,this.unsigned)};Fe.shl=Fe.shiftLeft;Fe.shiftRight=function(e){return Pr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?an(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):an(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Fe.shr=Fe.shiftRight;Fe.shiftRightUnsigned=function(e){if(Pr(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return an(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?an(t,0,this.unsigned):an(t>>>e-32,0,this.unsigned)};Fe.shru=Fe.shiftRightUnsigned;Fe.shr_u=Fe.shiftRightUnsigned;Fe.toSigned=function(){return this.unsigned?an(this.low,this.high,!1):this};Fe.toUnsigned=function(){return this.unsigned?this:an(this.low,this.high,!0)};Fe.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Fe.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Fe.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};on.fromBytes=function(e,t,n){return n?on.fromBytesLE(e,t):on.fromBytesBE(e,t)};on.fromBytesLE=function(e,t){return new on(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};on.fromBytesBE=function(e,t){return new on(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const K$=vA({__proto__:null,default:Cm},[Cm]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qo=Cm||K$;function Bf(r){return Qo.fromString(r,!0,16)}const E2=Bf("c3a5c85c97cb3127"),jo=Bf("b492b66fbe98f273"),er=Bf("9ae16a3b2f90404f");function Nm(r){return r.xor(r.shru(47))}function M2(r,e,t){const n=r.slice(e,e+t);return Qo.fromBytes(Array.from(n),!0,!0)}function Kt(r,e){return M2(r,e,8)}function ax(r,e){return M2(r,e,4)}function Cn(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function _o(r,e,t=Bf("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let i=e.xor(n).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function X$(r,e,t,n,i,s){i=i.add(r),s=Cn(s.add(i).add(n),21);const o=i;return i=i.add(e),i=i.add(t),s=s.add(Cn(i,44)),[i.add(n),s.add(o)]}function xh(r,e,t,n){return X$(Kt(r,e),Kt(r,e+8),Kt(r,e+16),Kt(r,e+24),t,n)}function Y$(r,e=r.length){if(e>=8){const t=er.add(e*2),n=Kt(r,0).add(er),i=Kt(r,e-8),s=Cn(i,37).mul(t).add(n),o=Cn(n,25).add(i).mul(t);return _o(s,o,t)}if(e>=4){const t=er.add(e*2),n=ax(r,0);return _o(n.shl(3).add(e),ax(r,e-4),t)}if(e>0){const t=r[0],n=r[e>>1],i=r[e-1],s=t+(n<<8),o=e+(i<<2);return Nm(er.mul(s).xor(E2.mul(o))).mul(er)}return er}function Z$(r,e=r.length){const t=er.add(e*2),n=Kt(r,0).mul(jo),i=Kt(r,8),s=Kt(r,e-8).mul(t),o=Kt(r,e-16).mul(er);return _o(Cn(n.add(i),43).add(Cn(s,30)).add(o),n.add(Cn(i.add(er),18)).add(s),t)}function Q$(r,e=r.length){const t=er.add(e*2),n=Kt(r,0).mul(er),i=Kt(r,8),s=Kt(r,e-8).mul(t),o=Kt(r,e-16).mul(er),a=Cn(n.add(i),43).add(Cn(s,30)).add(o),l=_o(a,n.add(Cn(i.add(er),18)).add(s),t),u=Kt(r,16).mul(t),c=Kt(r,24),h=a.add(Kt(r,e-32)).mul(t),f=l.add(Kt(r,e-24)).mul(t);return _o(Cn(u.add(c),43).add(Cn(h,30)).add(f),u.add(Cn(c.add(n),18)).add(h),t)}function J$(r,e=r.length){const t=Qo.fromNumber(81,!0);if(e<=32)return e<=16?Y$(r,e):Z$(r,e);if(e<=64)return Q$(r,e);let n=t,i=t.mul(jo).add(113),s=Nm(i.mul(er).add(113)).mul(er),o=[Qo.UZERO,Qo.UZERO],a=[Qo.UZERO,Qo.UZERO];n=n.mul(er).add(Kt(r,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do n=Cn(n.add(i).add(o[0]).add(Kt(r,l+8)),37).mul(jo),i=Cn(i.add(o[1]).add(Kt(r,l+48)),42).mul(jo),n=n.xor(a[1]),i=i.add(o[0]).add(Kt(r,l+40)),s=Cn(s.add(a[0]),33).mul(jo),o=xh(r,l,o[1].mul(jo),n.add(a[0])),a=xh(r,l+32,s.add(a[1]),i.add(Kt(r,l+16))),[s,n]=[n,s],l+=64;while(l!==u);const h=jo.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),n=Cn(n.add(i).add(o[0]).add(Kt(r,l+8)),37).mul(h),i=Cn(i.add(o[1]).add(Kt(r,l+48)),42).mul(h),n=n.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(Kt(r,l+40))),s=Cn(s.add(a[0]),33).mul(h),o=xh(r,l,o[1].mul(h),n.add(a[0])),a=xh(r,l+32,s.add(a[1]),i.add(Kt(r,l+16))),[s,n]=[n,s],_o(_o(o[0],a[0],h).add(Nm(i).mul(E2)).add(s),_o(o[1],a[1],h).add(n),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ez(r,e){return e==="string"?pa(r):Uf([r],e)}function tz(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Uf(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Ea(r)),it().getBool("DEBUG")&&l$(r,e),tz(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){const t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ef(){return it().platform.now()}function pa(r,e="utf-8"){return e=e||"utf-8",it().platform.encode(r,e)}function ql(r,e="utf-8"){return e=e||"utf-8",it().platform.decode(r,e)}function zi(r){return it().platform.isTypedArray(r)}function Ea(r,e=[],t=!1){if(e==null&&(e=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||Ta(r)||r==null||zi(r)&&t)e.push(r);else if(Array.isArray(r)||zi(r))for(let n=0;n<r.length;++n)Ea(r[n],e,t);else{let n=-1;for(const i of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(i)&&(n=Math.max(n,Number(i)));for(let i=0;i<=n;i++)Ea(r[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nz{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new iz)}profileKernel(e,t,n){let i;const s=()=>{i=n()};let o;const a=ef();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const u of i)u.dataSync();o=Promise.resolve({kernelMs:ef()-a})}if(it().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<i.length;u++){const c=i[u];c.data().then(h=>{rz(h,c.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:i,inputs:s,extraInfo:o}=e;n.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],s,l[2])})})}}function rz(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){const i=r[n];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class iz{logKernelProfile(e,t,n,i,s,o){const a=typeof i=="number"?Ph(`${i}ms`,9):i.error,l=Ph(e,25),u=t.rank,c=t.size,h=Ph(t.shape.toString(),14);let f="";for(const d in s){const g=s[d];if(g!=null){const p=g.shape||t.shape,m=p.length;f+=`${d}: ${m}D ${m>0?p:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sz(r,e,t){const n={},i={};for(let l=0;l<e.length;l++)n[e[l].id]=!0;for(let l=0;l<r.length;l++){const u=r[l],c=u.inputs;for(const h in c){const f=c[h];let d=!1;for(let g=0;g<e.length;g++)if(n[f.id]){u.outputs.forEach(p=>n[p.id]=!0),d=!0,i[u.id]=!0;break}if(d)break}}const s={};s[t.id]=!0;const o={};for(let l=r.length-1;l>=0;l--){const u=r[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(s[u.outputs[h].id]){for(const f in c)s[c[f].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<r.length;l++){const u=r[l];if(i[u.id]&&o[u.id]){const c={};for(const f in u.inputs){const d=u.inputs[f];n[d.id]&&(c[f]=d)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function oz(r,e,t,n){for(let i=e.length-1;i>=0;i--){const s=e[i],o=[];if(s.outputs.forEach(l=>{const u=r[l.id];u!=null?o.push(u):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=s.inputs[l];if(!br(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=u;else{const h=r[c.id];r[c.id]=n(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lx=20,Ru=3,fp=7;function az(r,e,t,n){const i=yr(e),s=lz(r,e,t,i),o=e.length,a=Dh(r,e,t,i,s),l=["Tensor"];return n&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function lz(r,e,t,n){const i=ze(e),s=n[n.length-1],o=new Array(s).fill(0),a=e.length,l=t==="complex64"?Uu(r):r;if(a>1)for(let u=0;u<i/s;u++){const c=u*s;for(let h=0;h<s;h++)o[h]=Math.max(o[h],Bu(l[c+h],0,t).length)}return o}function Bu(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(fp))} + ${parseFloat(r[1].toFixed(fp))}j`:$f(r)?n=`'${r}'`:t==="bool"?n=A2(r):n=parseFloat(r.toFixed(fp)).toString(),Ph(n,e)}function A2(r){return r===0?"false":"true"}function Dh(r,e,t,n,i,s=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const p=Uu(r);return[Bu(p[0],0,t)]}return t==="bool"?[A2(r[0])]:[r[0].toString()]}if(l===1){if(a>lx){const m=Ru*o;let _=Array.from(r.slice(0,m)),v=Array.from(r.slice((a-Ru)*o,a*o));return t==="complex64"&&(_=Uu(_),v=Uu(v)),["["+_.map((b,x)=>Bu(b,i[x],t)).join(", ")+", ..., "+v.map((b,x)=>Bu(b,i[a-Ru+x],t)).join(", ")+"]"]}return["["+(t==="complex64"?Uu(r):Array.from(r)).map((m,_)=>Bu(m,i[_],t)).join(", ")+"]"]}const u=e.slice(1),c=n.slice(1),h=n[0]*o,f=[];if(a>lx){for(let p=0;p<Ru;p++){const m=p*h,_=m+h;f.push(...Dh(r.slice(m,_),u,t,c,i,!1))}f.push("...");for(let p=a-Ru;p<a;p++){const m=p*h,_=m+h;f.push(...Dh(r.slice(m,_),u,t,c,i,p===a-1))}}else for(let p=0;p<a;p++){const m=p*h,_=m+h;f.push(...Dh(r.slice(m,_),u,t,c,i,p===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let p=1;p<f.length-1;p++)f[p]=" "+f[p]+d;let g=`,
`;for(let p=2;p<l;p++)g+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":g),f}function Uu(r){const e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vc{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ze(e),n!=null){const i=n.length;D(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Wn(t,this.size),this.strides=yr(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let i=0;i<e.length-1;++i)n+=this.strides[i]*e[i];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ri().makeTensor(this.values,this.shape,this.dtype)}}let Ri=null,cl=null;function uz(r){Ri=r}function cz(r){cl=r}class dn{constructor(e,t,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ze(e),this.strides=yr(e),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return cl.buffer(this.shape,this.dtype,e)}bufferSync(){return cl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return vm(this.shape,e,this.dtype==="complex64")}arraySync(){return vm(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ri().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>ql(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ri().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ri().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ql(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ri().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ri().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return cl.print(this,e)}clone(){return this.throwIfDisposed(),cl.clone(this)}toString(e=!1){const t=this.dataSync();return az(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),cl.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ri().makeVariable(this,e,t,n)}}Object.defineProperty(dn,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function hz(){return yy("Tensor",()=>dn)}hz();class tf extends dn{constructor(e,t,n,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!br(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ri().disposeTensor(this),this.dataId=e.dataId,Ri().incRef(this,null)}dispose(){Ri().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(tf,Symbol.hasInstance,{value:r=>r instanceof dn&&r.assign!=null&&r.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ux;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(ux||(ux={}));var Rm;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(Rm||(Rm={}));var Pm;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(Pm||(Pm={}));var Lm;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(Lm||(Lm={}));var Dm;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(Dm||(Dm={}));const fz={float32:Lm,int32:Rm,bool:Pm,complex64:Dm};function Ma(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return fz[r][e]}function dz(r){return Ma(r,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(r,e){if(r.dtype===e.dtype)return[r,e];const t=Ma(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function pz(r,e){D(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function I2(r){const e=[];return C2(r,e,new Set),e}function C2(r,e,t){if(r==null)return;if(r instanceof dn){e.push(r);return}if(!mz(r))return;const n=r;for(const i in n){const s=n[i];t.has(s)||(t.add(s),C2(s,e,t))}}function mz(r){return Array.isArray(r)||typeof r=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(r){return r.kernelName!=null}class cx{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Kl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new cx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ul(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new nz(this.backendInstance),!0}setupRegisteredKernels(){tx(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){tx(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(n&&!(n instanceof Z1)&&typeof n.then=="function"){const i=++this.pendingBackendInitId,s=n.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,ul(`Initialization of backend ${e} failed`),ul(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return ul(`Initialization of backend ${e} failed`),ul(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:i,asyncInit:s}=this.initializeBackend(n);if(s||i)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),i=n.backend,s=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let i;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,n){e();try{const i=n();return t(),i}catch(i){throw t(),i}}nextTensorId(){return Kl.nextTensorId++}nextVariableId(){return Kl.nextVariableId++}clone(e){const t=X.runKernel(xy,{x:e}),n={x:e},i=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return X.runKernel(by,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],i,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Im(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const i=this.backend.numDataIds();let s=0;n.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const i=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=dp(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(dp(e)){const{kernelName:g,inputs:p,attrs:m}=e;this.backendName==null&&this.backend;const _=Im(g,this.backendName);D(_!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const v=this.backend.numDataIds();l=_.kernelFunc({inputs:p,attrs:m,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,v,b);const x=b.map(T=>T.rank!=null?T:this.makeTensorFromTensorInfo(T));if(i){const T=this.getTensorsForGradient(g,p,x);n=this.saveTensorsForBackwardMode(T)}return x}}else{const{forwardFunc:g}=e,p=m=>{i&&(n=m.map(_=>this.keep(this.clone(_))))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,p));const _=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,m,_),_}}const{inputs:c,attrs:h}=e,f=dp(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),i&&this.addTapeNode(u,c,t,f,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){const i=ex(e);if(i!=null){const s=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=s.map(u=>t[u]);const l=n.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,t,n,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",i=i||this.backend;let s=e;n==="string"&&$f(e[0])&&(s=e.map(l=>pa(l)));const o=i.write(s,t,n),a=new dn(t,n,o,this.nextTensorId());if(this.trackTensor(a,i),n==="string"){const l=this.state.tensorInfo.get(o),u=h$(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,n,i){n=n||"float32";const s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:i,dtype:s}=e,o=new dn(i,s,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,n,i){n=n||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new tf(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*bm(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof tf||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*bm(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,i,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},l=ex(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const f=n[h],d=xs(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return c}),i(u.length>1?u:u[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=I2(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!n.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,t,n,i=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(s instanceof dn,()=>"The result y returned by f() must be a tensor.");const o=sz(this.state.activeTape,t,s);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=n??gz(s.shape),oz(a,o,u=>this.tidy(u),yz);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return D(xm(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(a=>a instanceof dn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const i={};t.forEach((a,l)=>{i[l]=a});const s=(a,l)=>(n=e(...t,l),D(n.value instanceof dn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(xm(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),o=(a,l)=>{const u=n.gradFunc(a,l),c=Array.isArray(u)?u:[u];D(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(c.every(f=>f instanceof dn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ef(),n=await this.backend.time(e);return n.wallMs=ef()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new cx;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Kl.nextTensorId=0;Kl.nextVariableId=0;function gz(r){const e=J1(ze(r),"float32");return X.makeTensor(e,r,"float32")}function k2(){const r=tS();if(r._tfengine==null){const e=new m$(r);r._tfengine=new Kl(e)}return b$(r._tfengine.ENV),uz(()=>r._tfengine),r._tfengine}const X=k2();function yz(r,e){const t={a:r,b:e};return X.runKernel(_y,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _z(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qr=it();qr.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});qr.registerFlag("IS_BROWSER",()=>_z());qr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");qr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));qr.registerFlag("PROD",()=>!1);qr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>qr.getBool("DEBUG"));qr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);qr.registerFlag("IS_TEST",()=>!1);qr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);qr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);qr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);qr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(r,e){let t=r;if(zi(r))return e==="string"?[]:[r.length];if(typeof r=="object"){if("texture"in r){const s=r.channels||"RGBA";return[r.height,r.width*s.length]}else if("buffer"in r&&!(r.buffer instanceof ArrayBuffer))return[r.buffer.size/(e==null?4:bm(e))]}if(!Array.isArray(r))return[];const i=[];for(;Array.isArray(t)||zi(t)&&e!=="string";)i.push(t.length),t=t[0];return Array.isArray(r)&&it().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&N2(r,i,[]),i}function N2(r,e,t){if(t=t||[],!Array.isArray(r)&&!zi(r)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),D(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);const n=e.slice(1);for(let i=0;i<r.length;++i)N2(r[i],n,t.concat(i))}function hx(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function P(r,e,t,n="numeric"){if(r instanceof dn)return hx(n,r.dtype,e,t),r;let i=zf(r);if(i!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(i=n),hx(n,i,e,t),r==null||!zi(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){const l=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const s=Co(r,i);!zi(r)&&!Array.isArray(r)&&(r=[r]);const a=i!=="string"?Uf(r,i):Ea(r,[],!0);return X.makeTensor(a,s,i)}function nf(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,o)=>P(s,`${e}[${o}]`,t,n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R2="__op";function K(r){const e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+R2;const i=(...s)=>{X.startScope(t);try{const o=n(...s);return Ta(o)&&console.error("Cannot return a Promise inside of tidy."),X.endScope(o),o}catch(o){throw X.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bz(r,e){const t=P(r,"real","complex"),n=P(e,"imag","complex");Xr(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);const i={real:t,imag:n};return X.runKernel(vS,i)}const Eo=K({complex_:bz});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ko(r,e,t,n){if(n==null)n=zf(r);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof r=="object"&&("texture"in r||"buffer"in r&&!(r.buffer instanceof ArrayBuffer))){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return X.backend.createTensorFromGPUData(r,e||t,n)}if(!zi(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Zr(e);const i=ze(e),s=ze(t);D(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==ze(e.slice(o)):!0;D(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!zi(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Uf(r,n):Ea(r,[],!0),X.makeTensor(r,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(r,e,t){const n=Co(r,t);return ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Om={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rf=4;async function xz(r,e){const t=[],n=[],i=Array.isArray(r)?r.map(o=>o.name):Object.keys(r);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(r)?r[o].tensor:r[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const f=await l.bytes(),d=f.reduce((m,_)=>m+_.length,0)+rf*f.length,g=new Uint8Array(d);let p=0;for(let m=0;m<f.length;m++){const _=f[m],v=new Uint8Array(new Uint32Array([_.length]).buffer);g.set(v,p),p+=rf,g.set(_,p),p+=_.length}h(g)});n.push(c)}else n.push(l.data());e!=null&&(u.group=e),t.push(u)}const s=await Promise.all(n);return{data:vz(s),specs:t}}function P2(r,e){const t={};let n,i=0;for(const s of e){const o=s.name,a=s.dtype,l=s.shape,u=ze(l);let c;if("quantization"in s){const h=s.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${s.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const f=Om[h.dtype],d=r.slice(i,i+u*f),g=h.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(g.length);for(let p=0;p<g.length;p++){const m=g[p];c[p]=m*h.scale+h.min}}else if(h.dtype==="float16")n===void 0&&(n=Az()),c=n(g);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(g.length);for(let p=0;p<g.length;p++){const m=g[p];c[p]=Math.round(m*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);i+=u*f}else if(a==="string"){const h=ze(s.shape);c=[];for(let f=0;f<h;f++){const d=new Uint32Array(r.slice(i,i+rf))[0];i+=rf;const g=new Uint8Array(r.slice(i,i+d));c.push(g),i+=d}}else{const h=Om[a],f=r.slice(i,i+u*h);if(a==="float32")c=new Float32Array(f);else if(a==="int32")c=new Int32Array(f);else if(a==="bool")c=new Uint8Array(f);else if(a==="complex64"){c=new Float32Array(f);const d=new Float32Array(c.length/2),g=new Float32Array(c.length/2);for(let _=0;_<d.length;_++)d[_]=c[_*2],g[_]=c[_*2+1];const p=ts(d,l,"float32"),m=ts(g,l,"float32");t[o]=Eo(p,m),p.dispose(),m.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);i+=u*h}a!=="complex64"&&(t[o]=ts(c,l,a))}return t}function vz(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0;const t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const n=new Uint8Array(e);let i=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),n.buffer}const Sy=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function fx(r){return Sy?Buffer.byteLength(r):new Blob([r]).size}function wz(r){if(Sy)return Buffer.from(r).toString("base64");const e=new Uint8Array(r);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function Sz(r){if(Sy){const n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function Ty(r){if(r.length===1)return r[0];let e=0;r.forEach(i=>{e+=i.byteLength});const t=new Uint8Array(e);let n=0;return r.forEach(i=>{t.set(new Uint8Array(i),n),n+=i.byteLength}),t.buffer}function dx(r){const e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);const t=r.split(e);return t[t.length-1]}function L2(r,e){const t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(t.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}function D2(r,e,t){const n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),n}async function Ey(r,e){let t,n;return r.weightsManifest!=null&&([t,n]=await e(r.weightsManifest)),D2(r,t,n)}function Dc(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:fx(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:fx(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function O2(r){const e=[];for(const t of r)e.push(...t.weights);return e}function Tz(){const r=t=>{let n=t<<13,i=0;for(;!(n&8388608);)i-=8388608,n<<=1;return n&=-8388609,i+=947912704,n|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Ez(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function Mz(){const r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function Az(){const r=Tz(),e=Ez(),t=Mz();return n=>{const i=new ArrayBuffer(4*n.length),s=new Uint32Array(i);for(let o=0;o<n.length;o++){const a=n[o],l=r[t[a>>10]+(a&1023)]+e[a>>10];s[o]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return hn.instance==null&&(hn.instance=new hn),hn.instance}static registerSaveRouter(e){hn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){hn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return hn.getHandlers(e,"save")}static getLoadHandlers(e,t){return hn.getHandlers(e,"load",t)}static getHandlers(e,t,n){const i=[];return(t==="load"?hn.getInstance().loadRouters:hn.getInstance().saveRouters).forEach(o=>{const a=o(e,n);a!==null&&i.push(a)}),i}}const Iz=r=>hn.registerSaveRouter(r),Cz=r=>hn.registerLoadRouter(r),kz=r=>hn.getSaveHandlers(r),Nz=(r,e)=>hn.getLoadHandlers(r,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm="tensorflowjs",$m=1,sa="models_store",uo="model_info_store";function F2(){if(!it().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const r=typeof window>"u"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function zm(r){const e=r.result;e.createObjectStore(sa,{keyPath:"modelPath"}),e.createObjectStore(uo,{keyPath:"modelPath"})}class Aa{constructor(e){if(this.indexedDB=F2(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,i)=>{const s=this.indexedDB.open(Fm,$m);s.onupgradeneeded=()=>zm(s),s.onsuccess=()=>{const o=s.result;if(t==null){const a=o.transaction(sa,"readonly"),u=a.objectStore(sa).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=c=>(o.close(),i(u.error)),a.oncomplete=()=>o.close()}else{const a=Dc(t),l=o.transaction(uo,"readwrite");let u=l.objectStore(uo);const c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;c.onsuccess=()=>{h=o.transaction(sa,"readwrite");const d=h.objectStore(sa).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>n({modelArtifactsInfo:a}),d.onerror=g=>{u=l.objectStore(uo);const p=u.delete(this.modelPath);p.onsuccess=()=>(o.close(),i(d.error)),p.onerror=m=>(o.close(),i(d.error))}},c.onerror=f=>(o.close(),i(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},s.onerror=o=>i(s.error)})}}Aa.URL_SCHEME="indexeddb://";const $2=r=>it().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Aa.URL_SCHEME)?Rz(r.slice(Aa.URL_SCHEME.length)):null;hn.registerSaveRouter($2);hn.registerLoadRouter($2);function Rz(r){return new Aa(r)}function Pz(r){return r.startsWith(Aa.URL_SCHEME)?r.slice(Aa.URL_SCHEME.length):r}class Lz{constructor(){this.indexedDB=F2()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(Fm,$m);n.onupgradeneeded=()=>zm(n),n.onsuccess=()=>{const i=n.result,s=i.transaction(uo,"readonly"),a=s.objectStore(uo).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),t(a.error)),s.oncomplete=()=>i.close()},n.onerror=i=>t(n.error)})}async removeModel(e){return e=Pz(e),new Promise((t,n)=>{const i=this.indexedDB.open(Fm,$m);i.onupgradeneeded=()=>zm(i),i.onsuccess=()=>{const s=i.result,o=s.transaction(uo,"readwrite"),a=o.objectStore(uo),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=s.transaction(sa,"readwrite");const d=u.objectStore(sa).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=g=>n(l.error)};c.onsuccess=h,c.onerror=f=>(h(),s.close(),n(l.error))}},l.onerror=c=>(s.close(),n(l.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},i.onerror=s=>n(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vs="/",hl="tensorflowjs_models",z2="info",Dz="model_topology",Oz="weight_specs",Fz="weight_data",$z="model_metadata";function B2(r){return{info:[hl,r,z2].join(vs),topology:[hl,r,Dz].join(vs),weightSpecs:[hl,r,Oz].join(vs),weightData:[hl,r,Fz].join(vs),modelMetadata:[hl,r,$z].join(vs)}}function U2(r){for(const e of Object.values(r))window.localStorage.removeItem(e)}function zz(r){const e=r.split(vs);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(vs)}function Bz(r){return r.startsWith(Ia.URL_SCHEME)?r.slice(Ia.URL_SCHEME.length):r}class Ia{constructor(e){if(!it().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=B2(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),i=Dc(e);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,wz(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:i}}catch{throw U2(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Sz(o),t}}Ia.URL_SCHEME="localstorage://";const V2=r=>it().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ia.URL_SCHEME)?Uz(r.slice(Ia.URL_SCHEME.length)):null;hn.registerSaveRouter(V2);hn.registerLoadRouter(V2);function Uz(r){return new Ia(r)}class Vz{constructor(){D(it().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=hl+vs,n=vs+z2;for(let i=0;i<this.LS.length;++i){const s=this.LS.key(i);if(s.startsWith(t)&&s.endsWith(n)){const o=zz(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=Bz(e);const t=B2(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return U2(t),n}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Al="://";class Qn{constructor(){this.managers={}}static getInstance(){return Qn.instance==null&&(Qn.instance=new Qn),Qn.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Al)&&(e=e.slice(0,e.indexOf(Al))),D(e.length>0,()=>"scheme must not be an empty string.");const n=Qn.getInstance();D(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=Qn.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Qn.getInstance().managers)}}function Oh(r){if(r.indexOf(Al)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Qn.getSchemes().join(",")}`);return{scheme:r.split(Al)[0],path:r.split(Al)[1]}}async function W2(r,e,t=!1){D(r!==e,()=>`Old path and new path are the same: '${r}'`);const n=hn.getLoadHandlers(r);D(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),D(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);const i=n[0],s=hn.getSaveHandlers(e);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);const o=s[0],a=Oh(r).scheme,l=Oh(r).path,u=a===Oh(r).scheme,c=await i.load();t&&u&&await Qn.getManager(a).removeModel(l);const h=await o.save(c);return t&&!u&&await Qn.getManager(a).removeModel(l),h.modelArtifactsInfo}async function Wz(){const r=Qn.getSchemes(),e={};for(const t of r){const n=await Qn.getManager(t).listModels();for(const i in n){const s=t+Al+i;e[s]=n[i]}}return e}async function Gz(r){const e=Oh(r);return Qn.getManager(e.scheme).removeModel(e.path)}async function Hz(r,e){return W2(r,e,!1)}async function jz(r,e){return W2(r,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!it().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();const i=this.functionRefs[n.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if(it().get("IS_BROWSER")){it().setPlatform("browser",new qz);try{Qn.registerManager(Ia.URL_SCHEME,new Vz)}catch{}try{Qn.registerManager(Aa.URL_SCHEME,new Lz)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kz={importFetch:()=>require("node-fetch")};let pp;class Xz{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return it().global.fetch!=null?it().global.fetch(e,t):(pp==null&&(pp=Kz.importFetch()),pp(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}it().get("IS_NODE")&&!it().get("IS_BROWSER")&&it().setPlatform("node",new Xz);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rn(r,e="float32",t){return e=e||"float32",Zr(r),new vc(r,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yz(r,e){const t=P(r,"x","cast");if(!u$(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},i={dtype:e};return X.runKernel(by,n,i)}const ln=K({cast_:Yz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(r){const t={x:P(r,"x","clone","string_or_numeric")};return X.runKernel(xy,t)}const bo=K({clone_:Zz});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2(r,e=!1){console.log(r.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */k2();const Qz={buffer:rn,cast:ln,clone:bo,print:G2};cz(Qz);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(){return X}function ht(r,e){return X.tidy(r,e)}function zt(r){I2(r).forEach(t=>t.dispose())}function Zi(r){return X.keep(r)}function sf(){return X.backendName}function Jz(r,e,t=1){return X.registerBackend(r,e,t)}function wc(){return X.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(r,e){let t=P(r,"a","add"),n=P(e,"b","add");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(_y,i)}const Ye=K({add_:eB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(r,e){let t=P(r,"a","floorDiv"),n=P(e,"b","floorDiv");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(KS,i)}const H2=K({floorDiv_:tB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(r,e){let t=P(r,"a","div"),n=P(e,"b","div");if([t,n]=yn(t,n),t.dtype==="int32"&&n.dtype==="int32")return H2(t,n);const i={a:t,b:n},s={};return X.runKernel(OS,i,s)}const bt=K({div_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(r,e){let t=P(r,"a","mul"),n=P(e,"b","mul");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(ST,i)}const Ce=K({mul_:rB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(r){const e=P(r,"x","abs");if(e.dtype==="complex64"){const t={x:e};return X.runKernel(T$,t)}else{const t={x:e};return X.runKernel(nS,t)}}const $r=K({abs_:iB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(r){const t={x:P(r,"x","acos")};return X.runKernel(rS,t)}const oB=K({acos_:sB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(r){const t={x:P(r,"x","acosh")};return X.runKernel(iS,t)}const lB=K({acosh_:aB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(r){D(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),D(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const e=r.map((i,s)=>P(i,`tensors${s}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!br(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return X.runKernel(sS,n)}const cB=K({addN_:uB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(r,e=null,t=!1){const i={x:P(r,"x","all","bool")},s={axis:e,keepDims:t};return X.runKernel(oS,i,s)}const fB=K({all_:hB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(r,e=null,t=!1){const i={x:P(r,"x","any","bool")},s={axis:e,keepDims:t};return X.runKernel(aS,i,s)}const pB=K({any_:dB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(r,e=0){const n={x:P(r,"x","argMax")},i={axis:e};return X.runKernel(lS,n,i)}const j2=K({argMax_:mB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(r,e=0){const n={x:P(r,"x","argMin")},i={axis:e};return X.runKernel(uS,n,i)}const yB=K({argMin_:gB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(r){const t={x:P(r,"x","asin")};return X.runKernel(cS,t)}const bB=K({asin_:_B});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(r){const t={x:P(r,"x","asinh")};return X.runKernel(hS,t)}const vB=K({asinh_:xB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(r){const t={x:P(r,"x","atan")};return X.runKernel(fS,t)}const SB=K({atan_:wB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(r,e){let t=P(r,"a","atan2"),n=P(e,"b","atan2");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(pS,i)}const EB=K({atan2_:TB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(r){const t={x:P(r,"x","atanh")};return X.runKernel(dS,t)}const AB=K({atanh_:MB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(r,e,t,n,i="NHWC",s){const o=r[3],a=[...e,o],l=uu(i);return as(r,a,t,s,n,null,null,l)}function Vf(r,e,t,n,i,s,o="channelsLast"){const[a,l]=Sc(e);let u;if(o==="channelsLast")u=[a,l,r[3],r[3]];else if(o==="channelsFirst")u=[a,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${o}`);return as(r,u,t,n,i,s,!1,o)}function as(r,e,t,n,i,s,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=r;else if(a==="channelsFirst")[l,h,u,c]=r;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,g]=e,[p,m]=Sc(t),[_,v]=Sc(n),b=Bm(f,_),x=Bm(d,v),{padInfo:T,outHeight:I,outWidth:C}=NB(i,u,c,p,m,b,x,s,a),S=o?g*h:g;let A;return a==="channelsFirst"?A=[l,S,I,C]:a==="channelsLast"&&(A=[l,I,C,S]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:I,outWidth:C,outChannels:S,padInfo:T,strideHeight:p,strideWidth:m,filterHeight:f,filterWidth:d,effectiveFilterHeight:b,effectiveFilterWidth:x,dilationHeight:_,dilationWidth:v,inShape:r,outShape:A,filterShape:e}}function CB(r,e,t,n,i){n==null&&(n=kB(r,e,t));const s=r[0],o=r[1],a=of((s-e+2*n)/t+1,i),l=of((o-e+2*n)/t+1,i);return[a,l]}function kB(r,e,t,n=1){const i=Bm(e,n);return Math.floor((r[0]*(t-1)-t+i)/2)}function Sc(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Bm(r,e){return e<=1?r:r+(r-1)*(e-1)}function NB(r,e,t,n,i,s,o,a,l){let u,c,h;if(typeof r=="number"){u={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};const d=CB([e,t],s,n,r,a);c=d[0],h=d[1]}else if(r==="same"){c=Math.ceil(e/n),h=Math.ceil(t/i);const f=Math.max(0,(c-1)*n+s-e),d=Math.max(0,(h-1)*i+o-t),g=Math.floor(f/2),p=f-g,m=Math.floor(d/2),_=d-m;u={top:g,bottom:p,left:m,right:_,type:"SAME"}}else if(r==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/n),h=Math.ceil((t-o+1)/i);else if(typeof r=="object"){const f=l==="channelsLast"?r[1][0]:r[2][0],d=l==="channelsLast"?r[1][1]:r[2][1],g=l==="channelsLast"?r[2][0]:r[3][0],p=l==="channelsLast"?r[2][1]:r[3][1];u={top:f,bottom:d,left:g,right:p,type:f===0&&d===0&&g===0&&p===0?"VALID":"EXPLICIT"},c=of((e-s+f+d)/n+1,a),h=of((t-o+g+p)/i+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:u,outHeight:c,outWidth:h}}function of(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function af(r){const[e,t,n]=Sc(r);return e===1&&t===1&&n===1}function Us(r,e){return af(r)||af(e)}function Xl(r){return Sc(r).every(e=>e>0)}function uu(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Ui(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")D(xc(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(i=>{D(xc(i),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(r,e){const n={x:P(r,"x","reshape","string_or_numeric")},i={shape:e};return X.runKernel(zT,n,i)}const ye=K({reshape_:RB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(r,e,t,n,i){const s=P(r,"x","avgPool","float32"),o=1;D(Us(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Ui("avgPool",n,i);const u={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i};let h=X.runKernel(mS,u,c);return h=ln(h,s.dtype),l?ye(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const q2=K({avgPool_:PB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(r,e,t,n,i,s="NDHWC"){const o=P(r,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),D(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Ui("avgPool3d",n,i);const u={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:s};let h=X.runKernel(w$,u,c);return h=ln(h,a.dtype),l?ye(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const DB=K({avgPool3d_:LB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(r,e=0){D(r.length>=1,()=>"Pass at least one tensor to concat");const t=nf(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return bo(t[0]);const n=t,i={axis:e};return X.runKernel(wS,n,i)}const kn=K({concat_:OB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(r,e,t=!1,n=!1){let i=P(r,"a","matMul"),s=P(e,"b","matMul");[i,s]=yn(i,s);const o={a:i,b:s},a={transposeA:t,transposeB:n};return X.runKernel(gS,o,a)}const Wt=K({matMul_:FB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(r){const t={x:P(r,"x","sigmoid","float32")};return X.runKernel(e2,t)}const Is=K({sigmoid_:$B});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(r,e,t){const n=P(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const i={x:n},s={begin:e,size:t};return X.runKernel(YT,i,s)}const _t=K({slice_:zB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(r){const t={x:P(r,"x","tanh","float32")};return X.runKernel(d2,t)}const Um=K({tanh_:BB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(r,e,t,n,i,s){const o=P(r,"forgetBias","basicLSTMCell"),a=P(e,"lstmKernel","basicLSTMCell"),l=P(t,"lstmBias","basicLSTMCell"),u=P(n,"data","basicLSTMCell"),c=P(i,"c","basicLSTMCell"),h=P(s,"h","basicLSTMCell"),f=kn([u,h],1),d=Wt(f,a),g=Ye(d,l),p=g.shape[0],m=g.shape[1]/4,_=[p,m],v=_t(g,[0,0],_),b=_t(g,[0,m],_),x=_t(g,[0,m*2],_),T=_t(g,[0,m*3],_),I=Ye(Ce(Is(v),Um(b)),Ce(c,Is(Ye(o,x)))),C=Ce(Um(I),Is(T));return[I,C]}const VB=K({basicLSTMCell_:UB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(r,e,t){const n=P(r,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);D(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(n.shape[0]%i===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const s={x:n},o={blockShape:e,crops:t};return X.runKernel(yS,s,o)}const K2=K({batchToSpaceND_:WB});function GB(r){let e;return r.rank===0||r.rank===1?e=ye(r,[1,1,1,r.size]):r.rank===2?e=ye(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=ye(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(r,e,t,n,i,s){s==null&&(s=.001);const o=P(r,"x","batchNorm"),a=P(e,"mean","batchNorm"),l=P(t,"variance","batchNorm");let u;i!=null&&(u=P(i,"scale","batchNorm"));let c;n!=null&&(c=P(n,"offset","batchNorm")),D(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:GB(o),scale:u,offset:c,mean:a,variance:l},d={varianceEpsilon:s},g=X.runKernel(XS,f,d);return ye(g,o.shape)}const Wf=K({batchNorm_:HB});function jB(r,e,t,n,i,s){const o=P(r,"x","batchNorm"),a=P(e,"mean","batchNorm"),l=P(t,"variance","batchNorm");let u;i!=null&&(u=P(i,"scale","batchNorm"));let c;return n!=null&&(c=P(n,"offset","batchNorm")),D(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),D(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Wf(o,a,l,c,u,s)}const qB=K({batchNorm2d_:jB});function KB(r,e,t,n,i,s){const o=P(r,"x","batchNorm"),a=P(e,"mean","batchNorm"),l=P(t,"variance","batchNorm");let u;i!=null&&(u=P(i,"scale","batchNorm"));let c;return n!=null&&(c=P(n,"offset","batchNorm")),D(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),D(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Wf(o,a,l,c,u,s)}const XB=K({batchNorm3d_:KB});function YB(r,e,t,n,i,s){const o=P(r,"x","batchNorm"),a=P(e,"mean","batchNorm"),l=P(t,"variance","batchNorm");let u;i!=null&&(u=P(i,"scale","batchNorm"));let c;return n!=null&&(c=P(n,"offset","batchNorm")),D(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),D(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Wf(o,a,l,c,u,s)}const ZB=K({batchNorm4d_:YB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(r,e,t){const n=P(r,"x","bincount"),i=P(e,"weights","bincount");D(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(i.size===n.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${i.shape}.`);const s={x:n,weights:i},o={size:t};return X.runKernel(_S,s,o)}const X2=K({bincount_:QB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(r,e){const t=P(r,"s0","broadcastArgs","int32"),n=P(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const i={s0:t,s1:n};return X.runKernel(S$,i)}const eU=K({broadcastArgs_:JB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(r,e){let t=P(r,"broadcastTo","x");const n=t.shape;if(Zr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=ye(t,u)}const i=t.shape,s=Array.from(e);for(let u=e.length-1;u>=0;u--)if(i[u]===e[u])s[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return bo(t);const a={x:t},l={reps:s};return X.runKernel(vy,a,l)}const Ju=K({broadcastTo_:tU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(r){const t={x:P(r,"x","ceil","float32")};return X.runKernel(bS,t)}const rU=K({ceil_:nU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(r,e,t){Zr(r);const n={shape:r,value:e,dtype:t};return X.runKernel(HS,{},n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(r,e,t){const n=P(r,"x","clipByValue");if(D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Oc(n.shape,e,n.dtype);const i={x:n},s={clipValueMin:e,clipValueMax:t};return X.runKernel(xS,i,s)}const Y2=K({clipByValue_:iU});function sU(r){return kn(r,0)}const oU=K({concat1d_:sU});function aU(r,e){return kn(r,e)}const lU=K({concat2d_:aU});function uU(r,e){return kn(r,e)}const cU=K({concat3d_:uU});function hU(r,e){return kn(r,e)}const fU=K({concat4d_:hU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(r,e,t,n,i="NHWC",s=[1,1],o){const a=P(r,"x","conv2d","float32"),l=P(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Ui("conv2d",n,o);const h=i==="NHWC"?u.shape[3]:u.shape[1];D(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),D(Us(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(Xl(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Xl(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:u,filter:l},d={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:o},g=X.runKernel(SS,f,d);return c?ye(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Gf=K({conv2d_:dU});function pU(r,e,t,n,i="NWC",s=1,o){const a=P(r,"x","conv1d"),l=P(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=ye(a,[1,a.shape[0],a.shape[1]])),D(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),D(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Ui("conv1d",n,o),D(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(Us(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),D(Xl(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Xl(t),()=>"Error in conv1D: Stride should be larger than 0."),D(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=ye(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=ye(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=Gf(f,h,[1,t],n,"NHWC",[1,s],o);return c?ye(m,[m.shape[2],m.shape[3]]):ye(m,[m.shape[0],m.shape[2],m.shape[3]])}const mU=K({conv1d_:pU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(r,e,t,n,i,s="NHWC",o){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let a=r,l=e,u=!1;e.rank===3&&(u=!0,l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,r[0],r[1],r[2]]),D(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),D(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=s==="NHWC"?a[3]:a[1],h=s==="NHWC"?l.shape[3]:l.shape[1];D(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),D(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Ui("conv2dDerInput",i,o);const f={dy:l,filter:t},d={strides:n,pad:i,dataFormat:s,dimRoundingMode:o,inputShape:a},g=X.runKernel(ES,f,d);return u?ye(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Z2=K({conv2DBackpropInput_:gU});function yU(r,e,t,n,i,s){const o=P(r,"x","conv2dTranspose"),a=P(e,"filter","conv2dTranspose");return Z2(t,o,a,n,i,"NHWC",s)}const _U=K({conv2dTranspose_:yU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(r,e,t,n,i="NDHWC",s=[1,1,1]){const o=P(r,"x","conv3d"),a=P(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=ye(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),D(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),D(Us(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),D(Xl(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Xl(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:n,dataFormat:i,dilations:s},f=X.runKernel(E$,c,h);return u?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const xU=K({conv3d_:bU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(r,e,t,n,i){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,o=e,a=!1;e.rank===4&&(a=!0,o=ye(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);const l=s[4],u=o.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),D(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},h={pad:i,strides:n,inputShape:s},f=X.runKernel(M$,c,h);return a?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const wU=K({conv3DBackpropInput_:vU});function SU(r,e,t,n,i){const s=P(r,"x","conv3dTranspose"),o=P(e,"filter","conv3dTranspose");return wU(t,s,o,n,i)}const TU=K({conv3dTranspose_:SU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(r){const t={x:P(r,"x","cos","float32")};return X.runKernel(MS,t)}const MU=K({cos_:EU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(r){const t={x:P(r,"x","cosh","float32")};return X.runKernel(AS,t)}const IU=K({cosh_:AU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(r,e=0,t=!1,n=!1){const s={x:P(r,"x","cumprod")},o={axis:e,exclusive:t,reverse:n};return X.runKernel(IS,s,o)}const kU=K({cumprod_:CU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(r,e=0,t=!1,n=!1){const s={x:P(r,"x","cumsum")},o={axis:e,exclusive:t,reverse:n};return X.runKernel(CS,s,o)}const RU=K({cumsum_:NU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(r,e,t,n=!1){const i=P(r,"x","denseBincount"),s=P(e,"weights","denseBincount");D(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),D(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);const o={x:i,weights:s},a={size:t,binaryOutput:n};return X.runKernel(NS,o,a)}const LU=K({denseBincount_:PU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(r,e,t="NHWC"){const n=P(r,"x","depthToSpace","float32"),i=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],o=t==="NHWC"?n.shape[3]:n.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${n.shape}`),D(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),D(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${n.shape}`);const a={x:n},l={blockSize:e,dataFormat:t};return X.runKernel(RS,a,l)}const OU=K({depthToSpace_:DU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(r,e,t,n,i="NHWC",s=[1,1],o){const a=P(r,"x","depthwiseConv2d","float32"),l=P(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=i==="NHWC"?u.shape[3]:u.shape[1];D(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ui("depthwiseConv2d",n,o);const f={x:u,filter:l},d={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:o},g=X.runKernel(PS,f,d);return c?ye(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const My=K({depthwiseConv2d_:FU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(r){const t={x:P(r,"x","diag")};return X.runKernel(LS,t)}const zU=K({diag_:$U});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(r,e,t,n,i=[1,1],s="NHWC"){const o=P(r,"x","dilation2d"),a=P(e,"filter","dilation2d");D(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),D(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,u=!1;o.rank===3&&(l=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),D(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:n,dilations:i},f=X.runKernel(DS,c,h);return u?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const UU=K({dilation2d_:BU});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(r,e){const t=r.length,n=[];for(let i=0;i<t;i++){const s=t-1-i,o=r[s]||1;(e[e.length-1-i]||1)>1&&o===1&&n.unshift(s)}return n}function VU(r,e){const t=[];for(let n=0;n<e.length;n++){const i=r[r.length-n-1],s=e.length-n-1,o=e[s];(i==null||i===1&&o>1)&&t.unshift(s)}return t}function Zt(r,e){const t=[],n=Math.max(r.length,e.length);for(let i=0;i<n;i++){let s=r[r.length-i-1];s==null&&(s=1);let o=e[e.length-i-1];if(o==null&&(o=1),s===1)t.unshift(o);else if(o===1)t.unshift(s);else if(s!==o){const a=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(a)}else t.unshift(s)}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(r,e){let t=P(r,"a","equal","string_or_numeric"),n=P(e,"b","equal","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(BS,i)}const Q2=K({equal_:WU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(r,e,t){const n=P(e,"a","where"),i=P(t,"b","where"),s=P(r,"condition","where","bool"),o=Zt(Zt(s.shape,n.shape),i.shape),a=Ju(s,o),l=Ju(n,o),u=Ju(i,o),c={condition:a,t:l,e:u};return X.runKernel(KT,c)}const Yl=K({where_:GU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(r){const t={x:P(r,"x","zerosLike")};return X.runKernel(y2,t)}const Gr=K({zerosLike_:HU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jU(r,e){let t=P(r,"a","div"),n=P(e,"b","div");[t,n]=yn(t,n);const i=bt(t,n),s=Gr(i),o=Q2(n,s);return Yl(o,s,i)}const qU=K({divNoNan_:jU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(r,e){const t=P(r,"t1","dot"),n=P(e,"t2","dot");D((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);const i=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(D(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),t.rank===1&&n.rank===1){const o=ye(t,[1,-1]),a=ye(n,[-1,1]),l=Wt(o,a);return ye(l,[])}else if(t.rank===1&&n.rank===2){const o=ye(t,[1,-1]),a=ye(n,[n.shape[0],n.shape[1]]),l=Wt(o,a);return ye(l,[l.size])}else if(t.rank===2&&n.rank===1){const o=ye(n,[-1,1]),a=Wt(t,o);return ye(a,[a.size])}else{const o=ye(n,[n.shape[0],n.shape[1]]);return Wt(t,o)}}const XU=K({dot_:KU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(r,...e){const t=e.map((i,s)=>P(i,`tensors${s}`,"einsum")),n={equation:r};return X.runKernel(FS,t,n)}const ZU=K({einsum_:YU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QU(r){const t={x:P(r,"x","elu","float32")};return X.runKernel($S,t)}const J2=K({elu_:QU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(r){let e=P(r,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ln(e,"float32"));const t={x:e};return X.runKernel(zS,t)}const e4=K({erf_:JU});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function t4(r,e,t){const n=r.length+e.length,i=[];let s=0,o=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?i.push(r[s++]):i.push(e[o++]);return i}function Hf(r,e){const t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);const i=e.map(s=>r[s]);return[t,i]}function cu(r,e){const t=e.map(n=>1);return t4(r,t,e)}function Ay(r,e,t){D(eE(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function jf(r,e){if(eE(r,e))return null;const t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function n4(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function qf(r,e){const t=[];for(let n=e-r;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(r,e=null,t=!1){const i={x:P(r,"x","max")},s={reductionIndices:e,keepDims:t};return X.runKernel(mT,i,s)}const Cl=K({max_:r4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(r,e=null,t=!1){const i={x:P(r,"x","min")},s={axis:e,keepDims:t};return X.runKernel(bT,i,s)}const Vm=K({min_:i4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(r,e){let t=P(r,"base","pow"),n=P(e,"exp","pow");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(RT,i)}const Tc=K({pow_:s4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yt(r,e){if((zi(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&zi(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ko(r,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o4(r){const t={x:P(r,"x","sqrt","float32")};return X.runKernel(n2,t)}const Ds=K({sqrt_:o4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(r){const e=P(r,"x","square"),t={};return X.runKernel("Square",{x:e},t)}const xi=K({square_:a4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(r,e=null,t=!1){let n=P(r,"x","sum");n.dtype==="bool"&&(n=ln(n,"int32"));const i={x:n},s={axis:e,keepDims:t};return X.runKernel(r2,i,s)}const sn=K({sum_:l4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(r,e="euclidean",t=null,n=!1){r=P(r,"x","norm");const i=tE(r,e,t);let s=i.shape;if(n){const o=Yr(t,r.shape);s=cu(i.shape,o)}return ye(i,s)}function tE(r,e,t=null){if(r.rank===0)return $r(r);if(r.rank!==1&&t===null)return tE(ye(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return sn($r(r),t);if(e===1/0)return Cl($r(r),t);if(e===-1/0)return Vm($r(r),t);if(e==="euclidean"||e===2)return Ds(sn(Tc($r(r),yt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Cl(sn($r(r),t[0]),t[1]-1);if(e===1/0)return Cl(sn($r(r),t[1]),t[0]);if(e===-1/0)return Vm(sn($r(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ds(sn(xi(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Kf=K({norm_:u4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(r,e=null,t=!1){return Kf(r,"euclidean",e,t)}const h4=K({euclideanNorm_:c4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(r){const t={x:P(r,"x","exp")};return X.runKernel(US,t)}const Os=K({exp_:f4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(r,e=0){const t=P(r,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},i={dim:e};return X.runKernel(VS,n,i)}const ci=K({expandDims_:d4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(r){const t={x:P(r,"x","expm1")};return X.runKernel(WS,t)}const m4=K({expm1_:p4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(r,e){const t=P(r,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},i={reps:e};return X.runKernel(vy,n,i)}const ec=K({tile_:g4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(r,e,t,n="float32"){e==null&&(e=r);const i=rn([r,e],n),s=r<=e?r:e;for(let a=0;a<s;++a)i.set(1,a,a);const o=ye(i.toTensor(),[r,e]);if(t==null)return o;if(t.length===1)return ec(ci(o,0),[t[0],1,1]);if(t.length===2)return ec(ci(ci(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return ec(ci(ci(ci(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const nE=K({eye_:y4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _4(r){const t={x:P(r,"x","floor","float32")};return X.runKernel(qS,t)}const rE=K({floor_:_4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(r,e,t=0,n=0){const i=P(r,"x","gather"),s=P(e,"indices","gather","int32"),o={x:i,indices:s},a={axis:t,batchDims:n};return X.runKernel(YS,o,a)}const iE=K({gather_:b4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x4(r,e){let t=P(r,"a","greater","string_or_numeric"),n=P(e,"b","greater","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(QS,i)}const Xf=K({greater_:x4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4(r,e){let t=P(r,"a","greaterEqual","string_or_numeric"),n=P(e,"b","greaterEqual","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(JS,i)}const sE=K({greaterEqual_:v4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(r){const t={input:P(r,"input","imag")};return X.runKernel(tT,t)}const Yf=K({imag_:w4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S4(r){const t={x:P(r,"x","isFinite")};return X.runKernel(nT,t)}const T4=K({isFinite_:S4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(r){const t={x:P(r,"x","isInf")};return X.runKernel(rT,t)}const M4=K({isInf_:E4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(r){const t={x:P(r,"x","isNaN")};return X.runKernel(iT,t)}const I4=K({isNaN_:A4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(r,e=.2){const n={x:P(r,"x","leakyRelu")},i={alpha:e};return X.runKernel(sT,n,i)}const oE=K({leakyRelu_:C4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4(r,e){let t=P(r,"a","less","string_or_numeric"),n=P(e,"b","less","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(oT,i)}const N4=K({less_:k4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R4(r,e){let t=P(r,"a","lessEqual","string_or_numeric"),n=P(e,"b","lessEqual","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(aT,i)}const Iy=K({lessEqual_:R4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");const n={start:r,stop:e,num:t};return X.runKernel(lT,{},n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(r,e=5,t=1,n=1,i=.5){const s=P(r,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(xc(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;s.rank===3&&(a=!0,o=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},u={depthRadius:e,bias:t,alpha:n,beta:i},c=X.runKernel(pT,l,u);return a?ye(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const D4=K({localResponseNormalization_:L4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(r){const t={x:P(r,"x","log","float32")};return X.runKernel(uT,t)}const Ec=K({log_:O4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(r){const t={x:P(r,"x","log1p")};return X.runKernel(cT,t)}const aE=K({log1p_:F4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(r,e){D(xm(r),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(u=>u instanceof tf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in X.registeredVariables)e.push(X.registeredVariables[u])}const n=t?e.filter(u=>!u.trainable):null,i=e.length;e=e.filter(u=>u.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const s=!0,{value:o,grads:a}=X.gradients(r,e,null,s);D(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),n!=null&&n.forEach(u=>l[u.name]=null),{value:o,grads:l}}function Fs(r){return X.customGrad(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(r){const t={x:P(r,"x","neg")};return X.runKernel(TT,t)}const Cs=K({neg_:z4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(r){const t={x:P(r,"x","softplus")};return X.runKernel(t2,t)}const lE=K({softplus_:B4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(r){const e=P(r,"x","logSigmoid");return Fs(n=>({value:Cs(lE(Cs(n))),gradFunc:o=>Ce(o,Is(Cs(n)))}))(e)}const V4=K({logSigmoid_:U4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4(r,e){let t=P(r,"a","sub"),n=P(e,"b","sub");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(h2,i)}const ft=K({sub_:W4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(r,e=-1){const t=P(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Fs((i,s)=>{const a=Cl(i,e,!0),l=ft(i,a),u=ft(ln(l,"float32"),Ec(sn(Os(l),e,!0)));return s([u]),{value:u,gradFunc:(h,f)=>{const[d]=f,g=!0,p=Os(d);return ft(h,Ce(sn(h,e,g),p))}}})(t)}const H4=K({logSoftmax_:G4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(r,e=null,t=!1){const n=P(r,"x","logSumExp"),i=Yr(e,n.shape),s=Cl(n,i,!0),o=ft(n,s),a=Os(o),l=sn(a,i),u=Ec(l),c=Ye(ye(s,u.shape),u);if(t){const h=cu(c.shape,i);return ye(c,h)}return c}const uE=K({logSumExp_:j4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(r,e){const t=P(r,"a","logicalAnd","bool"),n=P(e,"b","logicalAnd","bool");Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(hT,i)}const uf=K({logicalAnd_:q4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(r){const t={x:P(r,"x","logicalNot","bool")};return X.runKernel(fT,t)}const cE=K({logicalNot_:K4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4(r,e){const t=P(r,"a","logicalOr","bool"),n=P(e,"b","logicalOr","bool");Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(dT,i)}const hE=K({logicalOr_:X4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4(r,e){const t=P(r,"a","logicalXor","bool"),n=P(e,"b","logicalXor","bool");return Zt(t.shape,n.shape),uf(hE(r,e),cE(uf(r,e)))}const Z4=K({logicalXor_:Y4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vh=2147483648;function Q4(r,e,t="left"){const n=P(r,"sortedSequence","searchSorted"),i=P(e,"values","searchSorted"),s=n.shape[n.shape.length-1],o=i.shape[i.shape.length-1],a=ye(n,[-1,s]),l=ye(i,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ze(l.shape)>=vh)throw new Error(`values tensor size must less than ${vh}`);if(a.shape[1]>=vh)throw new Error(`trailing dim_size must less than ${vh} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return X.runKernel(qT,u,c)}const Cy=K({searchSorted_:Q4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4(r,e){return Cy(r,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(r,e,t,n,i){const s=P(r,"x","maxPool"),o=1;let a=s,l=!1;s.rank===3&&(l=!0,a=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),D(Us(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Ui("maxPool",n,i);const u={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i},h=X.runKernel(yT,u,c);return l?ye(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const fE=K({maxPool_:eV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(r,e=[1,1,1],t,n,i,s="NDHWC"){const o=P(r,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Ui("maxPool3d",n,i);const u={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:s},h=X.runKernel(C$,u,c);return l?ye(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const nV=K({maxPool3d_:tV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(r,e,t,n,i=!1){const o={x:P(r,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:n,includeBatchInIndex:i},l=X.runKernel(k$,o,a);return{result:l[0],indexes:l[1]}}const iV=K({maxPoolWithArgmax_:rV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(r,e){let t=P(r,"a","maximum"),n=P(e,"b","maximum");[t,n]=yn(t,n),t.dtype==="bool"&&(t=ln(t,"int32"),n=ln(n,"int32")),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(gT,i)}const dE=K({maximum_:sV});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(r,e=null,t=!1){const i={x:P(r,"x","mean")},s={axis:e,keepDims:t};return X.runKernel(_T,i,s)}const cf=K({mean_:oV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(r,e="float32"){if(Zr(r),e==="complex64"){const n=Mo(r,"float32"),i=Mo(r,"float32");return Eo(n,i)}const t=xs(ze(r),e);return X.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(r,e="float32"){if(Zr(r),e==="complex64"){const n=oa(r,"float32"),i=Mo(r,"float32");return Eo(n,i)}const t=J1(ze(r),e);return X.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=P(r,"x","meshgrid",r instanceof dn?r.dtype:"float32");if(e===void 0)return[n];let i=P(e,"y","meshgrid",e instanceof dn?e.dtype:"float32");const s=ze(n.shape),o=ze(i.shape);return t==="xy"?(n=ye(n,[1,-1]),i=ye(i,[-1,1]),[Wt(oa([o,1],n.dtype),n),Wt(i,oa([1,s],i.dtype))]):(n=ye(n,[-1,1]),i=ye(i,[1,-1]),[Wt(n,oa([1,o],n.dtype)),Wt(oa([s,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(r,e){let t=P(r,"a","minimum"),n=P(e,"b","minimum");[t,n]=yn(t,n),t.dtype==="bool"&&(t=ln(t,"int32"),n=ln(n,"int32")),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(xT,i)}const ky=K({minimum_:lV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(r,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=P(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let a=0;a<n.rank;a++)D(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[a][0]>=0&&e[a][0]<=n.shape[a]-i&&e[a][1]>=0&&e[a][1]<=n.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-i} or less than 0 for input of shape ${n.shape}`);const s={paddings:e,mode:t},o={x:n};return X.runKernel(vT,o,s)}const pE=K({mirrorPad_:uV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(r,e){let t=P(r,"a","mod"),n=P(e,"b","mod");[t,n]=yn(t,n);const i={a:t,b:n};return X.runKernel(wT,i)}const hV=K({mod_:cV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(r,e=null,t=!1){r=P(r,"x","moments");const n=Yr(e,r.shape),i=cf(r,n,t);let s=i.shape;t||(s=cu(i.shape,n));const o=xi(ft(ln(r,"float32"),ye(i,s))),a=cf(o,n,t);return{mean:i,variance:a}}const dV=K({moments_:fV});function pV(r,e,t,n){const i=P(e,"data","multiRNNCell"),s=nf(t,"c","multiRNNCell"),o=nf(n,"h","multiRNNCell");let a=i;const l=[];for(let h=0;h<r.length;h++){const f=r[h](a,s[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const mV=K({multiRNNCell_:pV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gV(r,e,t,n=!1){const i=P(r,"logits","multinomial"),s=i.size,o=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ye(i,[1,-1]):i},u={numSamples:e,seed:t,normalized:n},c=X.runKernel(N$,l,u);return o===1?ye(c,[c.size]):c}const yV=K({multinomial_:gV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _V(r,e){let t=P(r,"a","notEqual","string_or_numeric"),n=P(e,"b","notEqual","string_or_numeric");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n};return X.runKernel(ET,i)}const mE=K({notEqual_:_V});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bV(r,e,t=1,n=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:P(r,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:n};return X.runKernel(CT,o,a)}const xV=K({oneHot_:bV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vV(r){const t={x:P(r,"x","onesLike")};return X.runKernel(IT,t)}const wV=K({onesLike_:vV});function SV(r,e){const t=P(r,"v1","outerProduct"),n=P(e,"v2","outerProduct");D(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);const i=ye(t,[-1,1]),s=ye(n,[1,-1]);return Wt(i,s)}const TV=K({outerProduct_:SV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EV(r,e,t=0){const n=P(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},s={x:n};return X.runKernel(NT,s,i)}const Ao=K({pad_:EV});function MV(r,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ao(r,[e],t)}const AV=K({pad1d_:MV});function IV(r,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ao(r,e,t)}const CV=K({pad2d_:IV});function kV(r,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ao(r,e,t)}const NV=K({pad3d_:kV});function RV(r,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ao(r,e,t)}const PV=K({pad4d_:RV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LV(r,e,t){const n=P(r,"x","spaceToBatchND");D(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(n.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:n},s={blockShape:e,paddings:t};return X.runKernel(i2,i,s)}const gE=K({spaceToBatchND_:LV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(r,e,t,n,i,s,o){i==null&&(i=[1,1]),s==null&&(s=1),n===0&&(n="valid");const a=P(r,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(Us(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const c=Vf(l.shape,e,s,i,n),h=[c.dilationHeight,c.dilationWidth];let f;n==="same"?f=FV([c.filterHeight,c.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[g,p]=OV([c.inHeight,c.inWidth],h,f),m=d?n:"valid",_=d?l:gE(l,h,g),b=(t==="avg"?()=>q2(_,e,s,m,o):()=>fE(_,e,s,m,o))(),x=d?b:K2(b,h,p);return u?ye(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function OV(r,e,t){const n=t.map(c=>c[0]),i=t.map(c=>c[1]),s=r.concat(n,i),o=e.map((c,h)=>(c-s[h]%c)%c),a=i.map((c,h)=>c+o[h]),l=e.map((c,h)=>[n[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function FV(r,e){const n=r.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=n.map(o=>Math.floor(o/2)),s=n.map((o,a)=>o-i[a]);return n.map((o,a)=>[i[a],s[a]])}const $V=K({pool_:DV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(r,e){const t=P(r,"x","prelu"),n=P(e,"alpha","prelu"),i={x:t,alpha:n};return X.runKernel(PT,i)}const yE=K({prelu_:zV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(r,e=null,t=!1){let n=P(r,"x","prod");n.dtype==="bool"&&(n=ln(n,"int32"));const i={x:n},s={axis:e,keepDims:t};return X.runKernel(LT,i,s)}const UV=K({prod_:BV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(r,e,t,n){const i=r.map((c,h)=>P(c,`tensors${h}`,"raggedGather","int32")),s=P(e,"paramsDenseValues","raggedGather"),o=P(t,"indices","raggedGather","int32"),a={paramsNestedSplits:i,paramsDenseValues:s,indices:o},l={outputRaggedRank:n},u=X.runKernel(P$,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const WV=K({raggedGather_:VV});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GV(r,e,t){const n=P(r,"starts","raggedRange"),i=P(e,"limits","raggedRange",n.dtype),s=P(t,"deltas","raggedRange",n.dtype),o={starts:n,limits:i,deltas:s},a=X.runKernel(L$,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const HV=K({raggedRange_:GV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(r,e,t,n,i){const s=P(r,"shape","raggedTensorToTensor","int32"),o=P(e,"values","raggedTensorToTensor"),a=P(t,"defaultValue","raggedTensorToTensor",o.dtype),l=n.map((h,f)=>P(h,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:s,values:o,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:i};return X.runKernel(D$,u,c)}const qV=K({raggedTensorToTensor_:jV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KV(r,e,t){Zr(r);const n=ze(r);let i=null;if(t==null||t==="float32")i=new Float32Array(n);else if(t==="int32")i=new Int32Array(n);else if(t==="bool")i=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)i[s]=e();return X.makeTensor(i,r,t)}const XV=K({rand_:KV});var Wm={},YV={get exports(){return Wm},set exports(r){Wm=r}};(function(r){(function(e,t,n){function i(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function s(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new i(l),h=u&&u.state,f=c.next;return f.int32=function(){return c.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&s(h,c),f.state=function(){return s(c,{})}),f}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.alea=o})(es,r,!1)})(YV);var Gm={},ZV={get exports(){return Gm},set exports(r){Gm=r}};(function(r){(function(e,t,n){function i(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new i(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,d=(u.next()>>>0)/4294967296,g=(f+d)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor128=o})(es,r,!1)})(ZV);var Hm={},QV={get exports(){return Hm},set exports(r){Hm=r}};(function(r){(function(e,t,n){function i(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new i(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,d=(u.next()>>>0)/4294967296,g=(f+d)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorwow=o})(es,r,!1)})(QV);var jm={},JV={get exports(){return jm},set exports(r){jm=r}};(function(r){(function(e,t,n){function i(a){var l=this;l.next=function(){var c=l.x,h=l.i,f,d;return f=c[h],f^=f>>>7,d=f^f<<24,f=c[h+1&7],d^=f^f>>>10,f=c[h+3&7],d^=f^f>>>3,f=c[h+4&7],d^=f^f<<7,f=c[h+7&7],f=f^f<<13,d^=f^f<<9,c[h]=d,l.i=h+1&7,d};function u(c,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],c.x=d,c.i=0,f=256;f>0;--f)c.next()}u(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new i(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,d=(u.next()>>>0)/4294967296,g=(f+d)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.x&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorshift7=o})(es,r,!1)})(JV);var qm={},eW={get exports(){return qm},set exports(r){qm=r}};(function(r){(function(e,t,n){function i(a){var l=this;l.next=function(){var c=l.w,h=l.X,f=l.i,d,g;return l.w=c=c+1640531527|0,g=h[f+34&127],d=h[f=f+1&127],g^=g<<13,d^=d<<17,g^=g>>>15,d^=d>>>12,g=h[f]=g^d,l.i=f,g+(c^c>>>16)|0};function u(c,h){var f,d,g,p,m,_=[],v=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,v=Math.max(v,h.length)),g=0,p=-32;p<v;++p)h&&(d^=h.charCodeAt((p+32)%h.length)),p===0&&(m=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,p>=0&&(m=m+1640531527|0,f=_[p&127]^=d+m,g=f==0?g+1:0);for(g>=128&&(_[(h&&h.length||0)&127]=-1),g=127,p=4*128;p>0;--p)d=_[g+34&127],f=_[g=g+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,_[g]=d^f;c.w=m,c.X=_,c.i=g}u(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new i(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,d=(u.next()>>>0)/4294967296,g=(f+d)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.X&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor4096=o})(es,r,!1)})(eW);var Km={},tW={get exports(){return Km},set exports(r){Km=r}};(function(r){(function(e,t,n){function i(a){var l=this,u="";l.next=function(){var h=l.b,f=l.c,d=l.d,g=l.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^g,g=g-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-d|0,l.d=d<<16^f>>>16^g,l.a=g-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new i(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,d=(u.next()>>>0)/4294967296,g=(f+d)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.tychei=o})(es,r,!1)})(tW);var Xm={},nW={get exports(){return Xm},set exports(r){Xm=r}};const rW={},iW=Object.freeze(Object.defineProperty({__proto__:null,default:rW},Symbol.toStringTag,{value:"Module"})),sW=e$(iW);(function(r){(function(e,t,n){var i=256,s=6,o=52,a="random",l=n.pow(i,s),u=n.pow(2,o),c=u*2,h=i-1,f;function d(x,T,I){var C=[];T=T==!0?{entropy:!0}:T||{};var S=_(m(T.entropy?[x,b(t)]:x??v(),3),C),A=new g(C),R=function(){for(var F=A.g(s),q=l,O=0;F<u;)F=(F+O)*i,q*=i,O=A.g(1);for(;F>=c;)F/=2,q/=2,O>>>=1;return(F+O)/q};return R.int32=function(){return A.g(4)|0},R.quick=function(){return A.g(4)/4294967296},R.double=R,_(b(A.S),t),(T.pass||I||function(F,q,O,z){return z&&(z.S&&p(z,A),F.state=function(){return p(A,{})}),O?(n[a]=F,q):F})(R,S,"global"in T?T.global:this==n,T.state)}function g(x){var T,I=x.length,C=this,S=0,A=C.i=C.j=0,R=C.S=[];for(I||(x=[I++]);S<i;)R[S]=S++;for(S=0;S<i;S++)R[S]=R[A=h&A+x[S%I]+(T=R[S])],R[A]=T;(C.g=function(F){for(var q,O=0,z=C.i,H=C.j,Q=C.S;F--;)q=Q[z=h&z+1],O=O*i+Q[h&(Q[z]=Q[H=h&H+q])+(Q[H]=q)];return C.i=z,C.j=H,O})(i)}function p(x,T){return T.i=x.i,T.j=x.j,T.S=x.S.slice(),T}function m(x,T){var I=[],C=typeof x,S;if(T&&C=="object")for(S in x)try{I.push(m(x[S],T-1))}catch{}return I.length?I:C=="string"?x:x+"\0"}function _(x,T){for(var I=x+"",C,S=0;S<I.length;)T[h&S]=h&(C^=T[h&S]*19)+I.charCodeAt(S++);return b(T)}function v(){try{var x;return f&&(x=f.randomBytes)?x=x(i):(x=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(x)),b(x)}catch{var T=e.navigator,I=T&&T.plugins;return[+new Date,e,I,e.screen,b(t)]}}function b(x){return String.fromCharCode.apply(0,x)}if(_(n.random(),t),r.exports){r.exports=d;try{f=sW}catch{}}else n["seed"+a]=d})(typeof self<"u"?self:es,[],Math)})(nW);var oW=Wm,aW=Gm,lW=Hm,uW=jm,cW=qm,hW=Km,Oa=Xm;Oa.alea=oW;Oa.xor128=aW;Oa.xorwow=lW;Oa.xorshift7=uW;Oa.xor4096=cW;Oa.tychei=hW;var Ny=Oa;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ry{constructor(e,t,n,i,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=Ny.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,n=!1;for(;!n;){let i,s,o;do i=2*this.random()-1,s=2*this.random()-1,o=i*i+s*s;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class fW{constructor(e,t,n,i){this.alpha=e,this.beta=1/t,this.dtype=n;const s=i||Math.random();this.randu=Ny.alea(s.toString()),this.randn=new Ry(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,i,s,o;for(;;){do i=this.randn.nextValue(),o=1+this.c*i;while(o<=0);if(o*=o*o,e=i*i,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),s=this.randu(),s<t||Math.log(s)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class dW{constructor(e=0,t=1,n,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Ny.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(r,e,t=1,n="float32",i){if(Zr(r),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);const s=new fW(e,t,n,i),o=rn(r,n);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const mW=K({randomGamma_:pW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gW(r,e=0,t=1,n,i){if(Zr(r),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const s=new Ry(e,t,n,!1,i),o=rn(r,n);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const _E=K({randomNormal_:gW});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(r,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return _E(r,0,1,e,t)}const _W=K({randomStandardNormal_:yW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(r,e=0,t=1,n="float32",i){Zr(r);const s=rn(r,n),o=new dW(e,t,null,i);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}const bE=K({randomUniform_:bW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mc(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:r,stop:e,step:t,dtype:n};return X.runKernel(DT,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xW(r){const t={input:P(r,"input","real")};return X.runKernel(OT,t)}const Ac=K({real_:xW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(r){const t={x:P(r,"x","reciprocal")};return X.runKernel(FT,t)}const wW=K({reciprocal_:vW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(r){const t={x:P(r,"x","relu")};return X.runKernel($T,t)}const Zf=K({relu_:SW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(r){const t={x:P(r,"x","relu6")};return X.runKernel(VT,t)}const xE=K({relu6_:TW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(r,e){const n={x:P(r,"x","reverse")},i={dims:e};return X.runKernel(WT,n,i)}const Ca=K({reverse_:EW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(r){const e=P(r,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ca(e,0)}const AW=K({reverse1d_:MW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IW(r,e){const t=P(r,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Ca(t,e)}const CW=K({reverse2d_:IW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(r,e){const t=P(r,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Ca(t,e)}const NW=K({reverse3d_:kW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(r,e){const t=P(r,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Ca(t,e)}const PW=K({reverse4d_:RW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(r){const t={x:P(r,"x","round")};return X.runKernel(GT,t)}const vE=K({round_:LW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DW(r){const t={x:P(r,"x","rsqrt","float32")};return X.runKernel(HT,t)}const OW=K({rsqrt_:DW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FW(r){const t={x:P(r,"x","selu")};return X.runKernel(XT,t)}const $W=K({selu_:FW});function zW(r,e,t,n,i,s=[1,1],o="NHWC"){const a=P(r,"x","separableConv2d"),l=P(e,"depthwiseFilter","separableConv2d"),u=P(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),D(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const f=l.shape[2],d=l.shape[3];D(u.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${u.shape[2]}.`);const g=My(c,l,n,i,o,s),m=Gf(g,u,1,"valid",o);return h?ye(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const BW=K({separableConv2d_:zW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function UW(r,e){const t=P(r,"x","setdiff1d"),n=P(e,"y","setdiff1d");D(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const i=await t.data(),s=await n.data(),o=new Set(s);let a=0;for(let c=0;c<i.length;c++)o.has(i[c])||a++;const l=new vc([a],t.dtype),u=new vc([a],"int32");for(let c=0,h=0;c<i.length;c++)o.has(i[c])||(l.values[h]=i[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const VW=UW;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WW(r){const t={x:P(r,"x","sign")};return X.runKernel(JT,t)}const GW=K({sign_:WW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(r){const t={x:P(r,"x","sin","float32")};return X.runKernel(ZT,t)}const jW=K({sin_:HW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qW(r){const t={x:P(r,"x","sinh")};return X.runKernel(QT,t)}const KW=K({sinh_:qW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(r,e,t){const n=P(r,"x","slice1d");return D(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),_t(n,[e],[t])}const YW=K({slice1d_:XW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZW(r,e,t){const n=P(r,"x","slice2d");return D(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),_t(n,e,t)}const QW=K({slice2d_:ZW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(r,e,t){const n=P(r,"x","slice3d");return D(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),_t(n,e,t)}const eG=K({slice3d_:JW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tG(r,e,t){const n=P(r,"x","slice4d");return D(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),_t(n,e,t)}const nG=K({slice4d_:tG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rG(r,e=-1){const t=P(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},i={dim:e};return X.runKernel(o2,n,i)}const iG=K({softmax_:rG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);const e={input:r};return X.runKernel(GS,e)}const Py=K({fft_:sG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oG(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);const e={input:r};return X.runKernel(eT,e)}const hf=K({ifft_:oG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(r){const e=r.shape[r.shape.length-1],t=r.size/e;let n;if(e<=2){const i=ye(r,[t,e]);n=hf(i)}else{const i=[t,2*(e-1)],s=ye(Ac(r),[t,e]),o=ye(Yf(r),[t,e]),a=Ca(_t(s,[0,1],[t,e-2]),1),l=Ce(Ca(_t(o,[0,1],[t,e-2]),1),yt(-1)),u=kn([s,a],1),c=kn([o,l],1),h=ye(Eo(u,c),[i[0],i[1]]);n=hf(h)}if(n=Ac(n),r.rank===3&&r.shape[0]!==0){const i=n,s=r.shape[0];n=ye(n,[s,n.shape[0]/s,n.shape[1]]),i.dispose()}return n}const wE=K({irfft_:aG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(r,e,t=0){const i={x:P(r,"x","split")},s={numOrSizeSplits:e,axis:t};return X.runKernel(s2,i,s)}const Ic=K({split_:lG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uG(r,e){D(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1];const n=r.size/t;let i;if(e!=null&&e<t){const g=r.shape.map(m=>0),p=r.shape.map(m=>m);p[r.shape.length-1]=e,i=_t(r,g,p),t=e}else if(e!=null&&e>t){const g=r.shape.map(p=>p);g[r.shape.length-1]=e-t,i=kn([r,Mo(g)],r.shape.length-1),t=e}else i=r;const s=Gr(i),o=ye(Eo(i,s),[n,t]),a=Py(o),l=Math.floor(t/2)+1,u=Ac(a),c=Yf(a),h=Ic(u,[l,t-l],u.shape.length-1),f=Ic(c,[l,t-l],c.shape.length-1),d=i.shape.slice();return d[i.shape.length-1]=l,ye(Eo(h[0],f[0]),d)}const Ly=K({rfft_:uG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cG(r,e){let t=P(r,"a","squaredDifference"),n=P(e,"b","squaredDifference");[t,n]=yn(t,n),Zt(t.shape,n.shape);const i={a:t,b:n},s={};return X.runKernel(l2,i,s)}const SE=K({squaredDifference_:cG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hG(r,e){const t=P(r,"x","squeeze","string_or_numeric");return ye(t,a$(t.shape,e).newShape)}const Vt=K({squeeze_:hG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fG(r,e=0){const t=nf(r,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,i={axis:e};return X.runKernel(kT,n,i)}const $s=K({stack_:fG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(r,e=0){const n={x:P(r,"x","step")},i={alpha:e};return X.runKernel(_2,n,i)}const TE=K({step_:dG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(r,e,t,n,i=0,s=0,o=0,a=0,l=0){const c={x:P(r,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:n,beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return X.runKernel(u2,c,h)}const mG=K({stridedSlice_:pG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(r){const t={x:P(r,"x","tan","float32")};return X.runKernel(f2,t)}const yG=K({tan_:gG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(r,e){lu(r);const t=Co(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ko(r,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vi(r,e,t){if(lu(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=Co(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(r,e,t){if(lu(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=Co(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(r,e,t){if(lu(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const n=Co(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bG(r,e,t){if(lu(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const n=Co(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(r,e,t){if(lu(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const n=Co(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,ko(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(r,e=1,t=!0){const n=P(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:n},o={k:e,sorted:t},[a,l]=X.runKernel(p2,s,o);return{values:a,indices:l}}const wG=K({topk_:vG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SG(r,e=0,t=1,n,i){if(Zr(r),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new Ry(e,t,n,!0,i),o=rn(r,n);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const TG=K({truncatedNormal_:SG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EG(r,e=0){const t=P(r,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},i={axis:e},[s,o]=X.runKernel(W$,n,i);return{values:s,indices:o}}const MG=K({unique_:EG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(r,e,t){const n=P(r,"x","unsortedSegmentSum"),i=P(e,"segmentIds","unsortedSegmentSum","int32");D(xc(t),()=>"numSegments must be of dtype int");const s={x:n,segmentIds:i},o={numSegments:t};return X.runKernel(G$,s,o)}const IG=K({unsortedSegmentSum_:AG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CG(r,e=0){const t=P(r,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},i={axis:e};return X.runKernel(g2,n,i)}const Fa=K({unstack_:CG});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kG(r,e){return Cy(r,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NG(r,e=!0,t,n){return X.makeVariable(r,e,t,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(r,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const n=rn(r,"int32"),i=rn([t.length,r.length],"int32");for(let s=0;s<t.length;s++){const o=n.indexToLoc(t[s]),a=s*r.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function PG(r){const e=P(r,"condition","whereAsync","bool"),t=await e.data(),n=RG(e.shape,t);return r!==e&&e.dispose(),n}const ME=PG;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LG(r,e,t){const n=P(r,"tensor","boolMask"),i=P(e,"mask","boolMask","bool"),s=t??0,o=i.rank,a=n.shape;D(o>0,()=>"mask cannot be scalar"),Xr(a.slice(s,s+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let p=s;p<s+o;p++)l*=a[p];const u=a.slice(0,s).concat([l],a.slice(s+o)),c=ye(n,u),h=ye(i,[-1]),f=await ME(h),d=Vt(f,[1]),g=iE(c,d,s);return r!==n&&n.dispose(),e!==i&&i.dispose(),d.dispose(),c.dispose(),h.dispose(),f.dispose(),g}const DG=LG;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(r,e,t){const n=P(r,"x","transpose");if(e==null&&(e=n.shape.map((o,a)=>a).reverse()),D(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(o=>{D(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const i={x:n},s={perm:e};return n.dtype==="complex64"?ht(()=>{let o=Ac(n),a=Yf(n);return o=X.runKernel(Lh,{x:o},s),a=X.runKernel(Lh,{x:a},s),t&&(a=Cs(a)),Eo(o,a)}):X.runKernel(Lh,i,s)}const Ym=K({transpose_:OG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FG(r,e,t,n,i=!0){const s=P(r,"v","movingAverage"),o=P(e,"x","movingAverage"),a=P(t,"decay","movingAverage");pz(s,o),D(br(s.shape,o.shape),()=>"Shape mismatch in v and x");const l=yt(1),u=ft(l,a);let c=Ce(ft(o,s),u);if(i){D(n!=null,()=>"When using zeroDebias: true, step is required.");const h=P(n,"step","movingAverage");c=bt(c,ft(l,Tc(a,h)))}return Ye(s,c)}const $G=K({movingAverage_:FG});function zG(r,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(s+` update.rank < ${i}. `);if(r.length<n+(t.rank-i))throw new Error(s+` Output shape length < ${n+(t.rank-i)}`);if(t.rank!==i+r.length-n)throw new Error(s+` update.rank != ${i+r.length-n}`);for(let o=0;o<i;++o)if(t.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-i;++o)if(t.shape[o+i]!==r[o+n])throw new Error(s+` updates.shape[${o+i}] (${t.shape[o+i]}) != shape[${o+i}] (${r[o+i]})`)}function BG(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}zG(t,e,r)}function AE(r,e,t){const n=e.shape.length,i=n>1?e.shape[n-1]:1,s=t.length;let o=1;for(let h=i;h<s;++h)o*=t[h];const a=i<1?1:i,l=ze(e.shape)/a,u=[...yr(t.slice(0,i)),1],c=ze(t);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UG(r,e,t){Zr(t);const n=P(r,"indices","scatterND","int32"),i=P(e,"updates","scatterND");BG(i,n,t);const s={indices:n,updates:i},o={shape:t};return X.runKernel(jT,s,o)}const VG=K({scatterND_:UG});function WG(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);const i=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GG(r,e,t,n=0){Zr(t);const i=P(r,"sparseIndices","sparseToDense","int32"),s=P(e,"sparseValues","sparseToDense","string_or_numeric"),o=P(n,"defaultValue","sparseToDense",s.dtype);WG(i,s,t,o);const a={sparseIndices:i,sparseValues:s,defaultValue:o},l={outputShape:t};return X.runKernel(a2,a,l)}const HG=K({sparseToDense_:GG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(r,e){const t=P(e,"indices","gatherND","int32"),i={params:P(r,"x","gatherND","string_or_numeric"),indices:t};return X.runKernel(ZS,i)}const qG=K({gatherND_:jG});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(r,e){if(e==null)return r.shape.slice();if(br(r.shape,e))return e;if(r.shape.length===e.length){const t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(r,e,t,n){const i=P(r,"x","dropout");if(D(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof dn?i.clone():i;const s=KG(i,t),o=1-e,a=bt(rE(Ye(bE(s,0,1,"float32",n),o)),o);return Ce(i,a)}const YG=K({dropout_:XG});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Dy(r,e,t){const n=1-r%2,i=new Float32Array(r);for(let s=0;s<r;++s){const o=2*Math.PI*s/(r+n-1);i[s]=e-t*Math.cos(o)}return ir(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ZG(r,e,t=1){const n=P(r,"predictions","inTopK"),i=P(e,"targets","inTopK");D(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),D(n.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${i.rank}`),Xr(n.shape.slice(0,n.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=n.shape[n.shape.length-1];D(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);const o=await n.data(),a=await i.data(),[l,u]=[o.length/s,s],c=Es("bool",l);for(let h=0;h<l;h++){const f=h*u,d=o.subarray(f,f+u),g=[];for(let p=0;p<d.length;p++)g.push({value:d[p],index:p});g.sort((p,m)=>m.value-p.value),c[h]=0;for(let p=0;p<t;p++)if(g[p].index===a[h]){c[h]=1;break}}return r!==n&&n.dispose(),e!==i&&i.dispose(),ts(c,i.shape,"bool")}const QG=ZG;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(r,e,t,n,i,s="NHWC",o){let a=r;r.rank===3&&(a=ye(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),D(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];D(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),D(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Ui("conv2dDerFilter",i,o);const h={x:a,dy:l},f={strides:n,pad:i,dataFormat:s,dimRoundingMode:o,filterShape:t};return X.runKernel(TS,h,f)}const e6=K({conv2DBackpropFilter_:JG});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oy(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return Ce(r,TE(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Fy(r,e){let t=e;const n=VU(r.shape,e.shape);return n.length>0&&(t=sn(t,n)),ye(t,r.shape)}function $y(r,e,t,n){if(e==="linear")return r;if(e==="relu")return Zf(r);if(e==="elu")return J2(r);if(e==="relu6")return xE(r);if(e==="prelu")return yE(r,t);if(e==="leakyrelu")return oE(r,n);if(e==="sigmoid")return Is(r);throw new Error(`Unknown fused activation ${e}.`)}const zy=(r,e)=>!(r>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t6({x:r,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",zy(X.state.gradientDepth,l)===!1){D(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Gf(r,e,t,n,i,s,o);return a!=null&&(I=Ye(I,a)),$y(I,l,u,c)}const h=P(r,"x","conv2d","float32"),f=P(e,"filter","conv2d","float32");let d=h,g=!1;h.rank===3&&(g=!0,d=ye(h,[1,h.shape[0],h.shape[1],h.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Ui("fused conv2d",n,o);const p=i==="NHWC"?d.shape[3]:d.shape[1];D(f.shape[2]===p,()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${f.shape[2]}.`),D(Us(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const m=as(d.shape,f.shape,t,s,n,o);let _;a!=null&&(_=P(a,"bias","fused conv2d"),[_]=yn(_,h),i==="NHWC"?Zt(m.outShape,_.shape):(D(_.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`),D(_.shape.length===0||_.shape[0]===m.outChannels||_.shape[0]===1,()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let v;if(u!=null){const I=u.shape;if(D(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)D(I[0]===1||I[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${m.outChannels}).`);else if(I.length===3)try{Zt(I,m.outShape)}catch{const S=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(S)}v=P(u,"prelu weights","fused conv2d")}const b=(I,C)=>{D(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[S,A,R,F]=C,q=Oy(I,R,l);D(af(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const O=Z2(A.shape,q,S,t,n),z=e6(A,q,S.shape,t,n),H=[O,z];if(F!=null){const Q=Fy(F,q);H.push(Q)}return H},x={x:d,filter:f,bias:_,preluActivationWeights:v},T={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Fs((C,S,A)=>{let R=X.runKernel(Mm,x,T);return A([S,C,R]),g&&(R=ye(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(d,f):Fs((C,S,A,R)=>{let F=X.runKernel(Mm,x,T);return R([S,C,F,A]),g&&(F=ye(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:b}})(d,f,_)}const n6=K({fusedConv2d_:t6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(r,e,t,n,i,s=[1,1],o){let a=r;r.rank===3&&(a=ye(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:n,pad:i,dimRoundingMode:o,dilations:s,filterShape:t};return X.runKernel(A$,u,c)}const i6=K({depthwiseConv2dNativeBackpropFilter_:r6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s6(r,e,t,n,i,s=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:n,pad:i,dimRoundingMode:o,dilations:s,inputShape:r},h=X.runKernel(I$,u,c);return l?ye(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const o6=K({depthwiseConv2dNativeBackpropInput_:s6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a6({x:r,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(zy(X.state.gradientDepth,l)===!1){let T=My(r,e,t,n,i,s,o);return a!=null&&(T=Ye(T,a)),$y(T,l,u,c)}const h=P(r,"x","depthwiseConv2d","float32"),f=P(e,"filter","depthwiseConv2d","float32");let d=h,g=!1;h.rank===3&&(g=!0,d=ye(h,[1,h.shape[0],h.shape[1],h.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),D(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),D(Us(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Ui("fused depthwiseConv2d",n,o);const p=as(d.shape,f.shape,t,s,n,o,!0);let m;a!=null&&(m=P(a,"bias","fused conv2d"),[m]=yn(m,h),Zt(p.outShape,m.shape));let _;u!=null&&(_=P(u,"prelu weights","fused depthwiseConv2d"));const v=(T,I)=>{D(af(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[C,S,A,R]=I,F=Oy(T,A,l),q=o6(S.shape,F,C,t,n,s,o),O=i6(S,F,C.shape,t,n,s,o);if(R!=null){const z=Fy(m,F);return[q,O,z]}return[q,O]},b={x:d,filter:f,bias:m,preluActivationWeights:_},x={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Fs((I,C,S)=>{let A=X.runKernel(Am,b,x);return S([C,I,A]),g&&(A=ye(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:v}})(d,f):Fs((I,C,S,A)=>{let R=X.runKernel(Am,b,x);return A([C,I,R,S]),g&&(R=ye(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(d,f,m)}const l6=K({fusedDepthwiseConv2d_:a6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:i,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(zy(X.state.gradientDepth,s)===!1){let F=Wt(r,e,t,n);return i!=null&&(F=Ye(F,i)),$y(F,s,o,a)}let l=P(r,"a","fused matMul"),u=P(e,"b","fused matMul");[l,u]=yn(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=n?u.shape[u.rank-1]:u.shape[u.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),p=u.shape.slice(0,-2),m=ze(g),_=ze(p);D(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${n} must match.`);const b=Zt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,d]),x=t?ye(l,[m,c,f]):ye(l,[m,f,c]),T=n?ye(u,[_,d,h]):ye(u,[_,h,d]);let I;i!=null&&(I=P(i,"bias","fused matMul"),[I]=yn(I,l),Zt(b,I.shape));let C;o!=null&&(C=P(o,"prelu weights","fused matMul"));const S=(F,q)=>{const[O,z,H,Q]=q,Z=Oy(ye(F,H.shape),H,s);let Y,fe;if(!t&&!n?(Y=Wt(Z,z,!1,!0),fe=Wt(O,Z,!0,!1)):!t&&n?(Y=Wt(Z,z,!1,!1),fe=Wt(Z,O,!0,!1)):t&&!n?(Y=Wt(z,Z,!1,!0),fe=Wt(O,Z,!1,!1)):(Y=Wt(z,Z,!0,!0),fe=Wt(Z,O,!0,!0)),i!=null){const le=Fy(Q,Z);return[Y,fe,le]}else return[Y,fe]},A={a:x,b:T,bias:I,preluActivationWeights:C},R={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:a};return i==null?Fs((q,O,z)=>{const H=X.runKernel(Em,A,R);return z([q,O,H]),{value:ye(H,b),gradFunc:S}})(x,T):Fs((q,O,z,H)=>{const Q=X.runKernel(Em,A,R);return H([q,O,Q,z]),{value:ye(Q,b),gradFunc:S}})(x,T,I)}const c6=K({fusedMatMul_:u6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h6=Object.freeze(Object.defineProperty({__proto__:null,conv2d:n6,depthwiseConv2d:l6,matMul:c6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6(r){return Dy(r,.54,.46)}const d6=K({hammingWindow_:f6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6(r){return Dy(r,.5,.5)}const CE=K({hannWindow_:p6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(r,e,t,n=!1,i=0){let s=0;const o=[];for(;s+e<=r.size;)o.push(_t(r,s,e)),s+=t;if(n)for(;s<r.size;){const a=s+e-r.size,l=kn([_t(r,s,e-a),Oc([a],i)]);o.push(l),s+=t}return o.length===0?vi([],[0,e]):ye(kn(o),[o.length,e])}const kE=K({frame_:m6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g6(r,e,t,n,i=CE){n==null&&(n=IE(e));const s=kE(r,e,t),o=Ce(s,i(e));return Ly(o,n)}const y6=K({stft_:g6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6(r,e,t,n,i="bilinear",s=0){const o=P(r,"image","cropAndResize"),a=P(e,"boxes","cropAndResize","float32"),l=P(t,"boxInd","cropAndResize","int32"),u=a.shape[0];D(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),D(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),D(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),D(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),D(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),D(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const c={image:o,boxes:a,boxInd:l},h={method:i,extrapolationValue:s,cropSize:n};return X.runKernel(kS,c,h)}const b6=K({cropAndResize_:_6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6(r){const e=P(r,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return X.runKernel(jS,t,{})}const v6=K({flipLeftRight_:x6});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w6(r){const e=P(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,ec(e,i)}const S6=K({grayscaleToRGB_:w6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6(r,e,t=0,n=.5){const i=P(r,"image","rotateWithOffset","float32");D(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const s={image:i},o={radians:e,fillValue:t,center:n};return X.runKernel(b2,s,o)}const E6=K({rotateWithOffset_:T6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hu(r,e,t,n,i,s){n==null&&(n=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=r.shape[0];return t=Math.min(t,o),D(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),D(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),D(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const s=P(r,"boxes","nonMaxSuppression","float32"),o=P(e,"scores","nonMaxSuppression","float32"),a=hu(s,o,t,n,i);t=a.maxOutputSize,n=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:n,scoreThreshold:i};return X.runKernel(MT,{boxes:s,scores:o},l)}const A6=K({nonMaxSuppression_:M6});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I6(r,e,t){const n=C6(r,e,t),i=n<0?-(n+1):n;r.splice(i,0,e)}function C6(r,e,t){return N6(r,e,t||k6)}function k6(r,e){return r>e?1:r<e?-1:0}function N6(r,e,t){let n=0,i=r.length,s=0,o=!1;for(;n<i;){s=n+(i-n>>>1);const a=t(e,r[s]);a>0?n=s+1:(i=s,o=!a)}return o?n:-n-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(r,e,t,n,i){return By(r,e,t,n,i,0)}function R6(r,e,t,n,i,s){return By(r,e,t,n,i,0,!1,s,!0)}function RE(r,e,t,n,i,s){return By(r,e,t,n,i,s,!0)}function By(r,e,t,n,i,s,o=!1,a=!1,l=!1){const u=[];for(let m=0;m<e.length;m++)e[m]>i&&u.push({score:e[m],boxIndex:m,suppressBeginIndex:0});u.sort(px);const c=s>0?-.5/s:0,h=[],f=[];for(;h.length<t&&u.length>0;){const m=u.pop(),{score:_,boxIndex:v,suppressBeginIndex:b}=m;if(_<i)break;let x=!1;for(let T=h.length-1;T>=b;--T){const I=P6(r,v,h[T]);if(I>=n){x=!0;break}if(m.score=m.score*L6(n,c,I),m.score<=i)break}m.suppressBeginIndex=h.length,x||(m.score===_?(h.push(v),f.push(m.score)):m.score>i&&I6(u,m,px))}const d=h.length,g=t-d;a&&g>0&&(h.push(...new Array(g).fill(0)),f.push(...new Array(g).fill(0)));const p={selectedIndices:h};return o&&(p.selectedScores=f),l&&(p.validOutputs=d),p}function P6(r,e,t){const n=r.subarray(e*4,e*4+4),i=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),o=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),u=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),d=(a-s)*(l-o),g=(h-u)*(f-c);if(d<=0||g<=0)return 0;const p=Math.max(s,u),m=Math.max(o,c),_=Math.min(a,h),v=Math.min(l,f),b=Math.max(_-p,0)*Math.max(v-m,0);return b/(d+g-b)}function L6(r,e,t){const n=Math.exp(e*t*t);return t<=r?n:0}function px(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function D6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const s=P(r,"boxes","nonMaxSuppressionAsync"),o=P(e,"scores","nonMaxSuppressionAsync"),a=hu(s,o,t,n,i);t=a.maxOutputSize,n=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=NE(u,c,t,n,i);return s!==r&&s.dispose(),o!==e&&o.dispose(),ir(h,"int32")}const O6=D6;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=P(r,"boxes","nonMaxSuppression"),a=P(e,"scores","nonMaxSuppression"),l=hu(o,a,t,n,i,s);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:s},h=X.runKernel(AT,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const $6=K({nonMaxSuppressionWithScore_:F6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function z6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=P(r,"boxes","nonMaxSuppressionAsync"),a=P(e,"scores","nonMaxSuppressionAsync"),l=hu(o,a,t,n,i,s);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:f,selectedScores:d}=RE(c,h,t,n,i,s);return o!==r&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ir(f,"int32"),selectedScores:ir(d)}}const B6=z6;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=P(r,"boxes","nonMaxSuppression"),a=P(e,"scores","nonMaxSuppression"),l=hu(o,a,t,n,i,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},d={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:s},g=X.runKernel(R$,f,d);return{selectedIndices:g[0],validOutputs:g[1]}}const V6=K({nonMaxSuppressionPadded_:U6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function W6(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=P(r,"boxes","nonMaxSuppressionAsync"),a=P(e,"scores","nonMaxSuppressionAsync"),l=hu(o,a,t,n,i,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[f,d]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:p}=R6(f,d,u,c,h,s);return o!==r&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ir(g,"int32"),validOutputs:yt(p,"int32")}}const G6=W6;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6(r,e,t=!1,n=!1){const i=P(r,"images","resizeBilinear");D(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=ye(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:n,size:e},u=X.runKernel(UT,a,l);return o?ye(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const j6=K({resizeBilinear_:H6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6(r,e,t=!1,n=!1){const i=P(r,"images","resizeNearestNeighbor");D(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=ye(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:n,size:e},u=X.runKernel(BT,a,l);return o?ye(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const K6=K({resizeNearestNeighbor_:q6});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6(r,e="binary",t=!1,n=.5){const i=P(r,"image","threshold"),s=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let u=Ce(ir([n]),255),c,h,f,d;if(D(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),D(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),D(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[c,h,f]=Ic(i,[1,1,1],-1);const m=Ce(c,s),_=Ce(h,o),v=Ce(f,a);d=Ye(Ye(m,_),v)}else d=r;if(e==="otsu"){const m=X2(ln(vE(d),"int32"),ts([]),256);u=Y6(m,l)}const g=t?Iy(d,u):Xf(d,u);return ln(Ce(g,255),"int32")}function Y6(r,e){let t=ir([-1]),n=ir([0]),i=ir([0]),s,o,a,l,u,c;for(let h=0;h<r.size-1;h++){s=_t(r,0,h+1),o=_t(r,h+1),u=bt(sn(s),e),c=bt(sn(o),e);const f=sn(Ce(s,Mc(0,s.size)));a=bt(f,sn(s));const d=Oc(o.shape,s.size),g=Ye(Mc(0,o.size),d),p=Ce(o,g);l=bt(sn(p),sn(o));const m=ft(a,l),_=ft(a,l),v=Ce(u,c);i=Ce(Ce(v,m),_);const b=Xf(i,n);n=Yl(b,i,n),t=Yl(b,ir([h]),t)}return t}const Z6=K({threshold_:X6});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q6(r,e,t="nearest",n="constant",i=0,s){const o=P(r,"image","transform","float32"),a=P(e,"transforms","transform","float32");D(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),D(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:o,transforms:a},u={interpolation:t,fillMode:n,fillValue:i,outputShape:s};return X.runKernel(m2,l,u)}const J6=K({transform_:Q6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eH(r,e,t){D(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const n=P(r,"a","bandPart");D(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const i=n.shape,[s,o]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),t<0&&(t=o);const a=ye(Mc(0,s,1,"int32"),[-1,1]),l=Mc(0,o,1,"int32"),u=ft(a,l),c=uf(Iy(u,yt(+e,"int32")),sE(u,yt(-t,"int32"))),h=Mo([s,o],n.dtype);return ye($s(Fa(ye(n,[-1,s,o])).map(f=>Yl(c,f,h))),i)}const tH=K({bandPart_:eH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nH(r){let e;if(Array.isArray(r)){e=!1,D(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=r[0].shape[0];for(let s=1;s<r.length;++s)D(r[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${i})`)}else e=!0,r=Ic(r,r.shape[0],0).map(i=>Vt(i,[0]));D(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);const t=[],n=r;for(let i=0;i<r.length;++i)t.push(X.tidy(()=>{let s=n[i];if(i>0)for(let o=0;o<i;++o){const a=Ce(sn(Ce(t[o],s)),t[o]);s=ft(s,a)}return bt(s,Kf(s,"euclidean"))}));return e?$s(t,0):t}const rH=K({gramSchmidt_:nH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iH(r,e=!1){if(D(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return mx(r,e);{const t=r.shape.slice(0,r.shape.length-2).reduce((l,u)=>l*u),n=Fa(ye(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),i=[],s=[];n.forEach(l=>{const[u,c]=mx(l,e);i.push(u),s.push(c)});const o=ye($s(i,0),r.shape),a=ye($s(s,0),r.shape);return[o,a]}}function mx(r,e=!1){return X.tidy(()=>{D(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);const t=r.shape[0],n=r.shape[1];let i=nE(t),s=bo(r);const o=vi([[1]],[1,1]);let a=bo(o);const l=t>=n?n:t;for(let u=0;u<l;++u){const c=s,h=a,f=i;[a,s,i]=X.tidy(()=>{const d=_t(s,[u,u],[t-u,1]),g=Kf(d),p=_t(s,[u,u],[1,1]),m=Yl(Xf(p,0),vi([[-1]]),vi([[1]])),_=ft(p,Ce(m,g)),v=bt(d,_);v.shape[0]===1?a=bo(o):a=kn([o,_t(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const b=Cs(bt(Wt(m,_),g)),x=_t(s,[u,0],[t-u,n]),T=Ce(b,a),I=Ym(a);if(u===0)s=ft(x,Wt(T,Wt(I,x)));else{const A=ft(x,Wt(T,Wt(I,x)));s=kn([_t(s,[0,0],[u,n]),A],0)}const C=Ym(T),S=_t(i,[0,u],[t,i.shape[1]-u]);if(u===0)i=ft(S,Wt(Wt(S,a),C));else{const A=ft(S,Wt(Wt(S,a),C));i=kn([_t(i,[0,0],[t,u]),A],1)}return[a,s,i]}),zt([c,h,f])}return!e&&t>n&&(i=_t(i,[0,0],[t,n]),s=_t(s,[0,0],[n,n])),[i,s]})}const sH=K({qr_:iH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pr;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(pr||(pr={}));function oH(r,e,t=pr.SUM_BY_NONZERO_WEIGHTS){const n=P(r,"losses","computeWeightedLoss");let i=null;e!=null&&(i=P(e,"weights","computeWeightedLoss"));const s=i==null?n:Ce(n,i);if(t===pr.NONE)return s;if(t===pr.SUM)return sn(s);if(t===pr.MEAN){if(i==null)return cf(s);{const o=n.size/i.size,a=bt(sn(s),sn(i));return o>1?bt(a,yt(o)):a}}if(t===pr.SUM_BY_NONZERO_WEIGHTS){if(i==null)return bt(sn(s),yt(n.size));{const o=Ce(i,oa(n.shape)),a=ln(sn(mE(o,yt(0))),"float32");return bt(sn(s),a)}}throw Error(`Unknown reduction: ${t}`)}const Vs=K({computeWeightedLoss_:oH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aH(r,e,t,n=pr.SUM_BY_NONZERO_WEIGHTS){const i=P(r,"labels","absoluteDifference"),s=P(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=P(t,"weights","absoluteDifference")),Xr(i.shape,s.shape,"Error in absoluteDifference: ");const a=$r(ft(i,s));return Vs(a,o,n)}const lH=K({absoluteDifference_:aH});function uH(r,e,t,n,i=pr.SUM_BY_NONZERO_WEIGHTS){const s=P(r,"labels","cosineDistance"),o=P(e,"predictions","cosineDistance");let a=null;n!=null&&(a=P(n,"weights","cosineDistance")),Xr(s.shape,o.shape,"Error in cosineDistance: ");const l=yt(1),u=ft(l,sn(Ce(s,o),t,!0));return Vs(u,a,i)}const cH=K({cosineDistance_:uH});function hH(r,e,t,n=pr.SUM_BY_NONZERO_WEIGHTS){let i=P(r,"labels","hingeLoss");const s=P(e,"predictions","hingeLoss");let o=null;t!=null&&(o=P(t,"weights","hingeLoss")),Xr(i.shape,s.shape,"Error in hingeLoss: ");const a=yt(1);i=ft(Ce(yt(2),i),a);const l=Zf(ft(a,Ce(i,s)));return Vs(l,o,n)}const fH=K({hingeLoss_:hH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dH(r,e,t,n=1,i=pr.SUM_BY_NONZERO_WEIGHTS){const s=P(r,"labels","huberLoss"),o=P(e,"predictions","huberLoss");let a=null;t!=null&&(a=P(t,"weights","huberLoss")),Xr(s.shape,o.shape,"Error in huberLoss: ");const l=yt(n),u=$r(ft(o,s)),c=ky(u,l),h=ft(u,c),f=Ye(Ce(yt(.5),xi(c)),Ce(l,h));return Vs(f,a,i)}const pH=K({huberLoss_:dH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mH(r,e,t,n=1e-7,i=pr.SUM_BY_NONZERO_WEIGHTS){const s=P(r,"labels","logLoss"),o=P(e,"predictions","logLoss");let a=null;t!=null&&(a=P(t,"weights","logLoss")),Xr(s.shape,o.shape,"Error in logLoss: ");const l=yt(1),u=yt(n),c=Cs(Ce(s,Ec(Ye(o,u)))),h=Ce(ft(l,s),Ec(Ye(ft(l,o),u))),f=ft(c,h);return Vs(f,a,i)}const gH=K({logLoss_:mH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(r,e,t,n=pr.SUM_BY_NONZERO_WEIGHTS){const i=P(r,"labels","meanSquaredError"),s=P(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=P(t,"weights","meanSquaredError")),Xr(i.shape,s.shape,"Error in meanSquaredError: ");const a=SE(i,s);return Vs(a,o,n)}const _H=K({meanSquaredError_:yH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(r,e){const t=P(r,"labels","sigmoidCrossEntropyWithLogits"),n=P(e,"logits","sigmoidCrossEntropyWithLogits");Xr(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Zf(n),s=Ce(n,t),o=aE(Os(Cs($r(n))));return Ye(ft(i,s),o)}function xH(r,e,t,n=0,i=pr.SUM_BY_NONZERO_WEIGHTS){let s=P(r,"multiClassLabels","sigmoidCrossEntropy");const o=P(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=P(t,"weights","sigmoidCrossEntropy")),Xr(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),n>0){const u=yt(n),c=yt(1),h=yt(.5);s=Ye(Ce(s,ft(c,u)),Ce(h,u))}const l=bH(s,o);return Vs(l,a,i)}const vH=K({sigmoidCrossEntropy_:xH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wH(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Fs((i,s,o)=>{const l=uE(s,[t],!0),u=ft(ln(s,"float32"),l);o([i,u]);const c=Cs(Ce(u,i));return{value:sn(c,[t]),gradFunc:(d,g)=>{const[p,m]=g,_=cu(d.shape,[t]);return[Ce(ye(d,_),ft(ln(p,"float32"),Os(m))),Ce(ye(d,_),ft(Os(m),ln(p,"float32")))]}}})(r,e)}function SH(r,e,t,n=0,i=pr.SUM_BY_NONZERO_WEIGHTS){let s=P(r,"onehotLabels","softmaxCrossEntropy");const o=P(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=P(t,"weights","softmaxCrossEntropy")),Xr(s.shape,o.shape,"Error in softmaxCrossEntropy: "),n>0){const u=yt(n),c=yt(1),h=yt(s.shape[1]);s=Ye(Ce(s,ft(c,u)),bt(u,h))}const l=wH(s,o);return Vs(l,a,i)}const TH=K({softmaxCrossEntropy_:SH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EH(r,e,t,n){const i=P(r,"indices","sparseFillEmptyRows","int32"),s=P(e,"values","sparseFillEmptyRows"),o=P(t,"denseShape","sparseFillEmptyRows","int32"),a=P(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:i,values:s,denseShape:o,defaultValue:a},u=X.runKernel(O$,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const MH=K({sparseFillEmptyRows_:EH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AH(r,e,t){const n=P(r,"inputIndices","sparseReshape","int32"),i=P(e,"inputShape","sparseReshape","int32"),s=P(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:n,inputShape:i,newShape:s},a=X.runKernel(F$,o);return{outputIndices:a[0],outputShape:a[1]}}const IH=K({sparseReshape_:AH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CH(r,e,t){const n=P(r,"data","sparseSegmentMean"),i=P(e,"indices","sparseSegmentMean","int32"),s=P(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:n,indices:i,segmentIds:s};return X.runKernel($$,o)}const kH=K({sparseSegmentMean_:CH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NH(r,e,t){const n=P(r,"data","sparseSegmentSum"),i=P(e,"indices","sparseSegmentSum","int32"),s=P(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:n,indices:i,segmentIds:s};return X.runKernel(z$,o)}const RH=K({sparseSegmentSum_:NH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(r,e,t,n,i,s,o,a){const l=P(r,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=P(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:n,leftPad:i,rightPad:s,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:u},f=X.runKernel(c2,h,c);return{nGrams:f[0],nGramsSplits:f[1]}}const LH=K({stringNGrams_:PH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DH(r,e,t=!0){const n=P(r,"input","stringSplit","string"),i=P(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:t},o={input:n,delimiter:i},a=X.runKernel(U$,o,s);return{indices:a[0],values:a[1],shape:a[2]}}const OH=K({stringSplit_:DH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(r,e){const t=P(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return X.runKernel(V$,i,n)}const $H=K({stringToHashBucketFast_:FH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zH={fft:Py,ifft:hf,rfft:Ly,irfft:wE},BH={hammingWindow:d6,hannWindow:CE,frame:kE,stft:y6},xo={flipLeftRight:v6,grayscaleToRGB:S6,resizeNearestNeighbor:K6,resizeBilinear:j6,rotateWithOffset:E6,cropAndResize:b6,nonMaxSuppression:A6,nonMaxSuppressionAsync:O6,nonMaxSuppressionWithScore:$6,nonMaxSuppressionWithScoreAsync:B6,nonMaxSuppressionPadded:V6,nonMaxSuppressionPaddedAsync:G6,threshold:Z6,transform:J6},UH={bandPart:tH,gramSchmidt:rH,qr:sH},VH={absoluteDifference:lH,computeWeightedLoss:Vs,cosineDistance:cH,hingeLoss:fH,huberLoss:pH,logLoss:gH,meanSquaredError:_H,sigmoidCrossEntropy:vH,softmaxCrossEntropy:TH},WH={sparseFillEmptyRows:MH,sparseReshape:IH,sparseSegmentMean:kH,sparseSegmentSum:RH},GH={stringNGrams:LH,stringSplit:OH,stringToHashBucketFast:$H};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HH{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Jo{constructor(){this.classNameMap={}}static getMap(){return Jo.instance==null&&(Jo.instance=new Jo),Jo.instance}static register(e){Jo.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function jH(r){D(r.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),D(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Jo.register(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $a extends HH{minimize(e,t=!1,n){const{value:i,grads:s}=this.computeGradients(e,n);if(n!=null){const o=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(o)}else this.applyGradients(s);return zt(s),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return $4(e,t)}dispose(){this.iterations_!=null&&zt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:yt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty($a,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qH extends $a{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=X.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=X.registeredVariables[n],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accum_grad`,variable:ht(()=>Gr(s).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${n}/accum_var`,variable:ht(()=>Gr(s).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[n];if(a==null)return;const l=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;ht(()=>{const c=Ye(Ce(l,this.rho),Ce(xi(a),1-this.rho)),h=Ce(bt(Ds(Ye(u,this.epsilon)),Ds(Ye(l,this.epsilon))),a),f=Ye(Ce(u,this.rho),Ce(xi(h),1-this.rho));l.assign(c),u.assign(f);const d=Ye(Ce(h,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(zt(this.accumulatedGrads.map(e=>e.variable)),zt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KH extends $a{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=X.registeredVariables[n];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accumulator`,variable:ht(()=>Oc(s.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[i].tensor:e[n];if(o==null)return;const a=this.accumulatedGrads[i].variable;ht(()=>{const l=Ye(a,xi(o));a.assign(l);const u=Ye(Ce(bt(o,Ds(Ye(l,X.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&zt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XH extends $a{constructor(e,t,n,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ht(()=>{this.accBeta1=yt(t).variable(),this.accBeta2=yt(n).variable()}),i==null&&(this.epsilon=X.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ht(()=>{const n=ft(1,this.accBeta1),i=ft(1,this.accBeta2);t.forEach((s,o)=>{const a=X.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:ht(()=>Gr(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:ht(()=>Gr(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[s];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=Ye(Ce(c,this.beta1),Ce(u,1-this.beta1)),d=Ye(Ce(h,this.beta2),Ce(xi(u),1-this.beta2)),g=bt(f,n),p=bt(d,i);c.assign(f),h.assign(d);const m=Ye(Ce(bt(g,Ye(Ds(p),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(Ce(this.accBeta1,this.beta1)),this.accBeta2.assign(Ce(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&zt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&zt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ht(()=>{this.accBeta1.assign(Tc(this.beta1,this.iterations_+1)),this.accBeta2.assign(Tc(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YH extends $a{constructor(e,t,n,i=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ht(()=>{this.iteration=yt(0).variable(),this.accBeta1=yt(t).variable()}),i==null&&(this.epsilon=X.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ht(()=>{const n=ft(1,this.accBeta1),i=bt(-this.learningRate,Ye(Ce(this.iteration,this.decay),1));t.forEach((s,o)=>{const a=X.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:Gr(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:Gr(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[s];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=Ye(Ce(c,this.beta1),Ce(u,1-this.beta1)),d=Ce(h,this.beta2),g=$r(u),p=dE(d,g);c.assign(f),h.assign(p);const m=Ye(Ce(bt(i,n),bt(f,Ye(p,this.epsilon))),a);a.assign(m)}),this.iteration.assign(Ye(this.iteration,1)),this.accBeta1.assign(Ce(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&zt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&zt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PE extends $a{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=Array.isArray(e)?e[i].tensor:e[n];if(s==null)return;const o=X.registeredVariables[n];ht(()=>{const a=Ye(Ce(this.c,s),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Zi(yt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZH extends PE{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=yt(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=X.registeredVariables[n];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${n}/momentum`,variable:ht(()=>Gr(s).variable(!1))});const o=this.accumulations[i].variable,a=Array.isArray(e)?e[i].tensor:e[n];a!=null&&ht(()=>{let l;const u=Ye(Ce(this.m,o),a);this.useNesterov?l=Ye(Ce(this.c,Ye(a,Ce(u,this.m))),s):l=Ye(Ce(this.c,u),s),o.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&zt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QH extends $a{constructor(e,t=.9,n=0,i=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,i==null&&(this.epsilon=X.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=X.registeredVariables[n],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${n}/rms`,variable:ht(()=>Gr(s).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${n}/momentum`,variable:ht(()=>Gr(s).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${n}/mg`,variable:ht(()=>Gr(s).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[n];if(a==null)return;const l=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;ht(()=>{const c=Ye(Ce(l,this.decay),Ce(xi(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=Ye(Ce(h,this.decay),Ce(a,1-this.decay)),d=bt(Ce(a,this.learningRate),Ds(ft(c,Ye(xi(f),this.epsilon)))),g=Ye(Ce(u,this.momentum),d);l.assign(c),h.assign(f),u.assign(g);const p=ft(s,g);s.assign(p)}else{const h=Ye(Ce(l,this.decay),Ce(xi(a),1-this.decay)),f=Ye(Ce(u,this.momentum),bt(Ce(a,this.learningRate),Ds(Ye(h,this.epsilon))));l.assign(h),u.assign(f);const d=ft(s,f);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&zt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&zt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&zt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JH=[qH,KH,XH,YH,ZH,QH,PE];function e5(){for(const r of JH)jH(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5="model",n5=".json",r5=".weights.bin";function gx(r){return new Promise(e=>setTimeout(e)).then(r)}class ka{constructor(e){if(!it().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ka.URL_SCHEME)&&(e=e.slice(ka.URL_SCHEME.length)),(e==null||e.length===0)&&(e=t5),this.modelJsonFileName=e+n5,this.weightDataFileName=e+r5}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=L2(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await gx(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await gx(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Dc(e)}}}}ka.URL_SCHEME="downloads://";class i5{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=i=>{const s=JSON.parse(i.target.result),o=s.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=Ey(s,u=>this.loadWeights(u));e(l)},n.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const o of e)t.push(...o.weights),n.push(...o.paths);const i=this.checkManifestAndWeightFiles(e),s=n.map(o=>this.loadWeightsFile(o,i[o]));return Promise.all(s).then(o=>[t,Ty(o)])}loadWeightsFile(e,t){return new Promise((n,i)=>{const s=new FileReader;s.onload=o=>{const a=o.target.result;n(a)},s.onerror=o=>i(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(s=>dx(s.name)),i={};for(const s of e)s.paths.forEach(o=>{const a=dx(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);i[o]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const s5=r=>it().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ka.URL_SCHEME)?o5(r.slice(ka.URL_SCHEME.length)):null;hn.registerSaveRouter(s5);function o5(r="model"){return new ka(r)}function a5(r){return new i5(r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(r,e,t,n){o(r),t=t??0,n=n??1,a(t,n);let i=0;const s=l=>(l.then(u=>{const c=t+ ++i/r.length*(n-t);return e(c),u}),l);function o(l){D(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),D(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(r.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LE(r,e){e==null&&(e={});const t=e.fetchFunc==null?it().platform.fetch:e.fetchFunc,n=r.map(h=>t(h,e.requestInit,{isBinary:!0})),i=0,s=.5,a=(e.onProgress==null?await Promise.all(n):await yx(n,e.onProgress,i,s)).map(h=>h.arrayBuffer()),l=.5,u=1;return e.onProgress==null?await Promise.all(a):await yx(a,e.onProgress,l,u)}async function l5(r,e="",t,n){return DE(o=>LE(o,{requestInit:n}))(r,e,t)}function DE(r){return async(e,t="",n)=>{const i=e.map(()=>!1),s={},o=n!=null?n.map(()=>!1):[],a=[];if(e.forEach((d,g)=>{let p=0;d.weights.forEach(m=>{const _="quantization"in m?m.quantization.dtype:m.dtype,v=Om[_]*ze(m.shape),b=()=>{i[g]=!0,s[g]==null&&(s[g]=[]),s[g].push({manifestEntry:m,groupOffset:p,sizeBytes:v})};n!=null?n.forEach((x,T)=>{x===m.name&&(b(),o[T]=!0)}):b(),a.push(m.name),p+=v})}),!o.every(d=>d)){const d=n.filter((g,p)=>!o[p]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=i.reduce((d,g,p)=>(g&&d.push(p),d),[]),u=[];l.forEach(d=>{e[d].paths.forEach(g=>{const p=t+(t.endsWith("/")?"":"/")+g;u.push(p)})});const c=await r(u),h={};let f=0;return l.forEach(d=>{const g=e[d].paths.length;let p=0;for(let x=0;x<g;x++)p+=c[f+x].byteLength;const m=new ArrayBuffer(p),_=new Uint8Array(m);let v=0;for(let x=0;x<g;x++){const T=new Uint8Array(c[f+x]);_.set(T,v),v+=T.byteLength}s[d].forEach(x=>{const T=m.slice(x.groupOffset,x.groupOffset+x.sizeBytes),I=P2(T,[x.manifestEntry]);for(const C in I)h[C]=I[C]}),f+=g}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5="application/octet-stream",c5="application/json";class Uy{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=it().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=L2(e,n);t.body.append("model.json",new Blob([JSON.stringify(i)],{type:c5}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:u5}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Dc(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const n=t.modelTopology,i=t.weightsManifest;if(n==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ey(t,s=>this.loadWeights(s))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=h5(t),s=this.weightPathPrefix||n,o=O2(e),a=[],l=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(s+h+i);this.weightUrlConverter&&a.push(...await Promise.all(l));const u=await LE(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,Ty(u)]}}Uy.URL_SCHEME_REGEX=/^https?:\/\//;function h5(r){const e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),i=t>e?r.substring(t):"";return[n+"/",i]}function Zm(r){return r.match(Uy.URL_SCHEME_REGEX)!=null}const OE=(r,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Zm(n)):t=Zm(r),t)return Vy(r,e)}return null};hn.registerSaveRouter(OE);hn.registerLoadRouter(OE);function Vy(r,e){return new Uy(r,e)}function f5(r,e){return Vy(r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mp{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class FE{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class d5{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function p5(r,e,t,n){const i=arguments;return new d5($E(...i))}function $E(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new mp(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mp({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mp({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function m5(r){return new FE(r)}function g5(r){return new FE(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:a5,browserHTTPRequest:f5,concatenateArrayBuffers:Ty,copyModel:Hz,decodeWeights:P2,encodeWeights:xz,fromMemory:p5,fromMemorySync:$E,getLoadHandlers:Nz,getModelArtifactsForJSON:Ey,getModelArtifactsForJSONSync:D2,getModelArtifactsInfoForJSON:Dc,getSaveHandlers:kz,getWeightSpecs:O2,http:Vy,isHTTPScheme:Zm,listModels:Wz,loadWeights:l5,moveModel:jz,registerLoadRouter:Cz,registerSaveRouter:Iz,removeModel:Gz,weightsLoaderFactory:DE,withSaveHandler:m5,withSaveHandlerSync:g5},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uo;function y5(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,i=!1,s=!1,o=!1,a=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(Im(Tm,X.backendName)!=null){const g={pixels:r},p={numChannels:e};return X.runKernel(Tm,g,p)}const[u,c]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height];let h;if(o)h=r.getContext("2d").getImageData(0,0,u,c).data;else if(n||t)h=r.data;else if(s||i||a){if(Uo==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Uo=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Uo=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Uo.canvas.width=u,Uo.canvas.height=c,Uo.drawImage(r,0,0,u,c),h=Uo.getImageData(0,0,u,c).data}let f;if(e===4)f=new Int32Array(h);else{const g=u*c;f=new Int32Array(g*e);for(let p=0;p<g;p++)for(let m=0;m<e;++m)f[p*e+m]=h[p*4+m]}return EE(f,[c,u,e],"int32")}async function Wy(r,e){let t=P(r,"img","toPixels");if(!(r instanceof dn)){const u=t;t=ln(u,"int32"),u.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[n,i]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*n*4);for(let u=0;u<n*i;++u){const c=[0,0,0,255];for(let f=0;f<s;f++){const d=o[u*s+f];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(c[0]=d*a,c[1]=d*a,c[2]=d*a):c[f]=d*a}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(e!=null){e.width=i,e.height=n;const u=e.getContext("2d"),c=new ImageData(l,i,n);u.putImageData(c,0,0)}return t!==r&&t.dispose(),l}const BE=K({fromPixels_:y5});function _5(r,e){const t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(ze(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);const i=e.shape,s=i[i.length-1];let o=1;for(let h=0;h<i.length-1;++h)o*=i[h];const a=r.shape,l=i.slice();l.pop();let u=1;for(let h=s;h<t;++h)u*=a[h],l.push(a[h]);const c=[...yr(r.shape).map(h=>h/u),1].slice(0,s);return[l,o,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qm=-2,b5=-1;function x5(r,e,t){const n=r.shape.length;D(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),D(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let i=0;i<n;++i)D(e[i]+t[i]<=r.shape[i],()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${r.shape[i]})`)}function v5(r,e,t){const n=[];for(let i=0;i<r.length;i++)n[i]=Math.ceil((e[i]-r[i])/t[i]);return n}function w5(r,e,t){let n=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){n=i;break}for(let i=n+1;i<t.length;i++)if(e[i]>0||t[i]!==r[i])return!1;return!0}function S5(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function T5(r,e,t){let n;const i=r.shape.length;typeof e=="number"?n=[e,...new Array(i-1).fill(0)]:e.length<i?n=e.concat(new Array(i-e.length).fill(0)):n=e.slice(),n.forEach(o=>{D(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(i).fill(-1):typeof t=="number"?s=[t,...new Array(i-1).fill(-1)]:t.length<i?s=t.concat(new Array(i-t.length).fill(-1)):s=t,s=s.map((o,a)=>o>=0?o:(D(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function E5(r,e,t,n,i,s,o,a,l){let u;if(n==null?(u=new Array(e.length),u.fill(1)):u=n,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)c&&1<<b&a&&h.numAddAxisAfterEllipsis++,1<<b&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};M5(h,f);let d=!0,g=!0,p=!0;const m=[],_=[];for(let b=0;b<r.length;++b){if(f.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const x=!!(f.shrinkAxisMask&1<<b),T=r[b];if(T===-1){m.push(x?1:-1);continue}const I=[f.beginMask&1<<b,f.endMask&1<<b],C=[f.strides[b]>0?0:-1,f.strides[b]>0?T:T-1];if(x&&f.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");p=p&&f.strides[b]===1;const S=!!(f.beginMask&1<<b&&f.endMask&1<<b);if(f.beginValid&&f.endValid){if(x){const q=f.begin[b]<0?T+f.begin[b]:f.begin[b];if(f.begin[b]=q,f.end[b]=f.begin[b]+1,q<0||q>=T)throw Error(`slice index ${f.begin[b]} of dimension ${b} out of bounds.`)}else f.begin[b]=_x(f.begin[b],0,f.strides[b],T,I,C),f.end[b]=_x(f.end[b],1,f.strides[b],T,I,C);const F=f.strides[b]===1&&f.begin[b]===0&&f.end[b]===T;d=d&&F,g=g&&(b===0&&f.strides[b]===1||F)}else d=d&&f.strides[b]===1&&S,g=g&&(b===0&&f.strides[b]===1||S);let A,R=!1;if(f.beginValid&&f.endValid?(A=f.end[b]-f.begin[b],R=!0):x?(A=1,R=!0):S&&T>=0&&(f.strides[b]<0?A=-T:A=T,R=!0),R){let F;A===0||A<0!=f.strides[b]<0?F=0:F=Math.trunc(A/f.strides[b])+(A%f.strides[b]!==0?1:0),m.push(F)}else m.push(-1)}for(let b=0;b<f.finalShapeGatherIndices.length;++b){const x=f.finalShapeGatherIndices[b];x>=0?_.push(m[x]):x===Qm&&_.push(1)}return{finalShapeSparse:_.filter((b,x)=>f.finalShapeGatherIndices[x]!==Qm),finalShape:_,isIdentity:d,sliceDim0:g,isSimpleSlice:p,begin:f.begin,end:f.end,strides:f.strides}}function M5(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){const i=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(Qm),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(b5),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function _x(r,e,t,n,i,s){if(i[e])return t>0?s[e]:s[e+1&1];{const o=r<0?n+r:r;return o<s[0]?s[0]:o>s[1]?s[1]:o}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(r,e){const t=r[0].length;r.forEach((i,s)=>{D(i.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const n=r[0];r.forEach((i,s)=>{for(let o=0;o<t;o++)D(o===e||i[o]===n[o],()=>`Error in concat${t}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function tc(r,e){const t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ki;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(Ki||(Ki={}));function I5(r,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<r+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(r+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${r+t.length}, but shape.rank = ${n.length}`);for(let i=1;i<t.length;++i){const s=t[i],o=n[n.length-t.length+i],a=n[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+r}] = ${s} but shape[${i+r}] = ${a}`)}else n[o]=s}return n}function C5(r){const e={FIRST_DIM_SIZE:Ki.FIRST_DIM_SIZE,VALUE_ROWIDS:Ki.VALUE_ROWIDS,ROW_LENGTHS:Ki.ROW_LENGTHS,ROW_SPLITS:Ki.ROW_SPLITS,ROW_LIMITS:Ki.ROW_LIMITS,ROW_STARTS:Ki.ROW_STARTS},t=[];for(const n of r)if(n in e)t.push(e[n]);else break;return t}function k5(r){return r.length===0?0:r[0]===Ki.FIRST_DIM_SIZE?r.length-1:r.length}function N5(r,e){if(r==null||e==null)return;const t=r.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let i=0;i<Math.min(t,n-1);++i){const s=r[i],o=e[i+1];if(s>=0&&o>=0&&s!==1&&s!==o)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-r.length}] = ${s} but ragged tensor input.flatValues.shape[${i-r.length}] = ${o}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(r,e,t){const n=t*(typeof r=="number"?r:r[0]),i=e*(typeof r=="number"?r:r[1]);return[n,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(r,e,t,n=!0){let i=[];if(n)i=i.concat(e.slice(0)),i.push(r[0]/t),i=i.concat(r.slice(1));else{i=i.concat(r[0]);const s=e.length;for(let o=0;o<s;++o)i=i.concat([r[o+1]/e[o],e[o]]);i=i.concat(r.slice(s+1))}return i}function VE(r,e,t=!0){const n=[];if(t){n.push(e);for(let i=e+1;i<r;++i)i<=2*e?(n.push(i),n.push(i-(e+1))):n.push(i)}else{const i=[],s=[];for(let o=1;o<r;++o)o>=e*2+1||o%2===1?s.push(o):i.push(o);n.push(...i),n.push(0),n.push(...s)}return n}function WE(r,e,t,n=!0){const i=[];n?i.push(r[0]/t):i.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?i.push(e[s-1]*r[s]):i.push(r[s]/e[s-1]):i.push(r[s]);return i}function P5(r,e){const t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function L5(r,e,t){const n=r.slice(0,1);for(let i=0;i<t;++i)n.push(r[i+1]-e[i][0]-e[i][1]);return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D5=1.7580993408473768,O5=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F5=.3275911,$5=.254829592,z5=-.284496736,B5=1.421413741,U5=-1.453152027,V5=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);const t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gp="->",G5=/->/g,bx=",",xx="...";function H5(r,e){r=r.replace(/\s/g,"");const t=(r.length-r.replace(G5,"").length)/gp.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${gp}").`);const[n,i]=r.split(gp);D(n.indexOf(xx)===-1,()=>`The ellipsis notation ("${xx}") is not supported yet.`);const s=n.split(bx),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<i.length;++f){const d=i[f];if(!s.some(g=>g.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<n.length;++f){const d=n[f];a.indexOf(d)===-1&&d!==bx&&a.push(d)}const l=new Array(s.length);for(let f=0;f<o;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<s[f].length;++d)l[f].push(a.indexOf(s[f][d]))}const u=a.length,c=i.length,h=[];for(let f=c;f<u;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function j5(r,e){let t=new Array(r);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const n=[];for(let i=0;i<r;++i)t[i]===-1&&n.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:n}}function q5(r,e,t){const n=new Array(r);for(let i=0;i<t.length;++i){const s=t[i].shape;for(let o=0;o<e[i].length;++o)n[e[i][o]]===void 0?n[e[i][o]]=s[o]:D(n[e[i][o]]===s[o],()=>`Expected dimension ${n[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function K5(r,e){const t=r,n=[];let i=0;r.length===0&&t.push(-1),i=r.length+1;for(let o=0;o<i;++o)n.push([]);const s=[];for(let o=0;o<t.length;++o){const a=t[o],l=Y5(e,a);for(const u of l)s.indexOf(u)===-1&&(n[o].push(u),s.push(u))}return{path:t,steps:n}}function X5(r){return r.every((e,t)=>e===t)}function Y5(r,e){const t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function Z5(r,e,t=0){let n=[];if(typeof e=="number")D(r.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);D(i<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[s]=r.shape[t]-o}D(r.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function J5(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function e8(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function n8(r,e){return`size ${r} must be non-negative, not ${e}`}function r8(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function i8(r,e){const t=ze(r),n=ze(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function s8(r,e){const t=ze(r),n=ze(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vx(){return"segment ids must be >= 0"}function o8(){return"segment ids are not increasing"}function a8(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function l8(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u8(r,e,t,n){const i=e.shape.length,s=r.shape.length;if(n!==0&&(n<-i||n>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${n}`);if(n<0&&(n+=i),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let h=0;h<n;++h)if(r.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${r.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=r.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<n;++h)a.push(r.shape[h]),l*=r.shape[h];for(let h=n;h<t;h++)a.push(r.shape[h]),u*=r.shape[h];for(let h=n;h<i;h++)a.push(e.shape[h]);for(let h=t+1;h<s;h++)a.push(r.shape[h]),c*=r.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ff(r){try{return r.map(e=>ql(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function c8(r){return r.map(e=>pa(e))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */e5();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h8=it();h8.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var oi;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(oi||(oi={}));var wx;(function(r){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(wx||(wx={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f8={};function GE(r){return f8[r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E(r,e,t,n,i){const s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){const a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return rr(e.inputNames[s.inputIndexStart],t,n,i);if(s.type==="tensors")return e.inputNames.slice(a,l).map(f=>rr(f,t,n,i));const u=rr(e.inputNames.slice(a)[0],t,n,i),c=u.dataSync();return s.type==="number"?c[0]:vm(u.shape,c)}const o=e.attrParams[r];return o&&o.value}function rr(r,e,t,n){const[i,s]=Tr(r);if(n!=null){const a=n.getHashTableHandleByName(i);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[df(i,a)]);return o!==void 0?e[df(i,o)][s]:void 0}function d8(r,e,t){return e[df(r,t.currentContextId)]}function ys(r,e){const[t,n,i]=Tr(r);return[df(t,e&&e.currentContextId),n,i]}function df(r,e){return e?`${r}-${e}`:r}function Tr(r){const e=r.split(":");if(e.length===1)return[r,0,void 0];const t=e[0],n=e.length===3?e[1]:void 0,i=Number(e[e.length-1]);return[t,i,n]}function Fh(r,e,t){let n=E("pad",r,e,t);if(n==="explicit"){n=E("explicitPaddings",r,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=n[s*2],i[s][1]=n[s*2+1];return i}return n}function _s(r){return r.kept?r:bo(r)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p8=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],m8=Object.freeze(Object.defineProperty({__proto__:null,json:p8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g8=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],y8=Object.freeze(Object.defineProperty({__proto__:null,json:g8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _8=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],b8=Object.freeze(Object.defineProperty({__proto__:null,json:_8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x8=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],v8=Object.freeze(Object.defineProperty({__proto__:null,json:x8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w8=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],S8=Object.freeze(Object.defineProperty({__proto__:null,json:w8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T8=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],E8=Object.freeze(Object.defineProperty({__proto__:null,json:T8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M8=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],A8=Object.freeze(Object.defineProperty({__proto__:null,json:M8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I8=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],C8=Object.freeze(Object.defineProperty({__proto__:null,json:I8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k8=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],N8=Object.freeze(Object.defineProperty({__proto__:null,json:k8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R8=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],P8=Object.freeze(Object.defineProperty({__proto__:null,json:R8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L8=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],D8=Object.freeze(Object.defineProperty({__proto__:null,json:L8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O8=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],F8=Object.freeze(Object.defineProperty({__proto__:null,json:O8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $8=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],z8=Object.freeze(Object.defineProperty({__proto__:null,json:$8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B8=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],U8=Object.freeze(Object.defineProperty({__proto__:null,json:B8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V8=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],W8=Object.freeze(Object.defineProperty({__proto__:null,json:V8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G8=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],H8=Object.freeze(Object.defineProperty({__proto__:null,json:G8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j8=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],q8=Object.freeze(Object.defineProperty({__proto__:null,json:j8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K8=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],X8=Object.freeze(Object.defineProperty({__proto__:null,json:K8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y8=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Z8=Object.freeze(Object.defineProperty({__proto__:null,json:Y8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sx{constructor(){const e=[m8,y8,b8,v8,S8,E8,A8,C8,N8,P8,D8,F8,z8,U8,W8,H8,q8,X8,Z8],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,i)=>(n[i.tfOpName]=i,n),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,t={}){const n=e.node,i=[],s=[],o=[],a=n.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?i.push(p[m.name]):m.op==="Const"?s.push(p[m.name]):(m.input==null||m.input.length===0)&&o.push(p[m.name]),p),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(p=>{const m=a[p];m.inputNames.forEach((_,v)=>{const[b,,x]=ys(_),T=a[b];if(T.outputs!=null){const I=T.outputs.indexOf(x);if(I!==-1){const C=`${b}:${I}`;m.inputNames[v]=C}}m.inputs.push(T),T.children.push(m)})}),Object.keys(h).length===0?f.forEach(p=>{const m=a[p];m.children.length===0&&u.push(m)}):Object.keys(h).forEach(p=>{const[m]=ys(p),_=a[m];_!=null&&(_.signatureKey=h[p],u.push(_))}),Object.keys(c).length>0?Object.keys(c).forEach(p=>{const[m]=ys(p),_=a[m];_&&(_.signatureKey=c[p],l.push(_))}):l=i;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((p,m)=>(p[m.signature.name]=this.mapFunction(m),p),{}));const g={nodes:a,inputs:l,outputs:u,weights:s,placeholders:i,signature:t,functions:d};return o.length>0&&(g.initNodes=o),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=GE(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((i,s)=>(i[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},i),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((i,s)=>{const o=s.type;let a;switch(s.type){case"string":a=Jm(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Jm(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=og(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=og(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=tg(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=tg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=sg(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=sg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=eg(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=eg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=lg(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=lg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=ig(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=ig(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=ag(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=ag(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=ng(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=ng(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=rg(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=rg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=Tx(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Tx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return i[s.name]={value:a,type:o},i},{})),n}mapFunction(e){const t=e.nodeDef,n=[],i=[];let s={};t!=null&&(s=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&i.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=ys(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Gy(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),s[f]=d}),Object.keys(s).forEach(h=>{const f=s[h];f.inputNames.forEach((d,g)=>{const[p,,m]=ys(d),_=s[p];if(_.outputs!=null){const v=_.outputs.indexOf(m);if(v!==-1){const b=`${p}:${v}`;f.inputNames[g]=b}}f.inputs.push(_),_.children.push(f)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=ys(u[h.name]),g=s[f];g!=null&&(g.defaultOutput=d,a.push(g))});const c=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:i,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}function Q8(r){const e=it().global;if(typeof e.atob<"u")return e.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function HE(r,e){const t=Array.isArray(r)?String.fromCharCode.apply(null,r):Q8(r);return e?t:t.toLowerCase()}function Jm(r,e,t,n=!1){const i=r[e];return i!=null?HE(i.s,n):t}function eg(r,e,t){const n=r[e];return n?n.b:t}function tg(r,e,t){const n=r[e]||{},i=n.i!=null?n.i:n.f!=null?n.f:t;return typeof i=="number"?i:parseInt(i,10)}function Gy(r){switch(typeof r=="string"&&(r=oi[r]),r){case oi.DT_FLOAT:case oi.DT_HALF:return"float32";case oi.DT_INT32:case oi.DT_INT64:case oi.DT_INT8:case oi.DT_UINT8:return"int32";case oi.DT_BOOL:return"bool";case oi.DT_DOUBLE:return"float32";case oi.DT_STRING:return"string";default:return null}}function Tx(r,e,t){const n=r[e];return n&&n.func?n.func.name:t}function ng(r,e,t){const n=r[e];return n&&n.type?Gy(n.type):t}function rg(r,e,t){const n=r[e];return n&&n.list&&n.list.type?n.list.type.map(i=>Gy(i)):t}function jE(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ig(r,e,t){const n=r[e];return n&&n.shape?jE(n.shape):t}function sg(r,e,t){const n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function og(r,e,t,n=!1){const i=r[e];return i&&i.list&&i.list.s?i.list.s.map(s=>HE(s,n)):t}function ag(r,e,t){const n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(i=>jE(i)):t}function lg(r,e,t){const n=r[e];return n&&n.list&&n.list.b?n.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J8{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,s)=>(i[s]=this.getAttr(s),i),{}))}getInput(e){return rr(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return rr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return tg(this.node.rawAttrs,e,t);if(n.s!=null)return Jm(this.node.rawAttrs,e,t);if(n.b!=null)return eg(this.node.rawAttrs,e,t);if(n.shape!=null)return ig(this.node.rawAttrs,e,t);if(n.type!=null)return ng(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return sg(this.node.rawAttrs,e,t);if(n.list.s!=null)return og(this.node.rawAttrs,e,t);if(n.list.shape!=null)return ag(this.node.rawAttrs,e,t);if(n.list.b!=null)return lg(this.node.rawAttrs,e,t);if(n.list.type!=null)return rg(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:R2,abs:$r,acos:oB,acosh:lB,add:Ye,addN:cB,all:fB,any:pB,argMax:j2,argMin:yB,asin:bB,asinh:vB,atan:SB,atan2:EB,atanh:AB,avgPool:q2,avgPool3d:DB,basicLSTMCell:VB,batchNorm:Wf,batchNorm2d:qB,batchNorm3d:XB,batchNorm4d:ZB,batchToSpaceND:K2,bincount:X2,booleanMaskAsync:DG,broadcastArgs:eU,broadcastTo:Ju,buffer:rn,cast:ln,ceil:rU,clipByValue:Y2,clone:bo,complex:Eo,concat:kn,concat1d:oU,concat2d:lU,concat3d:cU,concat4d:fU,conv1d:mU,conv2d:Gf,conv2dTranspose:_U,conv3d:xU,conv3dTranspose:TU,cos:MU,cosh:IU,cosineWindow:Dy,cumprod:kU,cumsum:RU,denseBincount:LU,depthToSpace:OU,depthwiseConv2d:My,diag:zU,dilation2d:UU,div:bt,divNoNan:qU,dot:XU,dropout:YG,einsum:ZU,elu:J2,enclosingPowerOfTwo:IE,equal:Q2,erf:e4,euclideanNorm:h4,exp:Os,expandDims:ci,expm1:m4,eye:nE,fft:Py,fill:Oc,floor:rE,floorDiv:H2,fused:h6,gather:iE,gatherND:qG,greater:Xf,greaterEqual:sE,ifft:hf,imag:Yf,image:xo,inTopKAsync:QG,irfft:wE,isFinite:T4,isInf:M4,isNaN:I4,leakyRelu:oE,less:N4,lessEqual:Iy,linalg:UH,linspace:P4,localResponseNormalization:D4,log:Ec,log1p:aE,logSigmoid:V4,logSoftmax:H4,logSumExp:uE,logicalAnd:uf,logicalNot:cE,logicalOr:hE,logicalXor:Z4,losses:VH,lowerBound:J4,matMul:Wt,max:Cl,maxPool:fE,maxPool3d:nV,maxPoolWithArgmax:iV,maximum:dE,mean:cf,meshgrid:aV,min:Vm,minimum:ky,mirrorPad:pE,mod:hV,moments:dV,movingAverage:$G,mul:Ce,multiRNNCell:mV,multinomial:yV,neg:Cs,norm:Kf,notEqual:mE,oneHot:xV,ones:oa,onesLike:wV,op:K,outerProduct:TV,pad:Ao,pad1d:AV,pad2d:CV,pad3d:NV,pad4d:PV,pool:$V,pow:Tc,prelu:yE,print:G2,prod:UV,raggedGather:WV,raggedRange:HV,raggedTensorToTensor:qV,rand:XV,randomGamma:mW,randomNormal:_E,randomStandardNormal:_W,randomUniform:bE,range:Mc,real:Ac,reciprocal:wW,relu:Zf,relu6:xE,reshape:ye,reverse:Ca,reverse1d:AW,reverse2d:CW,reverse3d:NW,reverse4d:PW,rfft:Ly,round:vE,rsqrt:OW,scalar:yt,scatterND:VG,searchSorted:Cy,selu:$W,separableConv2d:BW,setdiff1dAsync:VW,sigmoid:Is,sign:GW,signal:BH,sin:jW,sinh:KW,slice:_t,slice1d:YW,slice2d:QW,slice3d:eG,slice4d:nG,softmax:iG,softplus:lE,spaceToBatchND:gE,sparse:WH,sparseToDense:HG,spectral:zH,split:Ic,sqrt:Ds,square:xi,squaredDifference:SE,squeeze:Vt,stack:$s,step:TE,stridedSlice:mG,string:GH,sub:ft,sum:sn,tan:yG,tanh:Um,tensor:ts,tensor1d:ir,tensor2d:vi,tensor3d:EE,tensor4d:_G,tensor5d:bG,tensor6d:xG,tile:ec,topk:wG,transpose:Ym,truncatedNormal:TG,unique:MG,unsortedSegmentSum:IG,unstack:Fa,upperBound:kG,variable:NG,where:Yl,whereAsync:ME,zeros:Mo,zerosLike:Gr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ej=(r,e,t,n=zn)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(E("a",r,e,t),E("b",r,e,t))];case"AddN":return[n.addN(E("tensors",r,e,t))];case"FloorMod":case"Mod":return[n.mod(E("a",r,e,t),E("b",r,e,t))];case"Mul":return[n.mul(E("a",r,e,t),E("b",r,e,t))];case"RealDiv":case"Div":return[n.div(E("a",r,e,t),E("b",r,e,t))];case"DivNoNan":return[n.divNoNan(E("a",r,e,t),E("b",r,e,t))];case"FloorDiv":return[n.floorDiv(E("a",r,e,t),E("b",r,e,t))];case"Sub":return[n.sub(E("a",r,e,t),E("b",r,e,t))];case"Minimum":return[n.minimum(E("a",r,e,t),E("b",r,e,t))];case"Maximum":return[n.maximum(E("a",r,e,t),E("b",r,e,t))];case"Pow":return[n.pow(E("a",r,e,t),E("b",r,e,t))];case"SquaredDifference":return[n.squaredDifference(E("a",r,e,t),E("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tj=(r,e,t,n=zn)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(E("x",r,e,t))];case"Acos":return[n.acos(E("x",r,e,t))];case"Acosh":return[n.acosh(E("x",r,e,t))];case"Asin":return[n.asin(E("x",r,e,t))];case"Asinh":return[n.asinh(E("x",r,e,t))];case"Atan":return[n.atan(E("x",r,e,t))];case"Atan2":return[n.atan2(E("x",r,e,t),E("y",r,e,t))];case"Atanh":return[n.atanh(E("x",r,e,t))];case"Ceil":return[n.ceil(E("x",r,e,t))];case"Complex":return[n.complex(E("real",r,e,t),E("imag",r,e,t))];case"Cos":return[n.cos(E("x",r,e,t))];case"Cosh":return[n.cosh(E("x",r,e,t))];case"Elu":return[n.elu(E("x",r,e,t))];case"Erf":return[n.erf(E("x",r,e,t))];case"Exp":return[n.exp(E("x",r,e,t))];case"Expm1":return[n.expm1(E("x",r,e,t))];case"Floor":return[n.floor(E("x",r,e,t))];case"Log":return[n.log(E("x",r,e,t))];case"Log1p":return[n.log1p(E("x",r,e,t))];case"Imag":return[n.imag(E("x",r,e,t))];case"Neg":return[n.neg(E("x",r,e,t))];case"Reciprocal":return[n.reciprocal(E("x",r,e,t))];case"Real":return[n.real(E("x",r,e,t))];case"Relu":return[n.relu(E("x",r,e,t))];case"Round":return[n.round(E("x",r,e,t))];case"Selu":return[n.selu(E("x",r,e,t))];case"Sigmoid":return[n.sigmoid(E("x",r,e,t))];case"Sin":return[n.sin(E("x",r,e,t))];case"Sign":return[n.sign(E("x",r,e,t))];case"Sinh":return[n.sinh(E("x",r,e,t))];case"Softplus":return[n.softplus(E("x",r,e,t))];case"Sqrt":return[n.sqrt(E("x",r,e,t))];case"Square":return[n.square(E("x",r,e,t))];case"Tanh":return[n.tanh(E("x",r,e,t))];case"Tan":return[n.tan(E("x",r,e,t))];case"ClipByValue":return[n.clipByValue(E("x",r,e,t),E("clipValueMin",r,e,t),E("clipValueMax",r,e,t))];case"Relu6":return[n.relu6(E("x",r,e,t))];case"Rsqrt":return[n.rsqrt(rr(r.inputNames[0],e,t))];case"Prod":return[n.prod(E("x",r,e,t),E("axes",r,e,t))];case"LeakyRelu":return[n.leakyRelu(E("x",r,e,t),E("alpha",r,e,t))];case"Prelu":return[n.prelu(E("x",r,e,t),E("alpha",r,e,t))];case"IsNan":return[n.isNaN(rr(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){D(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){const i=r[n],s=e[n];D(i<0||s<0||i===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function Ex(r){return!(typeof r=="number"||r.some(e=>e<0))}function Pu(r,e,t){let n=ug(r,t);const i=!Ex(n);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(i&&e.forEach(s=>{n=ug(s.shape,n)}),!Ex(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function ug(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);const t=[];for(let n=0;n<r.length;++n){const i=r[n],s=e[n];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=i>=0?i:s}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nj{constructor(e,t,n,i,s,o,a){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=i,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=yt(0),Zi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ui(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Zi(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,i)=>this.write(n,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return ts([],[0].concat(this.elementShape));const n=this.readMany(e);return ui(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),$s(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ts([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const n=this.readMany(t);return ui(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),kn(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Fa(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const i=e.map(l=>(n+=l,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=n===0?0:t.size/n,o=[];ht(()=>{t=ye(t,[1,n,s]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],h=[1,e[l],s];o[l]=ye(_t(t,c,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Na{constructor(e,t,n,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);ui(t,s.shape,"TensorList shape mismatch: "),Zi(s)}),this.idTensor=yt(0),this.maxNumElements=i,Zi(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Na([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);ui(e,this.elementShape,"TensorList shape mismatch: ");const i=Pu(this.elementShape,this.tensors,e);return ht(()=>{const s=this.tensors.map(o=>ye(o,i));return $s(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=Pu(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,ui(i.shape,e,"TensorList shape mismatch: "),ye(i,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ui(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Zi(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Na([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ui(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Pu(this.elementShape,this.tensors,t);return ye(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ui(this.elementShape,t.shape,"TensorList shape mismatch: "),Zi(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ui(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Pu(this.elementShape,this.tensors,n);return e.length===0?ts([],[0].concat(i)):ht(()=>{const s=e.map(o=>ye(this.tensors[o],i));return $s(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ui(this.elementShape,t,"TensorList shape mismatch: ");const n=Pu(this.elementShape,this.tensors,t);return this.size()===0?ts([],[0].concat(n)):ht(()=>{const i=this.tensors.map(s=>ye(s,n));return kn(i,0)})}}function rj(r,e,t){const n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);const i=r.shape.slice(1);ui(i,e,"TensorList shape mismatch: ");const s=Fa(r);return new Na(s,e,n)}function ij(r,e,t,n){return new Na([],r,e,n)}function sj(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);const i=Math.max(...e);if(n!=null&&n!==-1&&i>=n)throw new Error(`Max index must be < array size (${i}  vs. ${n})`);const s=new Na([],t,r.dtype,n),o=Fa(r,0);return e.forEach((a,l)=>{s.setItem(a,o[l])}),s}function oj(r,e,t){let n=0;const i=e.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);const s=r.shape.slice(1),o=ug(s,t),a=n===0?0:r.size/n,l=ht(()=>{const c=[];r=ye(r,[1,n,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:i[h-1],0],g=[1,e[h],a];c[h]=ye(_t(r,d,g),o)}return r.dispose(),c}),u=new Na([],t,r.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aj=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{const n=E("thenBranch",r,e,t),i=E("elseBranch",r,e,t),s=E("cond",r,e,t),o=E("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=E("body",r,e,t),i=E("cond",r,e,t),s=E("args",r,e,t),o=await t.functionMap[i].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){const c=u;u=await t.functionMap[n].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(d=>d.id);c.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await t.functionMap[i].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return u}case"LoopCond":{const n=E("pred",r,e,t);return[_s(n)]}case"Switch":{const n=E("pred",r,e,t);let i=E("data",r,e,t);return i.kept||(i=_s(i)),(await n.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const n=r.inputNames.find(i=>rr(i,e,t)!==void 0);if(n){const i=rr(n,e,t);return[_s(i)]}return}case"Enter":{const n=E("frameName",r,e,t),i=E("tensor",r,e,t);return t.enterFrame(n),[_s(i)]}case"Exit":{const n=E("tensor",r,e,t);return t.exitFrame(),[_s(n)]}case"NextIteration":{const n=E("tensor",r,e,t);return t.nextIteration(),[_s(n)]}case"TensorArrayV3":{const n=E("size",r,e,t),i=E("dtype",r,e,t),s=E("elementShape",r,e,t),o=E("dynamicSize",r,e,t),a=E("clearAfterRead",r,e,t),l=E("identicalElementShapes",r,e,t),u=E("name",r,e,t),c=new nj(u,i,n,s,l,o,a);return t.addTensorArray(c),[c.idTensor,yt(1)]}case"TensorArrayWriteV3":{const n=E("tensorArrayId",r,e,t),i=E("index",r,e,t),s=E("tensor",r,e,t),o=t.getTensorArray(n.id);return o.write(i,s),[o.idTensor]}case"TensorArrayReadV3":{const n=E("tensorArrayId",r,e,t),i=E("index",r,e,t);return[t.getTensorArray(n.id).read(i)]}case"TensorArrayGatherV3":{const n=E("tensorArrayId",r,e,t),i=E("indices",r,e,t),s=E("dtype",r,e,t);return[t.getTensorArray(n.id).gather(i,s)]}case"TensorArrayScatterV3":{const n=E("tensorArrayId",r,e,t),i=E("indices",r,e,t),s=E("tensor",r,e,t),o=t.getTensorArray(n.id);return o.scatter(i,s),[o.idTensor]}case"TensorArrayConcatV3":{const n=E("tensorArrayId",r,e,t),i=t.getTensorArray(n.id),s=E("dtype",r,e,t);return[i.concat(s)]}case"TensorArraySplitV3":{const n=E("tensorArrayId",r,e,t),i=E("tensor",r,e,t),s=E("lengths",r,e,t),o=t.getTensorArray(n.id);return o.split(s,i),[o.idTensor]}case"TensorArraySizeV3":{const n=E("tensorArrayId",r,e,t),i=t.getTensorArray(n.id);return[yt(i.size(),"int32")]}case"TensorArrayCloseV3":{const n=E("tensorArrayId",r,e,t),i=t.getTensorArray(n.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const n=E("tensorListId",r,e,t),i=E("index",r,e,t),s=E("tensor",r,e,t),o=t.getTensorList(n.id);return o.setItem(i,s),[o.idTensor]}case"TensorListGetItem":{const n=E("tensorListId",r,e,t),i=E("index",r,e,t),s=E("elementShape",r,e,t),o=E("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(i,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=E("indices",r,e,t),i=E("tensor",r,e,t),s=E("elementShape",r,e,t),o=E("numElements",r,e,t),a=sj(i,n,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=E("elementShape",r,e,t),i=E("elementDType",r,e,t);let s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=E(s,r,e,t),a=r.op==="TensorListReserve"?-1:o,l=ij(n,i,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const n=E("tensorListId",r,e,t),i=E("indices",r,e,t),s=E("elementShape",r,e,t),o=E("elementDType",r,e,t);return[t.getTensorList(n.id).gather(i,o,s)]}case"TensorListStack":{const n=E("tensorListId",r,e,t),i=E("elementShape",r,e,t),s=E("elementDType",r,e,t),o=E("numElements",r,e,t);return[t.getTensorList(n.id).stack(i,s,o)]}case"TensorListFromTensor":{const n=E("tensor",r,e,t),i=E("elementShape",r,e,t),s=E("elementDType",r,e,t),o=rj(n,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=E("tensorListId",r,e,t),i=t.getTensorList(n.id),s=E("dtype",r,e,t),o=E("elementShape",r,e,t);return[i.concat(s,o)]}case"TensorListPushBack":{const n=E("tensorListId",r,e,t),i=E("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{const n=E("tensorListId",r,e,t),i=E("elementShape",r,e,t),s=E("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(i,s)]}case"TensorListSplit":{const n=E("tensor",r,e,t),i=E("elementShape",r,e,t),s=E("lengths",r,e,t),o=oj(n,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const n=E("tensorListId",r,e,t),i=t.getTensorList(n.id);return[yt(i.size(),"int32")]}case"TensorListResize":{const n=E("tensorListId",r,e,t),i=E("size",r,e,t),o=t.getTensorList(n.id).resize(i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(r,e,t){const[n,i]=E("fusedOps",r,e,t),s=n==="biasadd",o=!s,a=i==="prelu",l=n==="fusedbatchnorm",u=E("numArgs",r,e,t);if(s){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=E("strides",r,e,t),h=Fh(r,e,t),f=E("dataFormat",r,e,t).toUpperCase(),d=E("dilations",r,e,t);let[g,p]=E("args",r,e,t);o&&(p=g,g=void 0);const m=E("leakyreluAlpha",r,e,t);return{stride:c,pad:h,dataFormat:f,dilations:d,biasArg:g,preluArg:p,activationFunc:i,leakyreluAlpha:m}}const lj=(r,e,t,n=zn)=>{switch(r.op){case"Conv1D":{const i=E("stride",r,e,t),s=E("pad",r,e,t),o=E("dataFormat",r,e,t).toUpperCase(),a=E("dilation",r,e,t);return[n.conv1d(E("x",r,e,t),E("filter",r,e,t),i,s,o,a)]}case"Conv2D":{const i=E("strides",r,e,t),s=Fh(r,e,t),o=E("dataFormat",r,e,t).toUpperCase(),a=E("dilations",r,e,t);return[n.conv2d(E("x",r,e,t),E("filter",r,e,t),[i[1],i[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Mx(r,e,t);return[n.fused.conv2d({x:E("x",r,e,t),filter:E("filter",r,e,t),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Mx(r,e,t);return[n.fused.depthwiseConv2d({x:E("x",r,e,t),filter:E("filter",r,e,t),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=E("outputShape",r,e,t),s=E("strides",r,e,t),o=Fh(r,e,t);return[n.conv2dTranspose(E("x",r,e,t),E("filter",r,e,t),i,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=E("strides",r,e,t),s=Fh(r,e,t),o=E("dilations",r,e,t),a=E("dataFormat",r,e,t).toUpperCase();return[n.depthwiseConv2d(E("input",r,e,t),E("filter",r,e,t),[i[1],i[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("dataFormat",r,e,t).toUpperCase(),a=E("dilations",r,e,t);return[n.conv3d(E("x",r,e,t),E("filter",r,e,t),[i[1],i[2],i[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("kernelSize",r,e,t);return[n.avgPool(E("x",r,e,t),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPool":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("kernelSize",r,e,t);return[n.maxPool(E("x",r,e,t),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("kernelSize",r,e,t),a=E("includeBatchInIndex",r,e,t),{result:l,indexes:u}=n.maxPoolWithArgmax(E("x",r,e,t),[o[1],o[2]],[i[1],i[2]],s,a);return[l,u]}case"AvgPool3D":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("kernelSize",r,e,t);return[n.avgPool3d(E("x",r,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("kernelSize",r,e,t);return[n.maxPool3d(E("x",r,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{const i=E("strides",r,e,t),s=E("pad",r,e,t),o=E("dilations",r,e,t),a=i[1],l=i[2],u=o[1],c=o[2];return[n.dilation2d(E("x",r,e,t),E("filter",r,e,t),[a,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uj=(r,e,t,n=zn)=>{switch(r.op){case"Fill":{const i=E("shape",r,e,t),s=E("dtype",r,e,t),o=E("value",r,e,t);return[n.fill(i,o,s)]}case"LinSpace":{const i=E("start",r,e,t),s=E("stop",r,e,t),o=E("num",r,e,t);return[n.linspace(i,s,o)]}case"Multinomial":{const i=E("logits",r,e,t),s=E("numSamples",r,e,t),o=E("seed",r,e,t);return[n.multinomial(i,s,o)]}case"OneHot":{const i=E("indices",r,e,t),s=E("depth",r,e,t),o=E("onValue",r,e,t),a=E("offValue",r,e,t),l=E("dtype",r,e,t);return[n.oneHot(i,s,o,a,l)]}case"Ones":return[n.ones(E("shape",r,e,t),E("dtype",r,e,t))];case"OnesLike":return[n.onesLike(E("x",r,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(E("shape",r,e,t),E("dtype",r,e,t),E("seed",r,e,t))];case"RandomUniform":return[n.randomUniform(E("shape",r,e,t),E("minval",r,e,t),E("maxval",r,e,t),E("dtype",r,e,t))];case"Range":{const i=E("start",r,e,t),s=E("stop",r,e,t),o=E("step",r,e,t);return[n.range(i,s,o,E("dtype",r,e,t))]}case"TruncatedNormal":{const i=E("shape",r,e,t),s=E("mean",r,e,t),o=E("stdDev",r,e,t),a=E("seed",r,e,t);return[n.truncatedNormal(i,s,o,E("dtype",r,e,t),a)]}case"Zeros":return[n.zeros(E("shape",r,e,t),E("dtype",r,e,t))];case"ZerosLike":return[n.zerosLike(E("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yp(r,e,t){const n=E("boxes",r,e,t),i=E("scores",r,e,t),s=E("maxOutputSize",r,e,t),o=E("iouThreshold",r,e,t),a=E("scoreThreshold",r,e,t),l=E("softNmsSigma",r,e,t);return{boxes:n,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const cj=async(r,e,t,n,i=zn)=>{switch(r.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=yp(r,e,t),h=await i.image.nonMaxSuppressionWithScoreAsync(s,o,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=yp(r,e,t),c=E("padToMaxOutputSize",r,e,t),h=await i.image.nonMaxSuppressionPaddedAsync(s,o,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=yp(r,e,t);return[await i.image.nonMaxSuppressionAsync(s,o,a,l,u)]}case"Where":{const s=i.cast(E("condition",r,e,t),"bool"),o=[await i.whereAsync(s)];return s.dispose(),o}case"ListDiff":return i.setdiff1dAsync(E("x",r,e,t),E("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hj=(r,e,t,n=zn)=>{switch(r.op){case"LowerBound":{const i=E("sortedSequence",r,e,t),s=E("values",r,e,t);return[n.lowerBound(i,s)]}case"TopKV2":{const i=E("x",r,e,t),s=E("k",r,e,t),o=E("sorted",r,e,t),a=n.topk(i,s,o);return[a.values,a.indices]}case"UpperBound":{const i=E("sortedSequence",r,e,t),s=E("values",r,e,t);return[n.upperBound(i,s)]}case"Unique":{const i=E("x",r,e,t),s=n.unique(i);return[s.values,s.indices]}case"UniqueV2":{const i=E("x",r,e,t),s=E("axis",r,e,t),o=n.unique(i,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fj=(r,e,t,n=zn)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":const i=E("default",r,e,t);return[rr(r.name,e,t)||i];case"Placeholder":return[rr(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=E("x",r,e,t);return[_s(c)]}case"IdentityN":return E("x",r,e,t).map(c=>_s(c));case"Snapshot":const s=E("x",r,e,t);return[_s(s)];case"Shape":return[n.tensor1d(E("x",r,e,t).shape,"int32")];case"ShapeN":return E("x",r,e,t).map(c=>n.tensor1d(c.shape));case"Size":return[n.scalar(E("x",r,e,t).size,"int32")];case"Rank":return[n.scalar(E("x",r,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const o=E("x",r,e,t),a=E("data",r,e,t),l=E("message",r,e,t),u=E("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dj{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=yt(0),this.tensorMap=new Map,Zi(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return yt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),ht(()=>{const i=Fa(t),s=n.length,o=i.length;D(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){const l=n[a],u=i[a];Zi(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return ht(()=>{const i=[];for(let s=0;s<n.length;s++){const o=n[s],a=this.findWithDefault(o,t);i.push(a)}return $s(i)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pj=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{const i=n.getHashTableHandleByName(r.name);if(i!=null)return[i];{const s=E("keyDType",r,e,t),o=E("valueDType",r,e,t),a=new dj(s,o);return n.addHashTable(r.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=E("tableHandle",r,e,t,n),s=E("keys",r,e,t),o=E("values",r,e,t);return[await n.getHashTableById(i.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=E("tableHandle",r,e,t,n),s=E("keys",r,e,t),o=E("defaultValue",r,e,t);return[await n.getHashTableById(i.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=E("tableHandle",r,e,t,n);return[n.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mj=(r,e,t,n=zn)=>{switch(r.op){case"ResizeBilinear":{const i=E("images",r,e,t),s=E("size",r,e,t),o=E("alignCorners",r,e,t),a=E("halfPixelCenters",r,e,t);return[n.image.resizeBilinear(i,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const i=E("images",r,e,t),s=E("size",r,e,t),o=E("alignCorners",r,e,t),a=E("halfPixelCenters",r,e,t);return[n.image.resizeNearestNeighbor(i,[s[0],s[1]],o,a)]}case"CropAndResize":{const i=E("image",r,e,t),s=E("boxes",r,e,t),o=E("boxInd",r,e,t),a=E("cropSize",r,e,t),l=E("method",r,e,t),u=E("extrapolationValue",r,e,t);return[n.image.cropAndResize(i,s,o,a,l,u)]}case"ImageProjectiveTransformV3":{const i=E("images",r,e,t),s=E("transforms",r,e,t),o=E("outputShape",r,e,t),a=E("fillValue",r,e,t),l=E("interpolation",r,e,t),u=E("fillMode",r,e,t);return[n.image.transform(i,s,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gj=(r,e,t,n=zn)=>{switch(r.op){case"Equal":return[n.equal(E("a",r,e,t),E("b",r,e,t))];case"NotEqual":return[n.notEqual(E("a",r,e,t),E("b",r,e,t))];case"Greater":return[n.greater(E("a",r,e,t),E("b",r,e,t))];case"GreaterEqual":return[n.greaterEqual(E("a",r,e,t),E("b",r,e,t))];case"Less":return[n.less(E("a",r,e,t),E("b",r,e,t))];case"LessEqual":return[n.lessEqual(E("a",r,e,t),E("b",r,e,t))];case"LogicalAnd":return[n.logicalAnd(E("a",r,e,t),E("b",r,e,t))];case"LogicalNot":return[n.logicalNot(E("a",r,e,t))];case"LogicalOr":return[n.logicalOr(E("a",r,e,t),E("b",r,e,t))];case"Select":case"SelectV2":return[n.where(E("condition",r,e,t),E("a",r,e,t),E("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yj=(r,e,t,n=zn)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(E("a",r,e,t),E("b",r,e,t),E("transposeA",r,e,t),E("transposeB",r,e,t))];case"Einsum":return[n.einsum(E("equation",r,e,t),...E("tensors",r,e,t))];case"Transpose":return[n.transpose(E("x",r,e,t),E("perm",r,e,t))];case"_FusedMatMul":const[i,s]=E("fusedOps",r,e,t),o=i==="biasadd",a=s==="prelu",l=E("numArgs",r,e,t),u=E("leakyreluAlpha",r,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=E("args",r,e,t);return[n.fused.matMul({a:E("a",r,e,t),b:E("b",r,e,t),transposeA:E("transposeA",r,e,t),transposeB:E("transposeB",r,e,t),bias:c,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _j=(r,e,t,n=zn)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(E("x",r,e,t),E("axis",r,e,t),E("keepDims",r,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(E("x",r,e,t),E("mean",r,e,t),E("variance",r,e,t),E("offset",r,e,t),E("scale",r,e,t),E("epsilon",r,e,t))];case"FusedBatchNormV3":return[n.batchNorm(E("x",r,e,t),E("mean",r,e,t),E("variance",r,e,t),E("offset",r,e,t),E("scale",r,e,t),E("epsilon",r,e,t))];case"LRN":return[n.localResponseNormalization(E("x",r,e,t),E("radius",r,e,t),E("bias",r,e,t),E("alpha",r,e,t),E("beta",r,e,t))];case"Softmax":return[n.softmax(E("x",r,e,t))];case"LogSoftmax":return[n.logSoftmax(E("x",r,e,t))];case"SparseToDense":return[n.sparseToDense(E("sparseIndices",r,e,t),E("outputShape",r,e,t),E("sparseValues",r,e,t),E("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bj=(r,e,t,n=zn)=>{switch(r.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:s}=n.raggedGather(E("paramsNestedSplits",r,e,t),E("paramsDenseValues",r,e,t),E("indices",r,e,t),E("outputRaggedRank",r,e,t));return i.concat(s)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:s}=n.raggedRange(E("starts",r,e,t),E("limits",r,e,t),E("splits",r,e,t));return[i,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(E("shape",r,e,t),E("values",r,e,t),E("defaultValue",r,e,t),E("rowPartitionTensors",r,e,t),E("rowPartitionTypes",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xj=(r,e,t,n=zn)=>{switch(r.op){case"Max":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.max(E("x",r,e,t),a,l)]}case"Mean":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.mean(E("x",r,e,t),a,l)]}case"Min":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.min(E("x",r,e,t),a,l)]}case"Sum":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.sum(E("x",r,e,t),a,l)]}case"All":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.all(E("x",r,e,t),a,l)]}case"Any":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.any(E("x",r,e,t),a,l)]}case"ArgMax":{const a=E("axis",r,e,t);return[n.argMax(E("x",r,e,t),a)]}case"ArgMin":{const a=E("axis",r,e,t);return[n.argMin(E("x",r,e,t),a)]}case"Prod":{const a=E("axis",r,e,t),l=E("keepDims",r,e,t);return[n.prod(E("x",r,e,t),a,l)]}case"Cumprod":{const a=E("axis",r,e,t),l=E("exclusive",r,e,t),u=E("reverse",r,e,t);return[n.cumprod(E("x",r,e,t),a,l,u)]}case"Cumsum":{const a=E("axis",r,e,t),l=E("exclusive",r,e,t),u=E("reverse",r,e,t);return[n.cumsum(E("x",r,e,t),a,l,u)]}case"Bincount":const i=E("x",r,e,t),s=E("weights",r,e,t),o=E("size",r,e,t);return[n.bincount(i,s,o)];case"DenseBincount":{const a=E("x",r,e,t),l=E("weights",r,e,t),u=E("size",r,e,t),c=E("binaryOutput",r,e,t);return[n.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vj=(r,e,t,n=zn)=>{switch(r.op){case"ConcatV2":case"Concat":{const i=E("n",r,e,t),s=E("axis",r,e,t);let o=E("tensors",r,e,t);return o=o.slice(0,i),[n.concat(o,s)]}case"Gather":{const i=E("x",r,e,t),s=E("indices",r,e,t);return[n.gather(i,n.cast(s,"int32"),0)]}case"GatherV2":{const i=E("axis",r,e,t),s=E("batchDims",r,e,t),o=E("x",r,e,t),a=E("indices",r,e,t);return[n.gather(o,n.cast(a,"int32"),i,s)]}case"Reverse":{const i=E("dims",r,e,t),s=[];for(let a=0;a<i.length;a++)i[a]&&s.push(a);const o=E("x",r,e,t);return[n.reverse(o,s)]}case"ReverseV2":{const i=E("axis",r,e,t),s=E("x",r,e,t);return[n.reverse(s,i)]}case"Slice":{const i=E("begin",r,e,t),s=E("size",r,e,t);return[n.slice(E("x",r,e,t),i,s)]}case"StridedSlice":{const i=E("begin",r,e,t),s=E("end",r,e,t),o=E("strides",r,e,t),a=E("beginMask",r,e,t),l=E("endMask",r,e,t),u=E("ellipsisMask",r,e,t),c=E("newAxisMask",r,e,t),h=E("shrinkAxisMask",r,e,t),f=E("x",r,e,t);return[n.stridedSlice(f,i,s,o,a,l,u,c,h)]}case"Pack":return ht(()=>{const i=E("axis",r,e,t),s=E("tensors",r,e,t),o=s[0].shape,a=n.squeeze(s[0]).shape,l=s.map(u=>{const c=br(u.shape,o);if(!c&&!br(n.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:n.reshape(u,o)});return[n.stack(l,i)]});case"Unpack":{const i=E("axis",r,e,t),s=E("tensor",r,e,t);return n.unstack(s,i)}case"Tile":{const i=E("reps",r,e,t);return[n.tile(E("x",r,e,t),i)]}case"Split":case"SplitV":{const i=E("axis",r,e,t),s=E("numOrSizeSplits",r,e,t),o=E("x",r,e,t);return n.split(o,s,i)}case"ScatterNd":{const i=E("indices",r,e,t),s=E("values",r,e,t),o=E("shape",r,e,t);return[n.scatterND(i,s,o)]}case"GatherNd":{const i=E("x",r,e,t),s=E("indices",r,e,t);return[n.gatherND(i,s)]}case"SparseToDense":{const i=E("sparseIndices",r,e,t),s=E("outputShape",r,e,t),o=E("sparseValues",r,e,t),a=E("defaultValue",r,e,t);return[n.sparseToDense(i,o,s,o.dtype===a.dtype?a:n.cast(a,o.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wj=(r,e,t,n=zn)=>{switch(r.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=n.sparse.sparseFillEmptyRows(E("indices",r,e,t),E("values",r,e,t),E("denseShape",r,e,t),E("defaultValue",r,e,t));return[i,s,o,a]}case"SparseReshape":{const{outputIndices:i,outputShape:s}=n.sparse.sparseReshape(E("inputIndices",r,e,t),E("inputShape",r,e,t),E("newShape",r,e,t));return[i,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(E("data",r,e,t),E("indices",r,e,t),E("segmentIds",r,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(E("data",r,e,t),E("indices",r,e,t),E("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sj=(r,e,t,n=zn)=>{switch(r.op){case"FFT":return[n.fft(E("x",r,e,t))];case"IFFT":return[n.ifft(E("x",r,e,t))];case"RFFT":return[n.rfft(E("x",r,e,t))];case"IRFFT":return[n.irfft(E("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tj=(r,e,t,n=zn)=>{switch(r.op){case"StringNGrams":{const{nGrams:i,nGramsSplits:s}=n.string.stringNGrams(E("data",r,e,t),E("dataSplits",r,e,t),E("separator",r,e,t),E("nGramWidths",r,e,t),E("leftPad",r,e,t),E("rightPad",r,e,t),E("padWidth",r,e,t),E("preserveShortSequences",r,e,t));return[i,s]}case"StringSplit":{const{indices:i,values:s,shape:o}=n.string.stringSplit(E("input",r,e,t),E("delimiter",r,e,t),E("skipEmpty",r,e,t));return[i,s,o]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(E("input",r,e,t),E("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ej=(r,e,t,n=zn)=>{switch(r.op){case"Cast":return[n.cast(E("x",r,e,t),E("dtype",r,e,t))];case"ExpandDims":{const i=E("axis",r,e,t);return[n.expandDims(E("x",r,e,t),i)]}case"Squeeze":{const i=E("axis",r,e,t);return[n.squeeze(E("x",r,e,t),i)]}case"Reshape":return[n.reshape(E("x",r,e,t),E("shape",r,e,t))];case"MirrorPad":return[n.mirrorPad(E("x",r,e,t),E("padding",r,e,t),E("mode",r,e,t))];case"PadV2":case"Pad":return[n.pad(E("x",r,e,t),E("padding",r,e,t),E("constantValue",r,e,t))];case"SpaceToBatchND":{const i=E("blockShape",r,e,t),s=E("paddings",r,e,t);return[n.spaceToBatchND(E("x",r,e,t),i,s)]}case"BatchToSpaceND":{const i=E("blockShape",r,e,t),s=E("crops",r,e,t);return[n.batchToSpaceND(E("x",r,e,t),i,s)]}case"DepthToSpace":{const i=E("blockSize",r,e,t),s=E("dataFormat",r,e,t).toUpperCase();return[n.depthToSpace(E("x",r,e,t),i,s)]}case"BroadcastTo":return[n.broadcastTo(E("x",r,e,t),E("shape",r,e,t))];case"BroadcastArgs":return[n.broadcastArgs(E("s0",r,e,t),E("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(r,e,t,n,i=ht){const s=((o,a,l)=>{switch(o.category){case"arithmetic":return i(()=>ej(o,a,l));case"basic_math":return i(()=>tj(o,a,l));case"control":return aj(o,a,l);case"convolution":return i(()=>lj(o,a,l));case"creation":return i(()=>uj(o,a,l));case"dynamic":return cj(o,a,l);case"evaluation":return i(()=>hj(o,a,l));case"image":return i(()=>mj(o,a,l));case"graph":return i(()=>fj(o,a,l));case"logical":return i(()=>gj(o,a,l));case"matrices":return i(()=>yj(o,a,l));case"normalization":return i(()=>_j(o,a,l));case"ragged":return i(()=>bj(o,a,l));case"reduction":return i(()=>xj(o,a,l));case"slice_join":return i(()=>vj(o,a,l));case"sparse":return i(()=>wj(o,a,l));case"spectral":return i(()=>Sj(o,a,l));case"string":return i(()=>Tj(o,a,l));case"transformation":return i(()=>Ej(o,a,l));case"hash_table":return pj(o,a,l,n);case"custom":const u=GE(o.op);if(u&&u.customExecutor)return u.customExecutor(new J8(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return Ta(s)?s.then(o=>[].concat(o)):[].concat(s)}class Ix{constructor(e={},t={},n={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cx(r,e,t,n){const i=new Set,s=[];let o=null,a=null;const l=new Set,u=Object.keys(r).map(f=>Tr(f)[0]);let c=[];n!=null&&(c=n.map(f=>Tr(f.name)[0]));const h=[...e];for(;h.length>0;){const f=h.pop();if((qE(f)||kj(f)||Nj(f))&&o==null&&(o=f,a=o.children.map(d=>d.name).filter(d=>i.has(d))),i.add(f.name),t[f.name]==null&&u.indexOf(f.name)===-1&&c.indexOf(f.name)===-1){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),h.push(d))})}}return{inputs:r,outputs:e,usedNodes:i,missingInputs:s,dynamicNode:o,syncInputs:a}}function Mj(r,e,t){const{usedNodes:n,inputs:i}=t,s=[],o=Object.keys(i).map(c=>Tr(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;o.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});const l=new Set,u=[];for(;s.length>0;){const c=s.pop();l.add(c.name),e[c.name]||u.push(c),c.children.forEach(h=>{!l.has(h.name)&&n.has(h.name)&&h.inputs.every(f=>l.has(f.name))&&s.push(h)})}return u}const Aj=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Ij=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Cj=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function qE(r){return Aj.indexOf(r.op)>=0}function kj(r){return Ij.indexOf(r.op)>=0}function Nj(r){return Cj.indexOf(r.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pf{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new pf(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(s=>s.name).sort(),i=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const n=Cx(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:o}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const a=t.map(u=>u.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return Mj(this.graph,this.weightMap,n)}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Zi(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=n.map(h=>this.graph.nodes[Tr(h)[0]]),s=t.map(h=>Tr(h)[0]);let o=s.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const a=this.getCompilationKey(i,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(e,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=it().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const u={},c={};return ht(()=>{const h=new Ix(this.weightMap,u,c,this.functionExecutorMap),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(p=>{const[m,_]=Tr(p),v=[];v[_]=e[p],f[m]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(v))});const d=this.getFrozenTensorIds(f),g={};for(let p=0;p<l.length;p++){const m=l[p];if(!f[m.name]){const _=Ax(m,f,h,this._resourceManager);if(Ta(_))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);f[m.name]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[m.name]=this.cloneTensorList(_)),this.checkTensorForDisposal(m.name,m,f,h,d,s,g)}}return this.parent==null&&h.dispose(d),t.map(p=>rr(p,f,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,n,i,s,o,a){t.category==="control"||o.indexOf(e)!==-1||(n[e].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const u=d8(l.name,n,i);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,i={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=it().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new Ix(this.weightMap,i,s,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,n),l=t.map(f=>rr(f,a,o)),u=l.map(f=>f.id),c=Object.keys(e).map(f=>e[f].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,n){const i=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(i,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,i){const s=Object.keys(e),o=s.map(b=>this.graph.nodes[Tr(b)[0]]),a=n.map(b=>Tr(b)[0]);let l=a.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:f}=Cx(e,l,this.weightMap,this._initNodes),d=[...o,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[x,T]=Tr(b),I=[];I[T]=e[b],g[x]=I});const p={},m=this.getFrozenTensorIds(g),_={};for(;d.length>0;){const b=this.processStack(o,d,t,g,_,m,a,p,u);await Promise.all(b)}h==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=l.filter(b=>!qE(b)&&!rr(b.name,g,t)).map(b=>b.name);if(v.length>0){let b="";throw h!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${b}`)}return g}processStack(e,t,n,i,s,o,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();n.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&E("isConstant",h.node,i,n)&&([f]=ys(h.node.name,n)),i[h.node.name]==null){const d=Ax(h.node,i,n,this._resourceManager);f||([f]=ys(h.node.name,n));const g=n.currentContext;Ta(d)?c.push(d.then(p=>(i[f]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(p)),n.currentContext=g,this.checkTensorForDisposal(f,h.node,i,n,o,a,l),this.processChildNodes(h.node,t,n,i,s,u),p))):(i[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,i,n,o,a,l),this.processChildNodes(h.node,t,n,i,s,u))}else this.processChildNodes(h.node,t,n,i,s,u)}return c}processChildNodes(e,t,n,i,s,o){e.children.forEach(a=>{const[l]=ys(a.name,n);s[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!rr(u,i,n))&&(s[l]=!0,t.push({contexts:n.currentContext,node:a})):a.inputNames.every(u=>!!rr(u,i,n))&&(s[l]=!0,t.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[i]=Tr(t),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,a=o.length===n.shape.length&&n.shape.every((l,u)=>o[u]===-1||o[u]===l);D(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&D(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const i={};for(const s in e){const o=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[s];o!=null?i[o.name]=e[s]:i[s]=e[s]}return i}checkInputs(e){const t=Object.keys(e).filter(n=>{const[i]=Tr(n);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,i;const s=(i=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||i===void 0?void 0:i[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{const[n]=Tr(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}}class Rj{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pj="?tfjs-format=file",Lj="model.json";class Dj{constructor(e,t={},n=zE){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Rj}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ta(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new pf(Sx.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=Sx.Instance.transformGraph(e.modelInitializer);this.initializer=new pf(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof dn?[e]:e,n={};return t.forEach((i,s)=>n[this.structuredOutputKeys[s]]=i),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof dn)&&!Array.isArray(e)){const s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(const o in s){const a=s[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((s,o)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||u===void 0?void 0:u.resourceId;return c!=null?s[o]=this.resourceIdToCapturedInput[c]:s[o]=e[i++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let i=0;i<n.length;i++){const s=n[i],o=t[s];this.resourceIdToCapturedInput[o.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&zt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Zl(r,e={},t=zE){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof r=="string"&&(r=Oj(r));const n=new Dj(r,e,t);return await n.load(),n}function Oj(r){return r.endsWith("/")||(r=r+"/"),`${r}${Lj}${Pj}`}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var KE=function(r,e){return(KE=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n}||function(t,n){for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])})(r,e)};function XE(r,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=r}KE(r,e),r.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Ht=function(){return(Ht=Object.assign||function(r){for(var e,t=1,n=arguments.length;t<n;t++)for(var i in e=arguments[t])Object.prototype.hasOwnProperty.call(e,i)&&(r[i]=e[i]);return r}).apply(this,arguments)};function kt(r,e,t,n){return new(t||(t=Promise))(function(i,s){function o(u){try{l(n.next(u))}catch(c){s(c)}}function a(u){try{l(n.throw(u))}catch(c){s(c)}}function l(u){var c;u.done?i(u.value):(c=u.value,c instanceof t?c:new t(function(h){h(c)})).then(o,a)}l((n=n.apply(r,e||[])).next())})}function Nt(r,e){var t,n,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(u){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,n&&(i=2&c[0]?n.return:c[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,c[1])).done)return i;switch(n=0,i&&(c=[2&c[0],i.value]),c[0]){case 0:case 1:i=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,n=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(i=o.trys,!((i=i.length>0&&i[i.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){o.label=c[1];break}if(c[0]===6&&o.label<i[1]){o.label=i[1],i=c;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(c);break}i[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(r,o)}catch(h){c=[6,h],n=0}finally{t=i=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}function aa(r,e,t){if(t||arguments.length===2)for(var n,i=0,s=e.length;i<s;i++)!n&&i in e||(n||(n=Array.prototype.slice.call(e,0,i)),n[i]=e[i]);return r.concat(n||Array.prototype.slice.call(e))}var ss=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Cc=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function mf(r){return r instanceof SVGAnimatedLength?r.baseVal.value:r}function YE(r){return kt(this,void 0,void 0,function(){var e,t;return Nt(this,function(n){switch(n.label){case 0:return e=document.createElement("canvas"),r instanceof dn?[4,Wy(r,e)]:[3,2];case 1:return n.sent(),[3,3];case 2:e.width=mf(r.width),e.height=mf(r.height),t=e.getContext("2d"),r instanceof ImageData?t.putImageData(r,0,0):t.drawImage(r,0,0),n.label=3;case 3:return[2,e]}})})}function ZE(r){return kt(this,void 0,void 0,function(){var e,t,n,i,s,o;return Nt(this,function(a){switch(a.label){case 0:return r instanceof dn?(e=r.shape.slice(0,2),t=e[0],n=e[1],i=ImageData.bind,[4,Wy(r)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,a.sent(),n,t]))];case 2:return s=document.createElement("canvas"),o=s.getContext("2d"),s.width=mf(r.width),s.height=mf(r.height),o.drawImage(r,0,0),[2,o.getImageData(0,0,s.width,s.height)]}})})}function Fj(r){return kt(this,void 0,void 0,function(){var e,t;return Nt(this,function(n){switch(n.label){case 0:return r instanceof SVGImageElement||r instanceof OffscreenCanvas?[4,YE(r)]:[3,2];case 1:return t=n.sent(),[3,3];case 2:t=r,n.label=3;case 3:return e=t,[2,BE(e,4)]}})})}function QE(r){if(r<0||r>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(r));if(!Number.isInteger(r))throw new Error("Mask value must be an integer but got ".concat(r))}var Lu={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},$j=function(){function r(e){this.mask=e}return r.prototype.toCanvasImageSource=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,this.mask]})})},r.prototype.toImageData=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,ZE(this.mask)]})})},r.prototype.toTensor=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,Fj(this.mask)]})})},r.prototype.getUnderlyingType=function(){return"canvasimagesource"},r}();function zj(r){return QE(r),"person"}var Bj=function(){function r(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new t$.Pose({locateFile:function(i,s){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(i)}return"".concat(s,"/").concat(i)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(i){if(n.height=i.image.height,n.width=i.image.width,i.poseLandmarks==null)n.poses=[];else{var s=n.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(s.segmentation={maskValueToLabel:zj,mask:new $j(i.segmentationMask)}),n.poses=[s]}})}return r.prototype.translateOutput=function(e,t){var n=this,i={keypoints:e.map(function(s,o){return{x:s.x*n.width,y:s.y*n.height,z:s.z,score:s.visibility,name:Cc[o]}})};return t!=null&&(i.keypoints3D=t.map(function(s,o){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:Cc[o]}})),i},r.prototype.estimatePoses=function(e,t,n){return kt(this,void 0,void 0,function(){var i,s;return Nt(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof dn?(s=ImageData.bind,[4,Wy(e)]):[3,2];case 1:return i=new(s.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:i=e,o.label=3;case 3:return e=i,[4,this.poseSolution.send({image:e},n)];case 4:return o.sent(),[2,this.poses]}})})},r.prototype.dispose=function(){this.poseSolution.close()},r.prototype.reset=function(){this.poseSolution.reset()},r.prototype.initialize=function(){return this.poseSolution.initialize()},r}();function Uj(r){return kt(this,void 0,void 0,function(){var e,t;return Nt(this,function(n){switch(n.label){case 0:return e=function(i){if(i==null)return Ht({},Lu);var s=Ht({},i);return s.runtime="mediapipe",s.enableSegmentation==null&&(s.enableSegmentation=Lu.enableSegmentation),s.enableSmoothing==null&&(s.enableSmoothing=Lu.enableSmoothing),s.smoothSegmentation==null&&(s.smoothSegmentation=Lu.smoothSegmentation),s.modelType==null&&(s.modelType=Lu.modelType),s}(r),[4,(t=new Bj(e)).initialize()];case 1:return n.sent(),[2,t]}})})}function Ql(r){return r instanceof dn?{height:r.shape[0],width:r.shape[1]}:{height:r.height,width:r.width}}function JE(r){return r-2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI))}function Hy(r){return r instanceof dn?r:BE(r)}function eM(r,e,t){return cg(t,"inputResolution"),[1/t.width*r[0][0]*e.width,1/t.height*r[0][1]*e.width,r[0][3]*e.width,1/t.width*r[1][0]*e.height,1/t.height*r[1][1]*e.height,r[1][3]*e.height,0,0]}function cg(r,e){D(r.width!==0,function(){return"".concat(e," width cannot be 0.")}),D(r.height!==0,function(){return"".concat(e," height cannot be 0.")})}function _p(r,e,t){var n=t.rotationVectorStartKeypointIndex,i=t.rotationVectorEndKeypointIndex,s=r.locationData,o=s.relativeKeypoints[n].x*e.width,a=s.relativeKeypoints[n].y*e.height,l=s.relativeKeypoints[i].x*e.width,u=s.relativeKeypoints[i].y*e.height,c=2*Math.sqrt((l-o)*(l-o)+(u-a)*(u-a)),h=function(f,d,g){var p,m=f.locationData,_=g.rotationVectorStartKeypointIndex,v=g.rotationVectorEndKeypointIndex;p=g.rotationVectorTargetAngle?g.rotationVectorTargetAngle:Math.PI*g.rotationVectorTargetAngleDegree/180;var b=m.relativeKeypoints[_].x*d.width,x=m.relativeKeypoints[_].y*d.height,T=m.relativeKeypoints[v].x*d.width,I=m.relativeKeypoints[v].y*d.height;return JE(p-Math.atan2(-(I-x),T-b))}(r,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:c/e.width,height:c/e.height,rotation:h}}function tM(r){if(r.length!==16)throw new Error("Array length must be 16 but got ".concat(r.length));return[[r[0],r[1],r[2],r[3]],[r[4],r[5],r[6],r[7]],[r[8],r[9],r[10],r[11]],[r[12],r[13],r[14],r[15]]]}function bp(r,e,t,n,i,s,o){return r[e][i]*(r[t][s]*r[n][o]-r[t][o]*r[n][s])}function Zn(r,e,t){var n=(e+1)%4,i=(e+2)%4,s=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return bp(r,n,i,s,o,a,l)+bp(r,i,s,n,o,a,l)+bp(r,s,n,i,o,a,l)}function kx(r,e,t){t===void 0&&(t={ignoreRotation:!1});for(var n=[],i=0,s=r;i<s.length;i++){var o=s[i],a=o.x-.5,l=o.y-.5,u=t.ignoreRotation?0:e.rotation,c=Math.cos(u)*a-Math.sin(u)*l,h=Math.sin(u)*a+Math.cos(u)*l;c=c*e.width+e.xCenter,h=h*e.height+e.yCenter;var f=o.z*e.width,d=Ht({},o);d.x=c,d.y=h,d.z=f,n.push(d)}return n}function nM(r,e){var t=function(n,i,s,o){var a=i-n,l=o-s;if(a===0)throw new Error("Original min and max are both ".concat(n,", range cannot be 0."));var u=l/a;return{scale:u,offset:s-n*u}}(0,255,e[0],e[1]);return ht(function(){return Ye(Ce(r,t.scale),t.offset)})}function hg(r,e,t){var n,i,s,o,a,l,u,c,h,f,d,g,p,m,_=e.outputTensorSize,v=e.keepAspectRatio,b=e.borderMode,x=e.outputTensorFloatRange,T=Ql(r),I=function(A,R){return R?{xCenter:R.xCenter*A.width,yCenter:R.yCenter*A.height,width:R.width*A.width,height:R.height*A.height,rotation:R.rotation}:{xCenter:.5*A.width,yCenter:.5*A.height,width:A.width,height:A.height,rotation:0}}(T,t),C=function(A,R,F){if(F===void 0&&(F=!1),!F)return{top:0,left:0,right:0,bottom:0};var q=R.height,O=R.width;cg(R,"targetSize"),cg(A,"roi");var z,H,Q=q/O,Z=A.height/A.width,Y=0,fe=0;return Q>Z?(z=A.width,H=A.width*Q,fe=(1-Z/Q)/2):(z=A.height/Q,H=A.height,Y=(1-Q/Z)/2),A.width=z,A.height=H,{top:fe,left:Y,right:Y,bottom:fe}}(I,_,v),S=(n=I,i=T.width,s=T.height,o=!1,a=n.width,l=n.height,u=o?-1:1,c=Math.cos(n.rotation),h=Math.sin(n.rotation),f=n.xCenter,d=n.yCenter,g=1/i,p=1/s,(m=new Array(16))[0]=a*c*u*g,m[1]=-l*h*g,m[2]=0,m[3]=(-.5*a*c*u+.5*l*h+f)*g,m[4]=a*h*u*p,m[5]=l*c*p,m[6]=0,m[7]=(-.5*l*c-.5*a*h*u+d)*p,m[8]=0,m[9]=0,m[10]=a*g,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,tM(m));return{imageTensor:ht(function(){var A=Hy(r),R=vi(eM(S,T,_),[1,8]),F=b==="zero"?"constant":"nearest",q=xo.transform(ci(ln(A,"float32")),R,"bilinear",F,0,[_.height,_.width]);return x!=null?nM(q,x):q}),padding:C,transformationMatrix:S}}function Nx(r,e,t,n){return n===1?.5*(r+e):r+(e-r)*t/(n-1)}function Vj(r){return ht(function(){var e=function(i){return ht(function(){return[_t(i,[0,0,0],[1,-1,1]),_t(i,[0,0,1],[1,-1,-1])]})}(r),t=e[0],n=e[1];return{boxes:Vt(n),logits:Vt(t)}})}function rM(r){return r!=null&&r.currentTime!=null}function Rx(r){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<r.length;++o){var a=r[o];t=Math.min(t,a.x),n=Math.max(n,a.x),i=Math.min(i,a.y),s=Math.max(s,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:i,xMax:n,yMax:s,width:n-t,height:s-i},e}function Wj(r,e,t,n){return kt(this,void 0,void 0,function(){var i,s,o,a,l;return Nt(this,function(u){switch(u.label){case 0:return r.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),i=vi(r.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),s=ir(r.map(function(c){return c.score[0]})),[4,xo.nonMaxSuppressionAsync(i,s,e,t)];case 1:return[4,(o=u.sent()).array()];case 2:return a=u.sent(),l=r.filter(function(c,h){return a.indexOf(h)>-1}),zt([i,s,o]),[2,l]}})})}function iM(r,e){return r.map(function(t){var n=Ht(Ht({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(n.z=t.z*e.width),n})}function Gj(r,e,t){return kt(this,void 0,void 0,function(){var n,i,s,o,a,l,u,c,h,f,d,g,p,m,_,v,b,x,T,I,C,S,A,R;return Nt(this,function(F){switch(F.label){case 0:if(n=Vt(e,[0]),i=n.shape,s=i[0],o=i[1],a=i[2],r.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(r.length,", heatmap length: ").concat(a));return l=[],[4,n.buffer()];case 1:for(u=F.sent(),c=0;c<r.length;c++)if(h=r[c],f=Ht({},h),l.push(f),d=Math.trunc(f.x*o),g=Math.trunc(f.y*s),!(d<0||d>=o||g<0||d>=s)){for(p=Math.trunc((t.kernelSize-1)/2),m=Math.max(0,d-p),_=Math.min(o,d+p+1),v=Math.max(0,g-p),b=Math.min(s,g+p+1),x=0,T=0,I=0,C=0,S=v;S<b;++S)for(A=m;A<_;++A)R=u.get(S,A,c),x+=R,C=Math.max(C,R),T+=A*R,I+=S*R;C>=t.minConfidenceToRefine&&x>0&&(f.x=T/o/x,f.y=I/s/x)}return n.dispose(),[2,l]}})})}function Px(r,e){var t=e.left,n=e.top,i=e.left+e.right,s=e.top+e.bottom;return r.map(function(o){return Ht(Ht({},o),{x:(o.x-t)/(1-i),y:(o.y-n)/(1-s),z:o.z/(1-i)})})}function Hj(r,e,t){return sf()==="webgl"?function(n,i,s){var o=s.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:n.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=wc();return ht(function(){var u=l.compileAndRun(a,[n,i]);return Il().makeTensorFromDataId(u.dataId,u.shape,u.dtype)})}(r,e,t):ht(function(){var n=ft(e,.5),i=xi(n),s=ft(1,ky(1,Ce(i,Ye(5.68842,Ce(i,Ye(-.748699,Ce(i,Ye(-57.8051,Ce(i,Ye(291.309,Ce(i,-624.717)))))))))));return Ye(e,Ce(ft(r,e),Ce(s,t.combineWithPreviousRatio)))})}function jj(r,e,t){return kt(this,void 0,void 0,function(){var n,i,s,o,a;return Nt(this,function(l){switch(l.label){case 0:return n=r[0],i=r[1],s=function(u,c,h){return ht(function(){var f,d,g,p;h.reverseOutputOrder?(d=Vt(_t(u,[0,h.boxCoordOffset+0],[-1,1])),f=Vt(_t(u,[0,h.boxCoordOffset+1],[-1,1])),p=Vt(_t(u,[0,h.boxCoordOffset+2],[-1,1])),g=Vt(_t(u,[0,h.boxCoordOffset+3],[-1,1]))):(f=Vt(_t(u,[0,h.boxCoordOffset+0],[-1,1])),d=Vt(_t(u,[0,h.boxCoordOffset+1],[-1,1])),g=Vt(_t(u,[0,h.boxCoordOffset+2],[-1,1])),p=Vt(_t(u,[0,h.boxCoordOffset+3],[-1,1]))),d=Ye(Ce(bt(d,h.xScale),c.w),c.x),f=Ye(Ce(bt(f,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(g=Ce(Os(bt(g,h.hScale)),c.h),p=Ce(Os(bt(p,h.wScale)),c.w)):(g=Ce(bt(g,h.hScale),c.h),p=Ce(bt(p,h.wScale),c.h));var m=ft(f,bt(g,2)),_=ft(d,bt(p,2)),v=Ye(f,bt(g,2)),b=Ye(d,bt(p,2)),x=kn([ye(m,[h.numBoxes,1]),ye(_,[h.numBoxes,1]),ye(v,[h.numBoxes,1]),ye(b,[h.numBoxes,1])],1);if(h.numKeypoints)for(var T=0;T<h.numKeypoints;++T){var I=h.keypointCoordOffset+T*h.numValuesPerKeypoint,C=void 0,S=void 0;h.reverseOutputOrder?(C=Vt(_t(u,[0,I],[-1,1])),S=Vt(_t(u,[0,I+1],[-1,1]))):(S=Vt(_t(u,[0,I],[-1,1])),C=Vt(_t(u,[0,I+1],[-1,1])));var A=Ye(Ce(bt(C,h.xScale),c.w),c.x),R=Ye(Ce(bt(S,h.yScale),c.h),c.y);x=kn([x,ye(A,[h.numBoxes,1]),ye(R,[h.numBoxes,1])],1)}return x})}(i,e,t),o=ht(function(){var u=n;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(u=Y2(n,-t.scoreClippingThresh,t.scoreClippingThresh)),u=Is(u)):u}),[4,qj(s,o,t)];case 1:return a=l.sent(),zt([s,o]),[2,a]}})})}function qj(r,e,t){return kt(this,void 0,void 0,function(){var n,i,s,o,a,l,u,c,h,f,d,g;return Nt(this,function(p){switch(p.label){case 0:return n=[],[4,r.data()];case 1:return i=p.sent(),[4,e.data()];case 2:for(s=p.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&s[o]<t.minScoreThresh||(a=o*t.numCoords,l=Kj(i[a+0],i[a+1],i[a+2],i[a+3],s[o],t.flipVertically,o),(u=l.locationData.relativeBoundingBox).width<0||u.height<0))){if(t.numKeypoints>0)for((c=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,f=0;f<h;f+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+f,g={x:i[d+0],y:t.flipVertically?1-i[d+1]:i[d+1]},c.relativeKeypoints.push(g);n.push(l)}return[2,n]}})})}function Kj(r,e,t,n,i,s,o){return{score:[i],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:s?1-t:r,xMax:n,yMax:s?1-r:t,width:n-e,height:t-r}}}}function Xj(r,e){return r==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Lx(r,e,t,n){return kt(this,void 0,void 0,function(){var i,s,o,a,l,u,c,h;return Nt(this,function(f){switch(f.label){case 0:return t=t||e.flipHorizontally||!1,n=n||e.flipVertically||!1,i=r.size,s=i/e.numLandmarks,[4,r.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)u=l*s,(h={x:0,y:0}).x=t?e.inputImageWidth-o[u]:o[u],s>1&&(h.y=n?e.inputImageHeight-o[u+1]:o[u+1]),s>2&&(h.z=o[u+2]),s>3&&(h.score=Xj(e.visibilityActivation,o[u+3])),a.push(h);for(c=0;c<a.length;++c)(h=a[c]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Dx(r,e,t){var n=r.width,i=r.height,s=r.rotation;if(t.rotation==null&&t.rotationDegree==null||(s=function(c,h){return h.rotation!=null?c+=h.rotation:h.rotationDegree!=null&&(c+=Math.PI*h.rotationDegree/180),JE(c)}(s,t)),s===0)r.xCenter=r.xCenter+n*t.shiftX,r.yCenter=r.yCenter+i*t.shiftY;else{var o=(e.width*n*t.shiftX*Math.cos(s)-e.height*i*t.shiftY*Math.sin(s))/e.width,a=(e.width*n*t.shiftX*Math.sin(s)+e.height*i*t.shiftY*Math.cos(s))/e.height;r.xCenter=r.xCenter+o,r.yCenter=r.yCenter+a}if(t.squareLong){var l=Math.max(n*e.width,i*e.height);n=l/e.width,i=l/e.height}else if(t.squareShort){var u=Math.min(n*e.width,i*e.height);n=u/e.width,i=u/e.height}return r.width=n*t.scaleX,r.height=i*t.scaleY,r}function Yj(r,e){return r.map(function(t){var n=Ht(Ht({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),n})}var co=function(){function r(e){this.alpha=e,this.initialized=!1}return r.prototype.apply=function(e,t){var n;return this.initialized?n=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},r.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},r.prototype.hasLastRawValue=function(){return this.initialized},r.prototype.lastRawValue=function(){return this.rawValue},r.prototype.reset=function(){this.initialized=!1},r}(),xp=function(){function r(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new co(this.getAlpha(this.minCutOff)),this.dx=new co(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return r.prototype.apply=function(e,t,n){if(e==null)return e;var i=Math.trunc(t);if(this.lastTimestamp>=i)return e;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,o=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},r.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},r}(),fg=function(){function r(e){this.config=e}return r.prototype.apply=function(e,t,n){var i=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return aa([],e,!0);s=1/n}return e.map(function(o,a){var l=Ht(Ht({},o),{x:i.xFilters[a].apply(o.x,t,s),y:i.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,s)),l})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(n){return new xp(t.config)}),this.yFilters=e.map(function(n){return new xp(t.config)}),this.zFilters=e.map(function(n){return new xp(t.config)}))},r}(),vp=function(){function r(e){this.config=e,this.window=[],this.lowPassFilter=new co(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return r.prototype.apply=function(e,t,n){if(e==null)return e;var i,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(this.lastTimestamp===-1)i=1;else{for(var o=e*n-this.lastValue*this.lastValueScale,a=s-this.lastTimestamp,l=o,u=a,c=(1+this.window.length)*(1e6/30),h=0,f=this.window;h<f.length;h++){var d=f[h];if(u+d.duration>c)break;l+=d.distance,u+=d.duration}var g=l/(1e-6*u);i=1-1/(1+this.config.velocityScale*Math.abs(g)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,i)},r}(),Zj=function(){function r(e){this.config=e}return r.prototype.apply=function(e,t,n){var i=this;if(e==null)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return aa([],e,!0);s=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=Ht(Ht({},o),{x:i.xFilters[a].apply(o.x,t,s),y:i.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,s)),l})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(n){return new vp(t.config)}),this.yFilters=e.map(function(n){return new vp(t.config)}),this.zFilters=e.map(function(n){return new vp(t.config)}))},r}(),wp=function(){function r(e){if(e.velocityFilter!=null)this.keypointsFilter=new Zj(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new fg(e.oneEuroFilter)}}return r.prototype.apply=function(e,t,n,i,s){if(i===void 0&&(i=!1),e==null)return this.keypointsFilter.reset(),null;var o=s!=null?function(u,c){return(u.width*c.width+u.height*c.height)/2}(s,n):1,a=i?iM(e,n):e,l=this.keypointsFilter.apply(a,t,o);return i?Yj(l,n):l},r}(),Ox=function(){function r(e){this.alpha=e.alpha}return r.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new co(t.alpha)}));for(var n=[],i=0;i<e.length;++i){var s=e[i],o=Ht({},s);o.score=this.visibilityFilters[i].apply(s.score),n.push(o)}return n},r}(),Qj={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},sl={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Jj={maxPoses:1,flipHorizontal:!1},eq={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},tq=.3,Fx={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},nq={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},rq={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},iq={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},sq={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},oq={kernelSize:7,minConfidenceToRefine:.5},$x={alpha:.1},aq={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},lq={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},uq={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},cq={activation:"none"},hq={combineWithPreviousRatio:.7},fq=function(){function r(e){this.mask=e}return r.prototype.toCanvasImageSource=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,YE(this.mask)]})})},r.prototype.toImageData=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,ZE(this.mask)]})})},r.prototype.toTensor=function(){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,this.mask]})})},r.prototype.getUnderlyingType=function(){return"tensor"},r}();function dq(r){return QE(r),"person"}var pq=function(){function r(e,t,n,i,s,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=i,this.smoothSegmentation=s,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var f=[],d=0;d<h.numLayers;){for(var g=[],p=[],m=[],_=[],v=d;v<h.strides.length&&h.strides[v]===h.strides[d];){var b=Nx(h.minScale,h.maxScale,v,h.strides.length);if(v===0&&h.reduceBoxesInLowestLayer)m.push(1),m.push(2),m.push(.5),_.push(.1),_.push(b),_.push(b);else{for(var x=0;x<h.aspectRatios.length;++x)m.push(h.aspectRatios[x]),_.push(b);if(h.interpolatedScaleAspectRatio>0){var T=v===h.strides.length-1?1:Nx(h.minScale,h.maxScale,v+1,h.strides.length);_.push(Math.sqrt(b*T)),m.push(h.interpolatedScaleAspectRatio)}}v++}for(var I=0;I<m.length;++I){var C=Math.sqrt(m[I]);g.push(_[I]/C),p.push(_[I]*C)}var S=0,A=0;if(h.featureMapHeight.length>0)S=h.featureMapHeight[d],A=h.featureMapWidth[d];else{var R=h.strides[d];S=Math.ceil(h.inputSizeHeight/R),A=Math.ceil(h.inputSizeWidth/R)}for(var F=0;F<S;++F)for(var q=0;q<A;++q)for(var O=0;O<g.length;++O){var z={xCenter:(q+h.anchorOffsetX)/A,yCenter:(F+h.anchorOffsetY)/S,width:0,height:0};h.fixedAnchorSize?(z.width=1,z.height=1):(z.width=p[O],z.height=g[O]),f.push(z)}d=v}return f}(Qj);var a=ir(this.anchors.map(function(h){return h.width})),l=ir(this.anchors.map(function(h){return h.height})),u=ir(this.anchors.map(function(h){return h.xCenter})),c=ir(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:u,y:c,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?vi([],[0,0]):null}return r.prototype.estimatePoses=function(e,t,n){return kt(this,void 0,void 0,function(){var i,s,o,a,l,u,c,h,f,d,g,p,m,_,v,b,x,T,I,C,S,A,R;return Nt(this,function(F){switch(F.label){case 0:return i=function(q){var O;if((O=q==null?Jj:Ht({},q)).maxPoses==null&&(O.maxPoses=1),O.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(O.maxPoses,". Should be > 0."));if(O.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return O}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=n!=null?1e3*n:rM(e)?1e6*e.currentTime:null,s=Ql(e),o=ht(function(){return ln(Hy(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=F.sent()).length===0)return this.reset(),o.dispose(),[2,[]];u=l[0],a=this.poseDetectionToRoi(u,s),F.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return c=F.sent(),o.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,f=c.auxiliaryLandmarks,d=c.poseScore,g=c.worldLandmarks,p=c.segmentationMask,m=this.poseLandmarkFiltering(h,f,g,s),_=m.actualLandmarksFiltered,v=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,x=this.poseLandmarksToRoi(v,s),this.regionOfInterest=x,T=this.smoothSegmentation&&p!=null?this.poseSegmentationFiltering(p):p,(I=_!=null?iM(_,s):null)!=null&&I.forEach(function(q,O){q.name=Cc[O]}),(C=b)!=null&&C.forEach(function(q,O){q.name=Cc[O]}),S={score:d,keypoints:I,keypoints3D:C},T!==null&&(A=ht(function(){var q=ci(T,2),O=Ao(q,[[0,0],[0,0],[0,1]]);return pE(O,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||zt(T),R={maskValueToLabel:dq,mask:new fq(A)},S.segmentation=R),[2,[S]])}})})},r.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Hj(t,e,hq),zt(e)),zt(t),this.prevFilteredSegmentationMask},r.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),zt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},r.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(zt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=vi([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},r.prototype.detectPose=function(e){return kt(this,void 0,void 0,function(){var t,n,i,s,o,a,l,u,c,h;return Nt(this,function(f){switch(f.label){case 0:return t=hg(e,nq),n=t.imageTensor,i=t.padding,s=this.detectorModel.predict(n),o=Vj(s),a=o.boxes,[4,jj([l=o.logits,a],this.anchorTensor,eq)];case 1:return(u=f.sent()).length===0?(zt([n,s,l,a]),[2,u]):[4,Wj(u,this.maxPoses,tq)];case 2:return c=f.sent(),h=function(d,g){d===void 0&&(d=[]);for(var p=g.left,m=g.top,_=g.left+g.right,v=g.top+g.bottom,b=0;b<d.length;b++){var x=d[b],T=x.locationData.relativeBoundingBox,I=(T.xMin-p)/(1-_),C=(T.yMin-m)/(1-v),S=T.width/(1-_),A=T.height/(1-v);T.xMin=I,T.yMin=C,T.width=S,T.height=A,T.xMax=I+S,T.yMax=C+A;var R=x.locationData.relativeKeypoints;R&&R.forEach(function(F){var q=(F.x-p)/(1-_),O=(F.y-m)/(1-v);F.x=q,F.y=O})}return d}(c,i),zt([n,s,l,a]),[2,h]}})})},r.prototype.poseDetectionToRoi=function(e,t){return Dx(_p(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Fx)},r.prototype.poseLandmarksByRoi=function(e,t){return kt(this,void 0,void 0,function(){var n,i,s,o,a,l,u,c,h,f,d,g,p,m;return Nt(this,function(_){switch(_.label){case 0:if(n=Ql(t),i=hg(t,rq,e),s=i.imageTensor,o=i.padding,a=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),u=this.landmarkModel.execute(s,l),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return(c=_.sent())==null?(zt(u),zt(s),[2,null]):(h=c.landmarks,f=c.auxiliaryLandmarks,d=c.poseScore,g=c.worldLandmarks,p=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,o,a,h,f,g,p)]);case 2:return m=_.sent(),zt(u),zt(s),[2,Ht({poseScore:d},m)]}})})},r.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,i,s,o,a,l){return kt(this,void 0,void 0,function(){var u,c,h,f,d,g;return Nt(this,function(p){return u=Px(s,n),c=Px(o,n),h=kx(u,t),f=kx(c,t),d=function(m,_){for(var v=[],b=0,x=m;b<x.length;b++){var T=x[b],I=T.x,C=T.y,S=_.rotation,A=Math.cos(S)*I-Math.sin(S)*C,R=Math.sin(S)*I+Math.cos(S)*C,F=Ht({},T);F.x=A,F.y=R,v.push(F)}return v}(a,t),g=null,this.enableSegmentation&&(g=ht(function(){var m=l.shape,_=m[0],v=m[1],b=function(I){var C=tM(new Array(16).fill(0));C[0][0]=Zn(I,0,0),C[1][0]=-Zn(I,0,1),C[2][0]=Zn(I,0,2),C[3][0]=-Zn(I,0,3),C[0][2]=Zn(I,2,0),C[1][2]=-Zn(I,2,1),C[2][2]=Zn(I,2,2),C[3][2]=-Zn(I,2,3),C[0][1]=-Zn(I,1,0),C[1][1]=Zn(I,1,1),C[2][1]=-Zn(I,1,2),C[3][1]=Zn(I,1,3),C[0][3]=-Zn(I,3,0),C[1][3]=Zn(I,3,1),C[2][3]=-Zn(I,3,2),C[3][3]=Zn(I,3,3);for(var S=I[0][0]*C[0][0]+I[1][0]*C[0][1]+I[2][0]*C[0][2]+I[3][0]*C[0][3],A=0;A<C.length;A++)for(var R=0;R<C.length;R++)C[A][R]/=S;return C}(i),x=vi(eM(b,{width:v,height:_},e),[1,8]),T=[1,_,v,1];return Vt(xo.transform(ye(l,T),x,"bilinear","constant",0,[e.height,e.width]),[0,3])}),zt(l)),[2,{landmarks:h,auxiliaryLandmarks:f,worldLandmarks:d,segmentationMask:g}]})})},r.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return kt(this,void 0,void 0,function(){var t,n,i,s,o,a,l,u,c,h,f,d,g;return Nt(this,function(p){switch(p.label){case 0:return t=e[0],n=e[1],i=e[2],s=e[3],o=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(a=p.sent()[0])<.5?[2,null]:[4,Lx(t,iq)];case 2:return[4,Gj(p.sent(),i,oq)];case 3:return l=p.sent(),u=l.slice(0,33),c=l.slice(33,35),[4,Lx(s,sq)];case 4:return h=p.sent(),f=h.slice(0,33),d=function(m,_,v){v===void 0&&(v=!0);for(var b=[],x=0;x<m.length;x++){var T=Ht({},_[x]);v&&(T.score=m[x].score),b.push(T)}return b}(u,f,!0),g=this.enableSegmentation?function(m,_,v){return ht(function(){var b=Vt(m,[0]),x=b.shape[2];if(x===1){var T=b;switch(_.activation){case"none":break;case"sigmoid":T=Is(T);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(_.activation,")"))}var I=v?xo.resizeBilinear(T,[v.height,v.width]):T;return Vt(I,[2])}throw new Error("Unsupported number of tensor channels ".concat(x))})}(o,cq):null,[2,{landmarks:u,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:d,segmentationMask:g}]}})})},r.prototype.poseLandmarksToRoi=function(e,t){return Dx(_p(Rx(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Fx)},r.prototype.poseLandmarkFiltering=function(e,t,n,i){var s,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=_p(Rx(t),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Ox($x)),s=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Ox($x)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(n),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new wp(aq)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,i,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new wp(lq)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,i,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new wp(uq)),a=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else s=e,o=t,a=n;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},r}();function mq(r){return kt(this,void 0,void 0,function(){var e,t,n,i,s,o;return Nt(this,function(a){switch(a.label){case 0:return e=function(l){var u=Ht({},l??sl);if(u.enableSmoothing==null&&(u.enableSmoothing=sl.enableSmoothing),u.enableSegmentation==null&&(u.enableSegmentation=sl.enableSegmentation),u.smoothSegmentation==null&&(u.smoothSegmentation=sl.smoothSegmentation),u.modelType==null&&(u.modelType=sl.modelType),u.detectorModelUrl==null&&(u.detectorModelUrl=sl.detectorModelUrl),u.landmarkModelUrl==null)switch(u.modelType){case"lite":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return u}(r),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,n=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Zl(e.detectorModelUrl,{fromTFHub:t}),Zl(e.landmarkModelUrl,{fromTFHub:n})])];case 1:return i=a.sent(),s=i[0],o=i[1],[2,new pq(s,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var ma,ns,sM=function(){function r(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var n=0,i=t.keypointTrackerParams.keypointFalloff;n<i.length;n++){var s=i[n];if(s<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(s))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return r.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},r.prototype.getTracks=function(){return this.tracks.slice()},r.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},r.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(n){return e-n.lastTimestamp<=t.maxAge})},r.prototype.assignTracks=function(e,t,n){for(var i=Array.from(Array(t[0].length).keys()),s=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(i.length!==0){for(var u=-1,c=-1,h=0,f=i;h<f.length;h++){var d=f[h],g=t[l][d];g>=this.minSimilarity&&g>c&&(u=d,c=g)}if(u>=0){var p=this.tracks[u];p=Object.assign(p,this.createTrack(e[l],n,p.id)),e[l].id=p.id;var m=i.indexOf(u);i.splice(m,1)}else s.push(l)}else s.push(l)}for(var _=0,v=s;_<v.length;_++){l=v[_];var b=this.createTrack(e[l],n);this.tracks.push(b),e[l].id=b.id}},r.prototype.updateTracks=function(e){this.tracks.sort(function(t,n){return n.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},r.prototype.createTrack=function(e,t,n){var i={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:aa([],e.keypoints,!0).map(function(s){return Ht({},s)})};return e.box!==void 0&&(i.box=Ht({},e.box)),i},r.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},r.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(n){return!e.includes(n.id)})},r.prototype.reset=function(){this.tracks=[]},r}(),gq=function(r){function e(t){return r.call(this,t)||this}return XE(e,r),e.prototype.computeSimilarity=function(t){var n=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(i){return n.tracks.map(function(s){return n.iou(i,s)})})},e.prototype.iou=function(t,n){var i=Math.max(t.box.xMin,n.box.xMin),s=Math.max(t.box.yMin,n.box.yMin),o=Math.min(t.box.xMax,n.box.xMax),a=Math.min(t.box.yMax,n.box.yMax);if(i>=o||s>=a)return 0;var l=(o-i)*(a-s);return l/(t.box.width*t.box.height+n.box.width*n.box.height-l)},e}(sM),yq=function(r){function e(t){var n=r.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return XE(e,r),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var n=[],i=0,s=t;i<s.length;i++){for(var o=s[i],a=[],l=0,u=this.tracks;l<u.length;l++){var c=u[l];a.push(this.oks(o,c))}n.push(a)}return n},e.prototype.oks=function(t,n){for(var i=this.area(n.keypoints)+1e-6,s=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],u=n.keypoints[a];if(!(l.score<this.keypointThreshold||u.score<this.keypointThreshold)){o+=1;var c=Math.pow(l.x-u.x,2)+Math.pow(l.y-u.y,2),h=2*this.keypointFalloff[a];s+=Math.exp(-1*c/(2*i*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:s/o},e.prototype.area=function(t){var n=this,i=t.filter(function(l){return l.score>n.keypointThreshold}),s=Math.min.apply(Math,aa([1],i.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,aa([0],i.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,aa([1],i.map(function(l){return l.y}),!1));return(o-s)*(Math.max.apply(Math,aa([0],i.map(function(l){return l.y}),!1))-a)},e}(sM);function _q(r){switch(r){case ns.BlazePose:return Cc.reduce(function(e,t,n){return e[t]=n,e},{});case ns.PoseNet:case ns.MoveNet:return ss.reduce(function(e,t,n){return e[t]=n,e},{});default:throw new Error("Model ".concat(r," is not supported."))}}(function(r){r.Keypoint="keypoint",r.BoundingBox="boundingBox"})(ma||(ma={})),function(r){r.MoveNet="MoveNet",r.BlazePose="BlazePose",r.PoseNet="PoseNet"}(ns||(ns={}));var zx=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],oM={modelType:"SinglePose.Lightning",enableSmoothing:!0},Bx={},Ux={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Sp={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Vx={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function bq(r,e,t,n){for(var i={},s=0,o=ss;s<o.length;s++){var a=o[s];i[a]=[e[t[a]].y*n.height,e[t[a]].x*n.width]}if(function(v,b){return(v[b.left_hip].score>.2||v[b.right_hip].score>.2)&&(v[b.left_shoulder].score>.2||v[b.right_shoulder].score>.2)}(e,t)){var l=(i.left_hip[0]+i.right_hip[0])/2,u=(i.left_hip[1]+i.right_hip[1])/2,c=function(v,b,x,T,I){for(var C=["left_shoulder","right_shoulder","left_hip","right_hip"],S=0,A=0,R=0;R<C.length;R++)(H=Math.abs(T-x[C[R]][0]))>S&&(S=H),(Q=Math.abs(I-x[C[R]][1]))>A&&(A=Q);for(var F=0,q=0,O=0,z=Object.keys(x);O<z.length;O++){var H,Q,Z=z[O];v[b[Z]].score<.2||((H=Math.abs(T-x[Z][0]))>F&&(F=H),(Q=Math.abs(I-x[Z][1]))>q&&(q=Q))}return[S,A,F,q]}(e,t,i,l,u),h=c[0],f=c[1],d=c[2],g=c[3],p=Math.max(1.9*f,1.9*h,1.2*d,1.2*g),m=[l-(p=Math.min(p,Math.max(u,n.width-u,l,n.height-l))),u-p];if(p>Math.max(n.width,n.height)/2)return dg(r==null,n);var _=2*p;return{yMin:m[0]/n.height,xMin:m[1]/n.width,yMax:(m[0]+_)/n.height,xMax:(m[1]+_)/n.width,height:(m[0]+_)/n.height-m[0]/n.height,width:(m[1]+_)/n.width-m[1]/n.width}}return dg(r==null,n)}function dg(r,e){var t,n,i,s;return r?e.width>e.height?(t=1,n=e.height/e.width,i=0,s=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,n=1,i=(e.height/2-e.width/2)/e.height,s=0):e.width>e.height?(t=e.width/e.height,n=1,i=(e.height/2-e.width/2)/e.height,s=0):(t=1,n=e.height/e.width,i=0,s=(e.width/2-e.height/2)/e.width),{yMin:i,xMin:s,yMax:i+t,xMax:s+n,height:t,width:n}}function xq(r){var e,t=r==null?oM:Ht({},r);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(zx.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(zx));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=ma.BoundingBox),t.trackerType===ma.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(n){var i=Wx(Sp,n);return i.keypointTrackerParams=Ht({},Sp.keypointTrackerParams),n.keypointTrackerParams!=null&&(n.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=n.keypointTrackerParams.keypointConfidenceThreshold),n.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=n.keypointTrackerParams.keypointFalloff),n.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=n.keypointTrackerParams.minNumberOfKeypoints)),i}(t.trackerConfig):t.trackerConfig=Sp;else{if(t.trackerType!==ma.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Wx(Vx,e)):t.trackerConfig=Vx}return t}function Wx(r,e){var t={maxTracks:r.maxTracks,maxAge:r.maxAge,minSimilarity:r.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var vq=function(){function r(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=_q(ns.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new fg(Ux),this.cropRegionFilterYMin=new co(.9),this.cropRegionFilterXMin=new co(.9),this.cropRegionFilterYMax=new co(.9),this.cropRegionFilterXMax=new co(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===ma.Keypoint?this.tracker=new yq(t.trackerConfig):t.trackerType===ma.BoundingBox&&(this.tracker=new gq(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return r.prototype.runSinglePersonPoseModel=function(e){return kt(this,void 0,void 0,function(){var t,n,i,s,o;return Nt(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return sf()==="webgpu"?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=a.sent(),a.label=3;case 3:for(t.dispose(),i={keypoints:[],score:0},s=0,o=0;o<17;++o)i.keypoints[o]={y:n[3*o],x:n[3*o+1],score:n[3*o+2]},i.keypoints[o].score>.2&&(++s,i.score+=i.keypoints[o].score);return s>0&&(i.score/=s),[2,i]}})})},r.prototype.runMultiPersonPoseModel=function(e){return kt(this,void 0,void 0,function(){var t,n,i,s,o,a,l,u;return Nt(this,function(c){switch(c.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return sf()==="webgpu"?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=c.sent(),c.label=3;case 3:for(t.dispose(),i=[],s=n.length/56,o=0;o<s;++o)for(i[o]={keypoints:[]},a=56*o+51,i[o].box={yMin:n[a],xMin:n[a+1],yMax:n[a+2],xMax:n[a+3],width:n[a+3]-n[a+1],height:n[a+2]-n[a]},l=56*o+55,i[o].score=n[l],i[o].keypoints=[],u=0;u<17;++u)i[o].keypoints[u]={y:n[56*o+3*u],x:n[56*o+3*u+1],score:n[56*o+3*u+2]};return[2,i]}})})},r.prototype.estimatePoses=function(e,t,n){return t===void 0&&(t=Bx),kt(this,void 0,void 0,function(){var i,s,o,a,l,u;return Nt(this,function(c){switch(c.label){case 0:return t=function(h){return h==null?Bx:Ht({},h)}(t),e==null?(this.reset(),[2,[]]):(n==null?rM(e)&&(n=1e6*e.currentTime):n*=1e3,i=Hy(e),s=Ql(i),o=ci(i,0),e instanceof dn||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,s,n)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,s,n)];case 3:a=c.sent(),c.label=4;case 4:for(l=0;l<a.length;++l)for(u=0;u<a[l].keypoints.length;++u)a[l].keypoints[u].name=ss[u],a[l].keypoints[u].y*=s.height,a[l].keypoints[u].x*=s.width;return[2,a]}})})},r.prototype.estimateSinglePose=function(e,t,n){return kt(this,void 0,void 0,function(){var i,s,o,a,l=this;return Nt(this,function(u){switch(u.label){case 0:return this.cropRegion||(this.cropRegion=dg(this.cropRegion==null,t)),i=ht(function(){var c=vi([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=Mo([1],"int32"),f=[l.modelInputResolution.height,l.modelInputResolution.width];return ln(xo.cropAndResize(e,c,h,f,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(s=u.sent(),i.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<s.keypoints.length;++o)s.keypoints[o].y=this.cropRegion.yMin+s.keypoints[o].y*this.cropRegion.height,s.keypoints[o].x=this.cropRegion.xMin+s.keypoints[o].x*this.cropRegion.width;return n!=null&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),a=bq(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[s]]}})})},r.prototype.estimateMultiplePoses=function(e,t,n){return kt(this,void 0,void 0,function(){var i,s,o,a,l,u,c,h,f,d,g,p=this;return Nt(this,function(m){switch(m.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),i=xo.resizeBilinear(e,[o,s]),l=s,u=32*Math.ceil(o/32),a=Ao(i,[[0,0],[0,u-o],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,i=xo.resizeBilinear(e,[o,s]),l=32*Math.ceil(s/32),u=o,a=Ao(i,[[0,0],[0,0],[0,l-s],[0,0]])),i.dispose(),e.dispose(),c=ln(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=m.sent(),c.dispose(),h=h.filter(function(_){return _.score>=p.minPoseScore}),d=0;d<h.length;++d)for(f=0;f<h[d].keypoints.length;++f)h[d].keypoints[f].y*=u/o,h[d].keypoints[f].x*=l/s;if(this.enableTracking&&(this.tracker.apply(h,n),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new fg(Ux)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,n,1);g=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(_,v){g.has(v)||p.keypointFilterMap.delete(v)})}return[2,h]}})})},r.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),i=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:i,xMax:s,height:i-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},r.prototype.dispose=function(){this.moveNetModel.dispose()},r.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},r.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},r}();function wq(r){return r===void 0&&(r=oM),kt(this,void 0,void 0,function(){var e,t,n,i;return Nt(this,function(s){switch(s.label){case 0:return e=xq(r),n=!0,e.modelUrl?(n=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Zl(e.modelUrl,{fromTFHub:n})]):[3,2];case 1:return t=s.sent(),[3,4];case 2:return i=void 0,e.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Zl(i,{fromTFHub:n})];case 3:t=s.sent(),s.label=4;case 4:return sf()==="webgl"&&it().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new vq(t,e)]}})})}var Gx={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Hx=["MobileNetV1","ResNet50"],jx={MobileNetV1:[8,16],ResNet50:[16]},Sq=[8,16,32],qx={MobileNetV1:[.5,.75,1],ResNet50:[1]},Kx=[1,2,4],Xx={maxPoses:1,flipHorizontal:!1},Tq={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Eq=[-123.15,-115.9,-103.06];function Tp(r){return Math.floor(r/2)}var Mq=function(){function r(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return r.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},r.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},r.prototype.empty=function(){return this.numberOfElements===-1},r.prototype.size=function(){return this.numberOfElements+1},r.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},r.prototype.max=function(){return this.priorityQueue[0]},r.prototype.swim=function(e){for(;e>0&&this.less(Tp(e),e);)this.exchange(e,Tp(e)),e=Tp(e)},r.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},r.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},r.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},r.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},r}();function Aq(r,e,t,n,i,s){for(var o=s.shape,a=o[0],l=o[1],u=!0,c=Math.max(t-i,0),h=Math.min(t+i+1,a),f=c;f<h;++f){for(var d=Math.max(n-i,0),g=Math.min(n+i+1,l),p=d;p<g;++p)if(s.get(f,p,r)>e){u=!1;break}if(!u)break}return u}function Iq(r){return kt(this,void 0,void 0,function(){return Nt(this,function(e){return[2,Promise.all(r.map(function(t){return t.buffer()}))]})})}function aM(r,e,t,n){return{y:n.get(r,e,t),x:n.get(r,e,t+17)}}function lM(r,e,t){var n=aM(r.heatmapY,r.heatmapX,r.id,t),i=n.y,s=n.x;return{x:r.heatmapX*e+s,y:r.heatmapY*e+i}}function uM(r,e,t,n){var i=t.x,s=t.y;return r.some(function(o){var a,l,u,c,h,f,d=o.keypoints;return a=s,l=i,u=d[n].y,c=d[n].x,(h=u-a)*h+(f=c-l)*f<=e})}var Yx=ss.reduce(function(r,e,t){return r[e]=t,r},{}),cM=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(r){var e=r[0],t=r[1];return[Yx[e],Yx[t]]}),Ep=cM.map(function(r){return r[1]}),Zx=cM.map(function(r){return r[0]});function Qx(r,e,t){return r<e?e:r>t?t:r}function Mp(r,e,t,n){return{y:Qx(Math.round(r.y/e),0,t-1),x:Qx(Math.round(r.x/e),0,n-1)}}function Jx(r,e){return{x:r.x+e.x,y:r.y+e.y}}function ev(r,e,t,n,i,s,o,a){a===void 0&&(a=2);for(var l=n.shape,u=l[0],c=l[1],h={y:e.y,x:e.x},f=Jx(h,function(v,b,x){var T=x.shape[2]/2;return{y:x.get(b.y,b.x,v),x:x.get(b.y,b.x,T+v)}}(r,Mp(h,s,u,c),o)),d=0;d<a;d++){var g=Mp(f,s,u,c),p=aM(g.y,g.x,t,i);f=Jx({x:g.x*s,y:g.y*s},{x:p.x,y:p.y})}var m=Mp(f,s,u,c),_=n.get(m.y,m.x,t);return{y:f.y,x:f.x,name:ss[t],score:_}}function Cq(r,e,t,n,i,s){var o=e.shape[2],a=Ep.length,l=new Array(o),u=r.part,c=r.score,h=lM(u,n,t);l[u.id]={score:c,name:ss[u.id],y:h.y,x:h.x};for(var f=a-1;f>=0;--f){var d=Ep[f],g=Zx[f];l[d]&&!l[g]&&(l[g]=ev(f,l[d],g,e,t,n,s))}for(f=0;f<a;++f)d=Zx[f],g=Ep[f],l[d]&&!l[g]&&(l[g]=ev(f,l[d],g,e,t,n,i));return l}function kq(r,e,t){return t.reduce(function(n,i,s){var o=i.y,a=i.x,l=i.score;return uM(r,e,{y:o,x:a},s)||(n+=l),n},0)/t.length}function Nq(r,e,t,n,i,s,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),kt(this,void 0,void 0,function(){var l,u,c,h,f,d,g,p,m,_,v,b;return Nt(this,function(x){switch(x.label){case 0:return[4,Iq([r,e,t,n])];case 1:for(l=x.sent(),u=l[0],c=l[1],h=l[2],f=l[3],d=[],g=function(T,I,C){for(var S=C.shape,A=S[0],R=S[1],F=S[2],q=new Mq(A*R*F,function(Z){return Z.score}),O=0;O<A;++O)for(var z=0;z<R;++z)for(var H=0;H<F;++H){var Q=C.get(O,z,H);Q<T||Aq(H,Q,O,z,I,C)&&q.enqueue({score:Q,part:{heatmapY:O,heatmapX:z,id:H}})}return q}(o,1,u),p=a*a;d.length<s&&!g.empty();)m=g.dequeue(),_=lM(m.part,i,c),uM(d,p,_,m.part.id)||(v=Cq(m,u,c,i,h,f),b=kq(d,p,v),d.push({keypoints:v,score:b}));return[2,d]}})})}const Ci=it();Ci.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),Ci.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),Ci.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),Ci.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1),Ci.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),Ci.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),Ci.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),Ci.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),Ci.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),Ci.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>0),Ci.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);class Rq{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}class Pq{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const i=tv(e,t);if(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(i).length>0){this.numFreeBuffers--;const o=this.freeBuffers.get(i).shift();return this.usedBuffers.get(i).push(o),o}this.numBytesAllocated+=e;const s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(i).push(s),s}releaseBuffer(e,t,n){if(this.freeBuffers.size===0)return;const i=tv(t,n);this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const s=this.usedBuffers.get(i),o=s.indexOf(e);if(o<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(o,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(e,t,n)},i=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function tv(r,e){return`${r}_${e}`}class Lq{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,i){const s=e*t*rv(n),o=nv(e,t,n,i);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;const l=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(l),l}this.numBytesAllocated+=s;const a=this.device.createTexture({size:[e,t],format:n,usage:i});return this.usedTextures.get(o).push(a),a}releaseTexture(e,t,n,i,s){if(this.freeTextures.size===0)return;const o=nv(t,n,i,s);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const u=t*n*rv(i);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function nv(r,e,t,n){return`${r}_${e}_${t}_${n}`}function rv(r){if(r==="rgba8unorm")return 16;throw new Error(r+" is not supported!")}function Dq(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const t=r.length,n=r.map(s=>`${e}[${s}]`),i=new Array(t-1);i[t-2]=n[t-1];for(let s=t-3;s>=0;--s)i[s]=`(${i[s+1]} * ${n[s+1]})`;return i}const jy=(r,e,t)=>t==="int32"?`atomicAdd(${r}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${r}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`,Oq=(r,e,t,n)=>{const i=function(o,a,l){const u=[],c=l.workgroupSize[0]*l.workgroupSize[1]*l.workgroupSize[2];if(u.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${hM(l)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${c}u +
                localIndex);
        `}
      }
    `),l.isFromPixels){u.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${Vu(a.dtype,l.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const v=av(l);return[sv,u.join(`
`),ov(a.shape),l.getUserCode(),iv(v,l)].join(`
`)}let h="struct Uniforms { NAN : f32, INFINITY : f32, ";l.variableNames.forEach((v,b)=>{const x=On(o[b].shape.length);h+=`${v.charAt(0).toLowerCase()+v.slice(1)}Shape : ${x}, `});const f=On(a.shape.length);h+=`outShape : ${f}, `;const d=On(a.shape.length-1);h+=`
         outShapeStrides: ${d}, `,l.size&&(h+="size : i32, "),l.uniforms&&(h+=l.uniforms),h+="};",h=function(v){return v=v.replace(/(\w+)\s*:\s*vec(5|6)/g,b=>"@align(16) "+b),v=v.replace(/vec(5|6)\s*,\s*(\w+)/g,(b,x,T)=>`vec${x}, @align(16) ${T}`)}(h),u.push(h),l.atomic?u.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):u.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Vu(a.dtype,l.isVec4)}>;
    `),l.variableNames.forEach((v,b)=>{u.push(`
      @group(0) @binding(${1+b}) var<storage, read> ${v}: array<${l.variableTypes?l.variableTypes[b]:Vu(o[b].dtype,l.isVec4)}>;
        `)}),h!==""&&u.push(`
      @group(0) @binding(${1+l.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const g=function(v,b){const{x,y:T=[],z:I=[]}=b,C=v.length,S=x.length+T.length+I.length;if(S!==C)return"";if(x.length===C)return`fn getOutputCoords() -> ${On(C)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let A="";const R=[x,T,I];for(let z=0;z<R.length;z++){const H=R[z];if(H.length!==0)if(H.length===1)A+=`let d${H[0]} = i32(globalId[${z}]);`;else{const Q=Dq(H,"uniforms.outShape");A+=`var index${z} = i32(globalId[${z}]);`;for(let Z=0;Z<Q.length;Z++)A+=`let d${H[Z]} = index${z} / ${Q[Z]};`,Z===Q.length-1?A+=`let d${H[Z+1]} = index${z} - d${H[Z]} * ${Q[Z]};`:A+=`index${z} = index${z} - d${H[Z]} * ${Q[Z]};`}}const F=[];for(let z=0;z<S;z++)F.push("d"+z);const q=On(S);let O=`fn getOutputCoords() -> ${q} {
  ${A}
`;return F.length===0?O+=`return ${q}(0); }`:O+=`return ${q}(${F.join(",")}); }`,O}(a.shape,l.dispatchLayout),p=[sv,u.join(`
`)+Fq,ov(a.shape),g,$q(a.shape.length)];l.atomic||p.push(function(v,b,x){const T=v.length,I=Vu(b,x);let C;if(C=x?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${I}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${I}(value);
    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${I}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${I}(value);
    }`,T>=2){const S=["d0","d1","d2","d3","d4","d5"].slice(0,T),A=On(T);C+=x?`
      fn setOutputAtCoords(${S.map(R=>R+" : i32").join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${A}(${S.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${S.map(R=>R+" : i32").join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${A}(${S.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:`
      fn setOutputAtCoords(${S.map(R=>R+" : i32").join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${A}(${S.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${S.map(R=>R+" : i32").join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${A}(${S.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return C}(a.shape,a.dtype,l.isVec4));const m=o.map((v,b)=>function(x,T,I,C){let S=function(A,R){const F=A.name,q=A.shape.length,O=On(q),z="get"+F.charAt(0).toUpperCase()+F.slice(1),H=["d0","d1","d2","d3","d4","d5"].slice(0,q),Q=H.map(fe=>fe+" : i32").join(", ");if(q<1)return R?`
        fn ${z}() -> vec4<f32> {
          return vec4<f32>(${F}[0]);
        }
      `:`
      fn ${z}() ->f32 {
        return f32(${F}[0]);
      }
    `;const Z=`uniforms.${F.charAt(0).toLowerCase()+F.slice(1)}Shape`;let Y=q+"D";return q===0&&(Y="1D"),R?`
      fn ${z}(${Q}) -> vec4<f32> {
        return vec4<f32>(${F}[getIndexFromCoords${Y}(${O}(${H.join(",")}),
          ${Z}) / 4]);
      }
      `:`
    fn ${z}(${Q}) -> f32 {
      return f32(${F}[getIndexFromCoords${Y}(${O}(${H.join(",")}),
        ${Z})]);
    }
   `}(x,I);return x.shape.length<=T.length&&(S+=function(A,R,F,q){const O=A.name,z=O.charAt(0).toUpperCase()+O.slice(1),H="get"+z+"ByOutput",Q=A.shape.length,Z=R.length,Y=On(Z);if(br(A.shape,R)&&q)return F?`
      fn ${H}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${O}[globalIndex]);
      }

      fn ${H}Coords(coords : ${Y}) -> vec4<f32> {
        return vec4<f32>(${O}[${Z>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${H}Index(globalIndex : i32) -> f32 {
      return f32(${O}[globalIndex]);
    }

    fn ${H}Coords(coords : ${Y}) -> f32 {
      return f32(${O}[${Z>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;const fe=lf(A.shape,R),le=Z-Q;let ve="";if(Q===0)return F?`
    fn ${H}Index(globalIndex : i32) -> vec4<f32> {
      return get${z}();
    }

    fn ${H}Coords(coords : ${Y}) -> vec4<f32> {
      return get${z}();
    }
  `:`
    fn ${H}Index(globalIndex : i32) -> f32{
      return get${z}();
    }

    fn ${H}Coords(coords : ${Y}) -> f32{
      return get${z}();
    }
  `;ve=Z<2&&fe.length>=1?"coords = 0;":fe.map(ne=>`coords.${ks(ne+le)} = 0;`).join(`
`);let ee="";if(Z<2&&Q>0)ee="coords";else if(Z>1){const ne=On(Q),Le=A.shape.map((Ve,He)=>"coords."+ks(He+le)).join(", ");ee=`${ne}(${Le})`}else ee="coords";const _e=`uniforms.${O.charAt(0).toLowerCase()+O.slice(1)}Shape`,Te=Q+"D";return F?`
    fn ${H}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${ve}
      return ${O}[getIndexFromCoords${Te}(${ee}, ${_e}) / 4];
    }

    fn ${H}Coords(coordsIn : ${Y}) -> vec4<f32> {
      var coords = coordsIn;
      ${ve}
      return ${O}[getIndexFromCoords${Te}(${ee}, ${_e}) / 4];
    }
  `:`
  fn ${H}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${ve}
    return f32(${O}[getIndexFromCoords${Te}(${ee}, ${_e})]);
  }

  fn ${H}Coords(coordsIn : ${Y}) -> f32 {
    var coords = coordsIn;
    ${ve}
    return f32(${O}[getIndexFromCoords${Te}(${ee}, ${_e})]);
  }
`}(x,T,I,C)),S}(v,a.shape,l.variableTypes?l.variableTypes[b]==="vec4<f32>":l.isVec4,l.dispatchLayout.x.length===a.shape.length)).join(`
`);p.push(m),p.push(l.getUserCode());const _=av(l);return p.push(iv(_,l)),p.join(`
`)}(t,{dtype:n.dtype,shape:n.shape},e),s=r.createShaderModule({code:i,label:e.constructor.name});return r.createComputePipeline({compute:{module:s,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})};function On(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function ks(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function Qe(...r){let e;switch(r.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function iv(r,e){let t;return t=`
     ${function(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r?"main(getGlobalIndex());":"main();"};
      }
    `,t}const sv=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Fq=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function ov(r){const e=r.length;if(e<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const t=yr(r),n=On(e),i=[];for(let o=0;o<e;o++)i.push("d"+o);if(t.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s;return s="var index2 = index;"+t.map((o,a)=>`${`let ${i[a]} = index2 / uniforms.outShapeStrides.${ks(a)}`}; ${a===t.length-1?`let ${i[a+1]} = index2 - ${i[a]} * uniforms.outShapeStrides.${ks(a)}`:`index2 = index2 - ${i[a]} * uniforms.outShapeStrides.${ks(a)}`};`).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${i.join(",")});
    }
  `}function $q(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:D(!1,()=>`Unsupported ${r}D shape`)}return e}function hM(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Vu(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function av(r){return(!r.dispatchLayout.hasOwnProperty("y")||r.dispatchLayout.y.length===0)&&(!r.dispatchLayout.hasOwnProperty("z")||r.dispatchLayout.z.length===0)}const ga=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function Ze(r,e,t=[1,1,1],n=[1,1,1]){const[i,s,o]=[Math.ceil(ga(r.x.map(a=>e[a]))/(t[0]*n[0])),r.y?Math.ceil(ga(r.y.map(a=>e[a]))/(t[1]*n[1])):1,r.z?Math.ceil(ga(r.z.map(a=>e[a]))/(t[2]*n[2])):1];return[i,s,o]}function fM(r,e,t=!1){if(t)return[8,8,1];const n=ga(r.x.map(s=>e[s])),i=ga(r.y.map(s=>e[s]));return n<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function dM(r,e,t=!1){if(t)return[4,4,1];const n=ga(r.x.map(s=>e[s])),i=ga(r.y.map(s=>e[s]));return n<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function st(r){return{x:r.map((e,t)=>t)}}function lv(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error("Unknown dtype "+r)}function pM(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}var Gi;(function(r){r[r.MatMulReduceProgram=0]="MatMulReduceProgram",r[r.MatMulSplitKProgram=1]="MatMulSplitKProgram",r[r.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",r[r.MatMulPackedProgram=3]="MatMulPackedProgram",r[r.MatMulMax=4]="MatMulMax"})(Gi||(Gi={}));const zq=it().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class Jl extends Z1{constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!pM())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new Rq(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Pq(this.device),this.textureManager=new Lq(this.device),this.tensorMap=new i$(this,Il()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),it().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return Jl.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:i}=this.tensorMap.get(e);return i!=null&&(this.disposeData(i.real.dataId,t),this.disposeData(i.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const n=t.resourceInfo;n.texture instanceof GPUTexture&&this.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage),n.texture=null}else{const n=t.resourceInfo;this.bufferManager.releaseBuffer(n.buffer,n.size,n.usage),n.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:n,shape:t,values:e,refCount:1}),i}move(e,t,n,i,s){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:n,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const i=n.getMappedRange().slice(0);return n.unmap(),n!=null&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),it().getBool("WEBGPU_USE_PROFILE_TOOL")&&(D(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let i;if(t.dtype==="complex64"){const s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=s[0],a=s[1];i=W5(o,a)}else{const s=t.resourceInfo,o=await this.getBufferData(s.buffer,s.size);i=p$(o,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e,t,n){const i=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,n){let i=e.buffer;if(n==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(s),a=lv(o.dtype)*ze(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(i=this.copyBuffer(i,a,i.usage)),o.resourceInfo={size:i.size,usage:i.usage,buffer:i},Il().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:i,shape:s,resourceInfo:o}=t;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o.size,l=this.bufferManager.acquireBuffer(a,o.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(o.buffer,0,l,0,a),this.submitQueue();const u=this.makeTensorInfo(s,i),c=Il().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resourceInfo={size:a,usage:this.defaultGpuBufferUsage(),buffer:l},{tensorRef:c,buffer:l,bufSize:a}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(i=>ql(i));return rn(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return rn(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Ea(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=Ea(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(s);return a.kernelMs=s$(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,n){return t==="string"&&n!=null&&n.length>0&&$f(n[0])&&(n=n.map(i=>pa(i))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const i=t.resourceInfo;return i.texture instanceof GPUExternalTexture?i.texture:i.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=lv(t.dtype)*ze(t.shape),i=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:i},t.values){const s=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),o=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),s.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s,0,i,0,n);const a={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:s};this.stagingPendingDisposal.push(a)}}makeUniforms(e){let t=0,n=0;const i=[];let s=1;e.forEach(u=>{let c;switch(u.data.length===0&&(u.data=[1]),u.data.length){case 1:c=4;break;case 2:c=8;break;case 3:case 4:case 5:case 6:c=16;break;default:D(!1,()=>`Unsupported ${u.data.length}D shape`)}n!==5&&n!==6||(c=16),c>s&&(s=c),t=Math.ceil(t/c)*c,n=u.data.length,i.push(t),t+=4*u.data.length}),t=Math.ceil(t/s)*s;const o=new ArrayBuffer(t);e.forEach((u,c)=>{const h=i[c];u.type==="int32"?new Int32Array(o,h,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(o,h,u.data.length).set(u.data):new Float32Array(o,h,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,o,0,t);const l={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(l),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,n,i,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),ze(s.shape)===0)return this.tensorMap.get(s.dataId).values=Es(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((p,m)=>{const _=p.limits.maxComputeWorkgroupsPerDimension,v=m.dispatchLayout,b=m.dispatch;if(b.every(T=>T<=_))return b;D(b[0]>_&&v.y===void 0&&v.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let x=Math.ceil(Math.sqrt(b[0]));return x>_?(x=Math.ceil(Math.cbrt(b[0])),D(x<=_,()=>"Total dispatch size exceeds WebGPU maximum."),[x,x,x]):[x,x,1]})(this.device,e);let o=[],a=[];if(!e.isFromPixels){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=t.concat(s).map(_=>_.shape);const p="int32";a.map(_=>{o.push({type:p,data:_})});const m=yr(s.shape);if(o.push({type:p,data:m}),e.size){const _=ze(e.outputShape);o.push({type:p,data:[e.isVec4?_/4:_]})}}const l=t.map((p,m)=>{if(p.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(p.dataId),{dtype:this.tensorMap.get(p.dataId).dtype,shape:p.shape,name:e.variableNames[m]}}),u=function(p,m,_,v){let b=p.shaderKey;if(p.isFromPixels)return b;const x=_.map(A=>A.dtype).concat(v.dtype),T=_.map(A=>lf(A.shape,v.shape)),I=_.map(A=>br(A.shape,v.shape)).join("_"),C=T.map(A=>A.join("_")).join(";"),S=hM(p)?"flatDispatch":"";return b+="_"+(p.workgroupSize?p.workgroupSize.join(","):"")+m.map(A=>A.length).join(",")+x.join(",")+p.variableNames.join(",")+C+I+S,b}(e,a,l,s);let c;u in this.pipelineCache?c=this.pipelineCache[u]:(c=Oq(this.device,e,l,s),this.pipelineCache[u]=c),i&&(o=[...o,...i]);const h=[this.tensorToBinding(s),...t.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)],f=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:h.map((p,m)=>({binding:m,resource:p}))});this.ensureCommandEncoderReady();const d=this.getComputePass(),g=this.activeTimers!=null;return g&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,0),d.setPipeline(c),d.setBindGroup(0,f),d.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),g&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(s.dataId),it().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),g&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const i=new BigUint64Array(n.getMappedRange()),s=Number(i[1]-i[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=zq){return it().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).resourceInfo==null&&ze(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var ct;Jl.nextDataId=0,pM()&&Jz("webgpu",async()=>{it().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const r={powerPreference:it().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t={};e.features.has("timestamp-query-inside-passes")&&(t.requiredFeatures=["timestamp-query-inside-passes"]);const n=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:n.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.maxStorageBufferBindingSize};const i=await e.requestDevice(t),s=await e.requestAdapterInfo();return new Jl(i,s)},3),function(r){r[r.ADD=0]="ADD",r[r.ATAN2=1]="ATAN2",r[r.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",r[r.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",r[r.DIV=4]="DIV",r[r.EQUAL=5]="EQUAL",r[r.GREATER=6]="GREATER",r[r.GREATER_EQUAL=7]="GREATER_EQUAL",r[r.INT_DIV=8]="INT_DIV",r[r.LESS=9]="LESS",r[r.LESS_EQUAL=10]="LESS_EQUAL",r[r.LOGICAL_AND=11]="LOGICAL_AND",r[r.LOGICAL_OR=12]="LOGICAL_OR",r[r.MAX=13]="MAX",r[r.MIN=14]="MIN",r[r.MOD=15]="MOD",r[r.MUL=16]="MUL",r[r.NOT_EQUAL=17]="NOT_EQUAL",r[r.POW=18]="POW",r[r.PRELU=19]="PRELU",r[r.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",r[r.SUB=21]="SUB"}(ct||(ct={}));const mM=`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `,Qf=`
  resultTemp = select(
      resultTemp, vec4<f32>(valueForNaN),
      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));
  `,Bq=`
  ${mM}
  if (b == 0.) {
    return uniforms.NAN;
  }
  var resultTemp = a % b;
  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {
    return resultTemp;
  } else {
    return (resultTemp + b) % b;
  }
`,Uq=`
  let isNaN = !vec4<bool>(b);
  let valueForNaN = uniforms.NAN;
  var resultTemp = vec4<f32>(a % b);
  ${Qf}

  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }

  return resultTemp;
`,Vq=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${Qf}

  return resultTemp;
`,Wq=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
  let valueForNaN = uniforms.NAN;
  ${Qf}
  return resultTemp;
`;function Ap(r,e,t="uniforms.NAN"){const n=e?Qf:mM;return e?`
    let valueForNaN = ${t};
    var resultTemp = vec4<f32>(${r}(a, b));
    `+n+`
    return resultTemp;
  `:n+`
    return ${r}(a, b);
  `}function qy(r,e){switch(r){case ct.ADD:return"return a + b;";case ct.ATAN2:return Ap("atan2",e);case ct.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case ct.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case ct.DIV:return"return a / b;";case ct.EQUAL:return e?"return vec4<f32>(a == b);":"return f32(a == b);";case ct.GREATER:return e?"return vec4<f32>(a > b);":"return f32(a > b);";case ct.GREATER_EQUAL:return e?"return vec4<f32>(a >= b);":"return f32(a >= b);";case ct.INT_DIV:return e?`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
`:`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
`;case ct.LESS:return e?"return vec4<f32>(a < b);":"return f32(a < b);";case ct.LESS_EQUAL:return e?"return vec4<f32>(a <= b);":"return f32(a <= b);";case ct.LOGICAL_AND:return e?`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`:"return f32(a >= 1.0 && b >= 1.0);";case ct.LOGICAL_OR:return e?`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`:"return f32(a >= 1.0 || b >= 1.0);";case ct.MAX:return Ap("max",e);case ct.MIN:return Ap("min",e);case ct.MOD:return e?Uq:Bq;case ct.MUL:return"return a * b;";case ct.NOT_EQUAL:return e?Vq:`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`;case ct.POW:return e?Wq:`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
`;case ct.PRELU:return e?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`:"if (a < 0.0) { return b * a; }  return a;";case ct.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case ct.SUB:return"return a - b;";default:throw new Error(`BinaryType ${r} is not implemented!`)}}var Re;(function(r){r[r.ABS=0]="ABS",r[r.ACOS=1]="ACOS",r[r.ACOSH=2]="ACOSH",r[r.ASIN=3]="ASIN",r[r.ASINH=4]="ASINH",r[r.ATAN=5]="ATAN",r[r.ATANH=6]="ATANH",r[r.CEIL=7]="CEIL",r[r.COS=8]="COS",r[r.COSH=9]="COSH",r[r.ELU=10]="ELU",r[r.ERF=11]="ERF",r[r.EXP=12]="EXP",r[r.EXPM1=13]="EXPM1",r[r.FLOOR=14]="FLOOR",r[r.IS_FINITE=15]="IS_FINITE",r[r.IS_INF=16]="IS_INF",r[r.IS_NAN=17]="IS_NAN",r[r.LINEAR=18]="LINEAR",r[r.LOG=19]="LOG",r[r.LOG1P=20]="LOG1P",r[r.LOGICAL_NOT=21]="LOGICAL_NOT",r[r.NEG=22]="NEG",r[r.RELU=23]="RELU",r[r.RELU6=24]="RELU6",r[r.LEAKYRELU=25]="LEAKYRELU",r[r.RECIPROCAL=26]="RECIPROCAL",r[r.ROUND=27]="ROUND",r[r.RSQRT=28]="RSQRT",r[r.SELU=29]="SELU",r[r.SIGMOID=30]="SIGMOID",r[r.SIGN=31]="SIGN",r[r.SIN=32]="SIN",r[r.SINH=33]="SINH",r[r.SOFTPLUS=34]="SOFTPLUS",r[r.SQRT=35]="SQRT",r[r.SQUARE=36]="SQUARE",r[r.STEP=37]="STEP",r[r.TAN=38]="TAN",r[r.TANH=39]="TANH",r[r.TO_INT=40]="TO_INT"})(Re||(Re={}));const Gq=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${F5};
  let a1 = ${$5};
  let a2 = ${z5};
  let a3 = ${B5};
  let a4 = ${U5};
  let a5 = ${V5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Hq=`
  if (a >= 0.0) {
    return ${O5} * a;
  } else {
    return ${D5} * (exp(a) - 1.0);
  }
`;function qo(r,e){switch(r){case Re.ABS:return"return abs(a);";case Re.ACOS:return`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`;case Re.ACOSH:return`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`;case Re.ASIN:return`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`;case Re.ASINH:return"return asinh(a);";case Re.ATAN:return`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`;case Re.ATANH:return`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`;case Re.COS:return"return cos(a);";case Re.COSH:return`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;case Re.CEIL:return"return ceil(a);";case Re.ELU:return e?`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`:"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Re.ERF:return Gq;case Re.EXP:return"return exp(a);";case Re.EXPM1:return"return exp(a) - 1.0;";case Re.FLOOR:return"return floor(a);";case Re.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case Re.IS_INF:return"return f32(isinf(a));";case Re.IS_NAN:return"return f32(isnan(a));";case Re.LINEAR:return"return a;";case Re.LOG:return`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`;case Re.LOG1P:return`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`;case Re.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Re.NEG:return"return -a;";case Re.LEAKYRELU:return e?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`:"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Re.RECIPROCAL:return"return 1.0 / a;";case Re.RELU:return e?`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`:"return select(a, 0.0, a < 0.0);";case Re.RELU6:return e?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Re.ROUND:return"return round(a);";case Re.RSQRT:return"return inverseSqrt(a);";case Re.SELU:return Hq;case Re.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Re.SIGN:return"return sign(a);";case Re.SIN:return"return sin(a);";case Re.SINH:return`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;case Re.SOFTPLUS:return`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`;case Re.SQRT:return"return sqrt(a);";case Re.SQUARE:return"return a * a;";case Re.STEP:return`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`;case Re.TAN:return"return tan(a);";case Re.TANH:return`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;case Re.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${r} is not implemented!`)}}const Sn=r=>{switch(r){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(r+"-component is not supported.")}};function Ws(r,e=!1,t=!1,n=3){if(r===null)return"";let i="";if(r==="linear")i=qo(Re.LINEAR);else if(r==="relu")i=qo(Re.RELU,t);else if(r==="elu")i=qo(Re.ELU,t);else if(r==="relu6")i=qo(Re.RELU6,t);else if(r==="prelu")i=qy(ct.PRELU,t);else if(r==="sigmoid")i=qo(Re.SIGMOID,t);else{if(r!=="leakyrelu")throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);i=qo(Re.LEAKYRELU,t)}const s=Sn(t?4:1);let o="";return o=e?`
      fn activation(a : ${s}, coords : vec${n}<i32>) -> ${s} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:`
      fn activation(a : ${s}, coords : vec${n}<i32>) -> ${s} {
        ${i}
      }`,o}function za(r,e){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}function gM(r,e,t=!1,n=!1,i=!1,s=1){D(r&&s===1||!r,()=>`transposeA ${r} is not compatible with component size ${s}`);const o=`
      ${r?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${Sn(s)} {
    var value = ${Sn(s)}(0.0);
    let col = colIn * ${s};
    ${t&&i?o:`
    ${r?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${Sn(s)} {
    let col = colIn * ${s};
    var value = ${Sn(s)}(0.0);
    ${a}
    return value;
  }
  `}function Ky(r,e,t,n,i=!1,s=!1,o=!1,a=1){return`
  ${gM(t,n,i,s,o,a)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Sn(a)}) {
    let col = colIn * ${a};
    ${i&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${za(r,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}function Jf(r,e,t=!1,n=32,i=!1,s=32,o=!1,a=!1){const l=e[1]*r[1],u=e[0]*r[0],c=t?l:n,h=t?n:l,f=c/e[0],d=n/e[1],g=r[1];return D((t&&f===4&&r[1]===4||!t&&(f===3||f===4))&&c%e[0]==0&&n%e[1]==0&&r[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${f} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${c/f}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/r[0]}>, ${n}>;

  ${Qe()} {
    let localRow = i32(localId.y);
    let tileRow = ${o?"0":"localRow * "+g};
    let tileCol = i32(localId.x);

    let globalRow = ${o?"0":"i32(globalId.y) * "+g};
    let globalCol = i32(globalId.x);
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${l};

    let numTiles = ${i?""+Math.ceil(s/n):`(uniforms.dimInner - 1) / ${n} + 1`};
    var kStart = ${i?"i32(globalId.z) * "+s:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${((p,m)=>p?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart / ${m} + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart / ${m} + inputCol);
        `)(t,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/f}; k++) {
            let BCached0 = mm_Bsub[k * ${f}][tileCol];
            let BCached1 = mm_Bsub[k * ${f} + 1][tileCol];
            let BCached2 = mm_Bsub[k * ${f} + 2][tileCol];
            ${f===3?"":`let BCached3 = mm_Bsub[k * ${f} + 3][tileCol];`}

            ${((p,m,_)=>p?`
        let ACached0 = mm_Asub[k * ${m}][localRow];
        let ACached1 = mm_Asub[k * ${m} + 1][localRow];
        let ACached2 = mm_Asub[k * ${m} + 2][localRow];
        ${m===3?"":`let ACached3 = mm_Asub[k * ${m} + 3][localRow];`}
        for (var i = 0; i < ${_}; i++) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${m===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < ${_}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${m===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(t,f,g)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const uv=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `;function ed(r,e,t=!1,n=32,i=!1,s=32,o=!1,a=!1){const l=r[1]*e[1],u=r[0]*e[0],c=t?l:n,h=t?n:l;D(h%e[1]==0&&c%e[0]==0&&n%e[1]==0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);const f=h/e[1],d=c/e[0],g=n/e[1],p=r[1],m=r[0],_=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${uv(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${m}>;
        for (var k = 0; k < ${n}; k++) {
          for (var inner = 0; inner < ${m}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${m}; innerCol++) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                  ACached * BCached[innerCol];
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${p};
  let tileCol = i32(localId.x) * ${m};

  let globalRow = i32(globalId.y) * ${p};
  let globalCol = i32(globalId.x) * ${m};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${g};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${uv(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
      for (var innerCol = 0; innerCol < ${m}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${n};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${m}>;
    for (var k = 0; k < ${n}; k++) {
      for (var inner = 0; inner < ${m}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        ${(v=>v?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(t)}
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${p}; innerRow++) {
    for (var innerCol = 0; innerCol < ${m}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${n}>;

    ${Qe()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?""+Math.ceil(s/n):`(uniforms.dimInner - 1) / ${n} + 1`};
      var kStart = ${i?"i32(globalId.z) * "+s:"0"};

      var acc : array<array<f32, ${m}>, ${p}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${_}
    }
  `}class jq{constructor(e,t,n=!1,i=!1,s=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!i,this.isVectorA=t[1]===1&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const f=function(d,g,p,m=!1){const _=[8,8,1],v=[4,4,1];return m||(d<=8&&(v[1]=1),g<=16&&p<=16&&(_[0]=4)),{workgroupSize:_,elementsPerThread:v}}(t[1],u,t[2],n);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=s!=null,h=a!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=n,this.transposeB=i,this.addBias=c,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const i=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s,[e%i==0,t%s==0,n%this.tileInner==0]}getUserCode(){return`
      ${Ws(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Ky(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Jf(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,t=!1){D(e[1]===1&&e[2]===1,()=>`A linear work group size is required. But got ${e}.`);const n=4*e[0];return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;

    ${Qe()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${(i=>i?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `)(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}(this.workgroupSize,this.transposeA):ed(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}class qq{constructor(e,t=!1,n=!1,i=null,s=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`
      ${Ws(this.activation,this.hasPreluActivationWeights)}
      ${Ky(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${e=this.workgroupSize[0],`
    var<workgroup> sumValues : array<f32, ${e}>;
    ${Qe()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${e}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${e/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}
    `}}class Kq{constructor(e,t,n,i=!1,s=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=o!=null;u&&this.variableNames.push("bias");const c=l!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=s,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${s}`}getUserCode(){return`
      ${Ws(this.activation,this.hasPreluActivationWeights)}
      ${Ky(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${function(e){const t=e[1],n=e[0],i=t>n?t:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${i}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${i}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Qe()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${i} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${i};
    globalRowB = globalRowB + ${i};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${i};
      globalRowB = globalRowB + ${i};

      for (var k = 0; k < ${i}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}(this.workgroupSize)}
    `}}class Xq{constructor(e,t,n=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,D(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Ze(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=i,this.shaderKey=`matMulSplitK_${n}_${i}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1;return`
      ${gM(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${Sn(e)}) {
        let col = colIn * ${e};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${jy("&result[flatIndex + i]",e>1?"value[i]":"value","float32")}
          }
        }
      }
      ${this.isVec4?Jf(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):ed(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Yq{constructor(e,t=null,n=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=i!=null,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_"+n}getUserCode(){return`
    ${Ws(this.activation,this.hasPreluActivationWeights)}
    ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${za(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}class Zq{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Qe("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}function Gs(r){const{backend:e,attrs:t}=r,{shape:n,value:i}=t;let{dtype:s}=t;if(s=s||zf(i),s==="string"){const o=Wn(s,ze(n));return o.fill(i),e.makeTensorInfo(n,s,o)}{const o=new Zq(n),a=[{type:"float32",data:[i]}];return e.runWebGPUProgram(o,[],s,a)}}const Qq={kernelName:HS,backendName:"webgpu",kernelFunc:Gs};function et(r){const{inputs:e,attrs:t}=r,{x:n}=e,{shape:i}=t,s=ze(n.shape),o=o$(i,s),a=ze(o);return D(s===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:o,dtype:n.dtype}}const Jq={kernelName:zT,backendName:"webgpu",kernelFunc:et};function gf({a:r,b:e,transposeA:t,transposeB:n,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=r.shape.length,c=e.shape.length,h=t?r.shape[u-2]:r.shape[u-1],f=n?e.shape[c-1]:e.shape[c-2],d=t?r.shape[u-1]:r.shape[u-2],g=n?e.shape[c-2]:e.shape[c-1],p=r.shape.slice(0,-2),m=e.shape.slice(0,-2),_=ze(p),v=ze(m),b=Zt(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,g]);D(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);const x=t?[_,h,d]:[_,d,h],T=n?[v,g,f]:[v,f,g],I=et({inputs:{x:r},backend:i,attrs:{shape:x}}),C=et({inputs:{x:e},backend:i,attrs:{shape:T}}),S=[I,C],A=Math.max(_,v),R=[I,C],F=[{type:"int32",data:[d]},{type:"int32",data:[g]},{type:"int32",data:[h]}];let q,O;const z=[A,d,g];let H=it().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(H<0){const Z=it().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),Y=Z>0?Z:i.thresholdToIncreaseWorkgroups,fe=A*Math.ceil(d/32)*Math.ceil(g/32);H=fe<=Y||d<=8&&fe<=2*Y?A*d*g<=128?Gi.MatMulReduceProgram:A===1&&f>=2e3?Gi.MatMulSplitKProgram:Gi.MatMulSmallOutputSizeProgram:Gi.MatMulPackedProgram}switch(H){case Gi.MatMulReduceProgram:q=new qq(z,t,n,s,l,o);break;case Gi.MatMulSplitKProgram:if(O=Gs({backend:i,attrs:{shape:z,value:0,dtype:r.dtype}}),q=new Xq(z,f,t,n),s||l){O=i.runWebGPUProgram(q,R,r.dtype,F,O);const Y=new Yq(O.shape,s,l,o);let fe=null;const le=[O];s&&le.push(s),o&&le.push(o),l==="leakyrelu"&&(fe=[{type:"float32",data:[a]}],Y.uniforms+=" alpha : f32,");const ve=i.runWebGPUProgram(Y,le,O.dtype,fe);S.push(O);const ee=et({inputs:{x:ve},backend:i,attrs:{shape:b}});S.push(ve);for(const _e of S)i.disposeData(_e.dataId);return ee}break;case Gi.MatMulSmallOutputSizeProgram:q=new Kq(x,T,z,t,n,s,l,o);break;case Gi.MatMulPackedProgram:const Z=i.adapterInfo.isIntel();q=new jq(x,z,t,n,s,l,o,Z);break;default:throw new Error(`Unsupported MatMulProgramType ${H}.`)}s&&R.push(s),o&&R.push(o),l==="leakyrelu"&&(F.push({type:"float32",data:[a]}),q.uniforms+=" alpha : f32,"),O=i.runWebGPUProgram(q,R,r.dtype,F,O);const Q=et({inputs:{x:O},backend:i,attrs:{shape:b}});S.push(O);for(const Z of S)i.disposeData(Z.dataId);return Q}const e7={kernelName:Em,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{a:i,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=n;return gf({a:i,b:s,transposeA:l,transposeB:u,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}};class cv{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Zt(t,n),this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${qy(this.op,!1)}
      }

      ${Qe("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}class pg{constructor(e,t,n){this.size=!0,this.variableNames=["A","B"],this.outputShape=Zt(t,n),this.dispatchLayout=st(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(br(t,n)&&ze(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      let isNaN = false;
      {
        ${qy(this.op,this.isVec4)}
      }
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;e=`
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Qe("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${n}
       ${Qe("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}function Rr(r){const{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const t7={kernelName:xy,backendName:"webgpu",kernelFunc:Rr};function Ba(r){const{inputs:e,backend:t}=r,{real:n,imag:i}=e,s=t.makeTensorInfo(n.shape,"complex64"),o=t.tensorMap.get(s.dataId),a=Rr({inputs:{x:n},backend:t}),l=Rr({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},s}const n7={kernelName:vS,backendName:"webgpu",kernelFunc:Ba};class fu{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,n!==""&&(this.uniforms=n),this.shaderKey="unary_"+t}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${qo(this.op,!1)}
      }
      ${Qe("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}function Pt({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:n,backend:i})=>{const{x:s}=n,o=i,a=t||s.dtype;if(o.shouldExecuteOnCPU([s])&&e!=null){const u=o.tensorMap.get(s.dataId),c=e(u.values,a);return o.makeTensorInfo(s.shape,a,c)}const l=new fu(s.shape,r);return o.runWebGPUProgram(l,[s],a)}}function Pn({opType:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:n}){return({inputs:i,backend:s})=>{const{a:o,b:a}=i,l=s;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),f=l.tensorMap.get(a.dataId);let d,g;if(r!==ct.MUL)[d,g]=[[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(m=>{const[_,v]=m,b={dataId:_.dataId,dtype:_.dtype,shape:o.shape},x={dataId:v.dataId,dtype:v.dtype,shape:a.shape},T=new pg(r,o.shape,a.shape);return l.runWebGPUProgram(T,[b,x],Ma(_.dtype,v.dtype))});else{const m=new cv(ct.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),_=new cv(ct.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),v=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}];d=l.runWebGPUProgram(m,v,"float32"),g=l.runWebGPUProgram(_,v,"float32")}const p=Ba({inputs:{real:d,imag:g},backend:l});return l.disposeData(d.dataId),l.disposeData(g.dataId),p}const u=n||Ma(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,f=l.tensorMap.get(a.dataId).values,d=o.dtype==="string"?ff(h):h,g=o.dtype==="string"?ff(f):f,[p,m]=e(o.shape,a.shape,d,g,u);return l.makeTensorInfo(m,u,p)}const c=new pg(r,o.shape,a.shape);return l.runWebGPUProgram(c,[o,a],u)}}function Qr(r){return(e,t,n,i,s)=>{const o=Zt(e,t),a=o.length,l=yr(o),u=ze(o),c=Es(s,u),h=e.length,f=t.length,d=yr(e),g=yr(t),p=lf(e,o),m=lf(t,o);if(p.length+m.length===0)for(let _=0;_<c.length;++_)c[_]=r(n[_%n.length],i[_%i.length]);else for(let _=0;_<c.length;++_){const v=Sm(_,a,l),b=v.slice(-h);p.forEach(C=>b[C]=0);const x=wm(b,h,d),T=v.slice(-f);m.forEach(C=>T[C]=0);const I=wm(T,f,g);c[_]=r(n[x],i[I])}return[c,o]}}const r7=Qr((r,e)=>r+e);function No(r){return(e,t,n)=>{const i=Es(t,e.length);for(let s=0;s<e.length;++s)i[s]=r(e[s],n);return i}}const i7=No(r=>Math.ceil(r)),s7=Qr((r,e)=>r===e?1:0),o7=No(r=>Math.exp(r)),a7=No(r=>Math.expm1(r)),l7=No(r=>Math.floor(r)),u7=Qr((r,e)=>r>e?1:0),c7=Qr((r,e)=>r>=e?1:0),h7=Qr((r,e)=>r<e?1:0),f7=Qr((r,e)=>r<=e?1:0),d7=No(r=>Math.log(r)),p7=Qr((r,e)=>Math.max(r,e)),m7=Qr((r,e)=>Math.min(r,e)),hv=Qr((r,e)=>r*e),g7=Qr((r,e)=>r!==e?1:0);function y7(r,e,t,n){const i=[];let s=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);(function(u,c){for(let h=0;h<u.length;++h){const f=u[h],d=h===u.length-1?c:u[h+1].length;if(f.length===0)throw new Error("Ragged splits may not be empty");if(f[0]<0)throw new Error("Ragged splits must be non-negative");if(f[f.length-1]>d)throw new Error("Ragged splits must not point past values");for(let g=1;g<f.length;++g)if(f[g-1]>f[g])throw new Error("Ragged splits must be sorted in ascending order")}})(t,n);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<r.length;++u){let c=r[u],h=r[u]+1;for(let f=0;f<t.length;++f){const d=t[f],g=f+e.length-1;if(g>=0){const p=a[g],m=p[p.length-1]-d[c];for(let _=c;_<h;++_)a[g].push(d[_+1]+m)}c=d[c],h=d[h]}h!==c&&(i.push([c,h]),s+=h-c)}return{outSplits:a,valueSlices:i,numValues:s}}function fv(r,e){const t=r.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<r.length;n++)t[e-1]*=r[n];return t}function _7(r,e,t,n,i){const s=e.slice();s[0]=i;const o=Wn(t,ze(s)),a=r.length;return function(l,u,c,h,f,d){const g=fv(u,2)[1],p=fv(d,2)[1];let m=0;for(const _ of c)for(let v=_[0];v<_[1];++v){for(let b=0;b<h;++b)f[m*p+b]=l[v*g+b];++m}}(r,e,n,a===0?0:a/e[0],o,s),[o,s]}var ii=Ki;class yf{constructor(e,t,n,i,s,o,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=i,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=C5(c),this.raggedRank=k5(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ii.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ii.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ii.VALUE_ROWIDS:return yf.getMaxWidthValueRowID(t);case ii.ROW_SPLITS:return yf.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type "+ii[this.getRowPartitionTypeByDimension(e-1)])}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let n=0;for(let i=0;i<t-1;++i){const s=e[i+1]-e[i];s>n&&(n=s)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let n=0,i=e[0],s=0;for(let o=1;o<t;++o){const a=e[o];a!==i&&(i=a,s=Math.max(o-n,s),n=o)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return pv(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;N5(n,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=I5(this.raggedRank,i,t);s[0]<0&&(s[0]=e);for(let o=1;o<=this.raggedRank;++o)s[o]<0&&(s[o]=this.getMaxWidth(o));return s}calculateFirstParentOutputIndex(e,t,n){const i=Math.min(e,n),s=[];let o=0;for(let a=0;a<i;++a,o+=t)s.push(o);for(let a=i;a<e;++a)s.push(-1);return D(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,i){const s=e.length,o=[];for(let a=0;a<s-1;++a){const l=e[a+1]-e[a];let u=Math.min(i,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)o.push(c),c+=n;for(let h=0;h<l-u;++h)o.push(-1)}if(s>0&&o.length!==e[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,i){const s=e.length,o=[];if(s===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];o.push(u);for(let c=1;c<s;++c){const h=e[c];if(h===l)u>=0&&(++a,a<i?u+=n:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,i){const s=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case ii.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,i);case ii.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,i);default:throw new Error("Unsupported partition type: "+ii[o])}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ii.FIRST_DIM_SIZE:return e[0];case ii.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ii.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+ii[t])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const i=pv(t,!1),s=Wn(this.valuesDType,ze(i));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let a=1;a<=this.raggedRank;++a)o=this.calculateOutputIndex(a-1,o,n[a],t[a]);this.setOutput(this.raggedRank,o,s,i)}return[i,s]}setOutput(e,t,n,i){if(n.length===0)return;const s=this.values,o=n;let a=i.slice();a=a.slice(e+1);const l=ze(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const g=this.defaultValueShape;ht(()=>{const p=ye(c,g);c=Ju(p,a).dataSync()})}let h=0,f=0,d=0;for(let g=0;g<=u;++g){let p=g<u?t[g]:-1;if(p!==d){if(f<d){const m=s.subarray(h*l);dv(o.subarray(f*l),m,(d-f)*l)}if(g>=u){const m=n.length;p=Math.floor(m/l)}if(p>d)if(this.defaultValue.length===1)o.subarray(d*l,p*l).fill(this.defaultValue[0]),d=p;else for(;p>d;)dv(o.slice(d*l),c,l),++d;p<0?(h=g+1,f=d):(h=g,f=d,d=f+1)}else++d}}}function dv(r,e,t){for(let n=0;n<t;n++)r[n]=e[n]}function pv(r,e){const t=[];for(let n of r){if(n<0){if(!e)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}t.push(n)}return t}const b7=No(r=>1/Math.sqrt(r)),x7=No(r=>1/(1+Math.exp(-r))),v7=No(r=>Math.sqrt(r)),w7=Qr((r,e)=>{const t=r-e;return t*t});class S7{constructor(e,t,n,i,s,o){this.separator=pa(e),this.nGramWidths=t,this.leftPad=pa(n),this.rightPad=pa(i),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,i,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),h=o-(u+c),f=t+(u>0?0:a-l);let d=0;d+=u*this.leftPad.length;for(let _=0;_<h;++_)d+=e[f+_].length;d+=c*this.rightPad.length,d+=(u+c+h-1)*this.separator.length,n[i+a]=new Uint8Array(d);const g=n[i+a];let p=0;const m=_=>_.forEach(v=>g[p++]=v);for(let _=0;_<u;++_)m(this.leftPad),m(this.separator);for(let _=0;_<h-1;++_)m(e[f+_]),m(this.separator);if(h>0){m(e[f+h-1]);for(let _=0;_<c;++_)m(this.separator),m(this.rightPad)}else{for(let _=0;_<c-1;++_)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error("First split value must be 0, got "+l);for(let u=1;u<i;++u){let c=t[u]>=l;if(c=c&&t[u]<=n,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${n}]`);l=t[u]}if(l!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${l}`)}const s=i-1,o=Wn("int32",i);if(n===0||i===0){const l=new Array(n);for(let u=0;u<=s;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[s]);for(let l=0;l<s;++l){const u=t[l];let c=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],d=this.getNumNGrams(f,h);this.createNGrams(e,u,a,c,d,h),c+=d}),this.preserveShort&&c===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth,d=1;this.createNGrams(e,u,a,c,d,f)}}return[a,o]}}function T7(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){const s=e[0];let o=r.indexOf(s);for(;o!==-1;){const a=r.subarray(0,o);t&&a.length===0||n.push(a),o=(r=r.subarray(o+1)).indexOf(s)}return void(t&&r.length===0||n.push(r))}let i=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){const o=r.subarray(i,s);t&&o.length===0||n.push(o),i=s+1}}const E7=Qr((r,e)=>r-e),Wu=(r,e)=>{const t=e.value-r.value;return t===0?r.index-e.index:t};function yM(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){const a=n-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);yM(r,e,Math.max(t,Math.floor(e-l*c/a+h)),Math.min(n,Math.floor(e+(a-l)*c/a+h)))}const i=r[e];let s=t,o=n;for(Nu(r,t,e),Wu(r[n],i)>0&&Nu(r,t,n);s<o;){for(Nu(r,s,o),s++,o--;Wu(r[s],i)<0;)s+=1;for(;Wu(r[o],i)>0;)o-=1}Wu(r[t],i)===0?Nu(r,t,o):(o+=1,Nu(r,o,n)),o<=e&&(t=o+1),e<=o&&(n=o-1)}}var M7=Object.freeze({__proto__:null,simpleAbsImpl:function(r){const e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e},addImpl:r7,bincountImpl:function(r,e,t,n,i){const s=ze(n),o=xs(i,t);for(let a=0;a<r.length;a++){const l=r[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(o[l]+=s>0?e[a]:1)}return o},bincountReduceImpl:function(r,e,t,n=!1){const i=r.shape[0],s=r.shape[1],o=rn([i,t],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<s;l++){const u=r.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(n?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o},castImpl:function(r,e,t,n){if(n==="int32")return[e,"int32",Int32Array.from(r)];if(n==="bool"){const i=Uf([0],t),[s,o]=Qr((a,l)=>a!==l?1:0)(e,[],r,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${n}`)},ceilImpl:i7,concatImpl:function(r,e,t,n){const i=Wn(t,ze(e));if(n&&t!=="string"){let s=0;r.forEach(o=>{const a=ze(o.shape);i.set(o.vals,s),s+=a})}else{let s=0;r.forEach(o=>{const a=t==="string"?ff(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+s;for(let h=0;h<o.shape[1];++h)i[c+h]=a[l++]}s+=o.shape[1]})}return i},equalImpl:s7,expImpl:o7,expm1Impl:a7,floorImpl:l7,gatherNdImpl:function(r,e,t,n,i,s,o,a,l){const u=rn([n,s],t);for(let c=0;c<n;c++){const h=[];let f=0;for(let d=0;d<i;d++){const g=r[c*i+d];f+=g*o[d],h.push(g)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<s;d++)u.values[c*s+d]=e.get(...e.indexToLoc(f*s+d))}return u},gatherV2Impl:function(r,e,t){const n=rn(t,r.dtype);for(let i=0;i<n.size;++i){const s=n.indexToLoc(i).slice(),o=s[0],a=s[2],l=e.locToIndex([o,a]);s[2]=e.values[l];const u=r.locToIndex(s);0<=u&&u<r.values.length&&(n.values[i]=r.values[u])}return n},greaterImpl:u7,greaterEqualImpl:c7,lessImpl:h7,lessEqualImpl:f7,linSpaceImpl:function(r,e,t){const n=(e-r)/(t-1),i=xs(t,"float32");i[0]=r;for(let s=1;s<i.length;s++)i[s]=i[s-1]+n;return i},logImpl:d7,maxImpl:function(r,e,t,n){const i=Es(n,ze(t));for(let s=0;s<i.length;++s){const o=s*e;let a=r[o];for(let l=0;l<e;++l){const u=r[o+l];(Number.isNaN(u)||u>a)&&(a=u)}i[s]=a}return i},maximumImpl:p7,minimumImpl:m7,multiplyImpl:hv,negImpl:function(r,e,t){const n=ez(-1,t);return hv([],e,n,r,t)},notEqualImpl:g7,prodImpl:function(r,e,t,n){const[i,s]=Hf(r,n),o=Ma(e,"int32"),a=xs(ze(i),o),l=ze(s);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let f=0;f<l;++f)h*=t[c+f];a[u]=h}return{outVals:a,outShape:i,outDtype:o}},raggedGatherImpl:function(r,e,t,n,i,s,o,a){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");if(function(g,p,m){g.forEach((_,v)=>{if(_<0||_>=m){const b=Sm(v,p.length,yr(p)).join(",");throw new Error(`indices[${b}] = ${_} is not in [0, ${m})`)}})}(s,o,e[0][0]-1),n.length===0)throw new Error("params.rank must be nonzero");const l=n[0],{outSplits:u,valueSlices:c,numValues:h}=y7(s,o,r,l),f=function(g){const p=[];for(let m=0;m<g.length;++m){const _=g[m].length,v=Wn("int32",_);p.push(v),g[m].forEach((b,x)=>v[x]=b)}return p}(u),d=_7(t,n,i,c,h);return[f,d[0],d[1]]},raggedRangeImpl:function(r,e,t,n,i,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=i.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(i[0]),u||c.push(o[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],f=Wn("int32",h+1);f[0]=0;for(let m=0;m<h;++m){const _=a?r[0]:r[m],v=l?n[0]:n[m],b=u?s[0]:s[m];if(b===0)throw new Error("Requires delta != 0");let x;if(b>0&&v<_||b<0&&v>_)x=0;else if(x=Math.ceil(Math.abs((v-_)/b)),x>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");f[m+1]=f[m]+x}const d=f[h],g=Wn(t,d);let p=0;for(let m=0;m<h;++m){const _=f[m+1]-f[m];let v=a?r[0]:r[m];const b=u?s[0]:s[m];for(let x=0;x<_;++x)g[p++]=v,v+=b}return[f,g]},raggedTensorToTensorImpl:function(r,e,t,n,i,s,o,a,l,u){return new yf(r,e,t,n,i,s,o,a,l,u).compute()},rangeImpl:function(r,e,t,n){if(r===e||r<e&&t<0||e<r&&t>1)return xs(0,n);const i=Math.abs(Math.ceil((e-r)/t)),s=xs(i,n);e<r&&t===1&&(t=-1),s[0]=r;for(let o=1;o<s.length;o++)s[o]=s[o-1]+t;return s},rsqrtImpl:b7,scatterImpl:function(r,e,t,n,i,s,o,a,l,u){const c=[n/i,i],h=r.values,f=e.values;if(n===0)return rn(t,e.dtype);const d=rn(c,e.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let g=0;g<s;g++){const p=[];let m=0;for(let _=0;_<o;_++){const v=h[g*o+_];p.push(v),m+=v*a[_]}if(m<0||m>=n/i)throw new Error(`Invalid indices: ${p} does not index into ${t}`);for(let _=0;_<i;_++)u?d.values[m*i+_]+=f[g*i+_]:d.values[m*i+_]=e.rank===0?f[0]:f[g*i+_]}return d},sigmoidImpl:x7,sliceImpl:function(r,e,t,n,i){const s=w5(n,e,t),o=ze(t),a=yr(n);if(s){const h=S5(e,a);return i==="string"?r.slice(h,h+o):r.subarray(h,h+o)}const l=i==="string"?ff(r):r,u=rn(n,i,l),c=rn(t,i);for(let h=0;h<c.size;++h){const f=c.indexToLoc(h),d=f.map((g,p)=>g+e[p]);c.set(u.get(...d),...f)}return i==="string"?c8(c.values):c.values},sparseFillEmptyRowsImpl:function(r,e,t,n,i,s,o){const a=e[0],l=s[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(Q5(a));return[Wn(t,0),[0,h],Wn(i,0),u,c]}let f=!0,d=0;const g=new Array(l).fill(0);for(let m=0;m<a;++m){const _=r[m*h];if(_<0)throw new Error(J5(m,_));if(_>=l)throw new Error(e8(m,_,l));++g[_],f=f&&_>=d,d=_}let p=!0;for(let m=0;m<l;++m){const _=g[m]===0;u[m]=_,p=p&&!_,g[m]=Math.max(g[m],1),m>0&&(g[m]+=g[m-1])}if(p&&f){const m=r,_=n;for(let v=0;v<a;++v)c[v]=v;return[m,[a,h],_,u,c]}{const m=g[l-1],_=Wn(t,m*h),v=Wn(i,m),b=new Array(l).fill(0);for(let x=0;x<a;++x){const T=r[x*h],I=b[T],C=(T===0?0:g[T-1])+I;b[T]++;for(let S=0;S<h;++S)_[C*h+S]=r[x*h+S];v[C]=n[x],c[x]=C}for(let x=0;x<l;++x)if(b[x]===0){const T=x===0?0:g[x-1];_[T*h+0]=x;for(let I=1;I<h;++I)_[T*h+I]=0;v[T]=o}return[_,[m,h],v,u,c]}},sparseReshapeImpl:function(r,e,t,n,i){const s=ze(n),o=e[0],a=i.length,l=[];let u=1,c=-1;for(let p=0;p<a;++p){const m=i[p];if(m===-1){if(c!==-1)throw new Error(t8(c,p));c=p,l.push(1)}else{if(m<0)throw new Error(n8(p,m));u*=m,l.push(m)}}if(c!==-1){if(u<=0)throw new Error(r8());const p=Math.trunc(s/u);if(u*p!==s)throw new Error(i8(n,l));l[c]=p}if(ze(l)!==s)throw new Error(s8(n,l));const h=n.length,f=[];if(h>0){f[h-1]=1;for(let p=h-2;p>=0;--p)f[p]=f[p+1]*n[p+1]}const d=[];if(a>0){d[a-1]=1;for(let p=a-2;p>=0;--p)d[p]=d[p+1]*l[p+1]}const g=Wn(t,o*a);for(let p=0;p<o;++p){let m=0;for(let _=0;_<h;++_)m+=r[p*h+_]*f[_];for(let _=0;_<a;++_)g[p*a+_]=Math.trunc(m/d[_]),m%=d[_]}return[g,[o,a],l]},sparseSegmentReductionImpl:function(r,e,t,n,i,s=!1,o=0){const a=n.length,l=[e[0],r.length/e[0]],u=l[1],c=a>0?i[a-1]+1:0;if(c<0)throw new Error(vx());const h=e.slice();h[0]=c;const f=h.reduce((v,b)=>v*b,1),d=Wn(t,f);if(a===0)return c>0&&d.fill(o),[d,h];if(c<=0)throw new Error(vx());let g=0,p=1,m=0,_=i[g];for(;;){let v=0;if(p<a){if(v=i[p],_===v){++p;continue}if(_>=v)throw new Error(o8())}if(_<0||_>=c)throw new Error(a8(_,c));_>m&&d.fill(o,m*u,_*u);for(let b=g;b<p;++b){const x=n[b];if(x<0||x>=l[0])throw new Error(l8(b,n[b],l[0]));for(let T=0;T<u;T++)d[_*u+T]+=r[x*u+T]}if(s)for(let b=0;b<u;b++)d[_*u+b]/=p-g;if(g=p,++p,m=_+1,_=v,p>a)break}return m<c&&d.fill(o,m*u,c*u),[d,h]},sqrtImpl:v7,squaredDifferenceImpl:w7,stridedSliceImpl:function(r,e,t,n){const i=rn(r,e.dtype);for(let s=0;s<i.size;s++){const o=i.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+n[l];i.set(e.get(...a),...o)}return i},stringNGramsImpl:function(r,e,t,n,i,s,o,a){return new S7(t,n,i,s,o,a).compute(r,e)},stringSplitImpl:function(r,e,t){const n=r.length,i=[];let s=0,o=0;const a=new Array(n);for(let f=0;f<n;++f){const d=i.length;T7(r[f],e,t,i);const g=i.length-d;a[f]=g,s+=g,o=Math.max(o,g)}const l=Wn("int32",2*s),u=new Array(s),c=[n,o];let h=0;for(let f=0;f<n;++f)for(let d=0;d<a[f];++d)l[2*h]=f,l[2*h+1]=d,u[h]=i[h],++h;return[l,u,c]},stringToHashBucketFastImpl:function(r,e){const t=Wn("int32",r.length);for(let n=0;n<r.length;++n)t[n]=J$(r[n]).modulo(e).getLowBitsUnsigned();return t},subImpl:E7,tileImpl:function(r,e){const t=new Array(r.rank);for(let i=0;i<t.length;i++)t[i]=r.shape[i]*e[i];const n=rn(t,r.dtype);for(let i=0;i<n.values.length;++i){const s=n.indexToLoc(i),o=new Array(r.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%r.shape[l];const a=r.locToIndex(o);n.values[i]=r.values[a]}return n},topKImpl:function(r,e,t,n,i){const s=e[e.length-1],[o,a]=[r.length/s,s],l=Es(t,o*n),u=Es("int32",o*n);for(let h=0;h<o;h++){const f=h*a,d=r.subarray(f,f+a);let g=new Array(d.length);d.forEach((v,b)=>g[b]={value:v,index:b}),n<g.length&&(yM(g,n),g=g.slice(0,n)),i&&g.sort(Wu);const p=h*n,m=l.subarray(p,p+n),_=u.subarray(p,p+n);for(let v=0;v<n;v++)m[v]=g[v].value,_[v]=g[v].index}const c=e.slice();return c[c.length-1]=n,[rn(c,t,l),rn(c,"int32",u)]},transposeImpl:function(r,e,t,n,i){const s=e.length,o=ze(e),a=yr(e),l=yr(i),u=Es(t,ze(i));for(let c=0;c<o;++c){const h=Sm(c,s,a),f=new Array(h.length);for(let d=0;d<f.length;d++)f[d]=h[n[d]];u[wm(f,s,l)]=r[c]}return u},uniqueImpl:function(r,e,t,n){const i=Yr(e,t)[0],s=[1,t[0],1];for(let g=0;g<i;g++)s[0]*=t[g];s[1]=t[i];for(let g=i+1;g<t.length;g++)s[2]*=t[g];const o={},a=new Int32Array(t[i]),l=new vc(s,n,r),u=[],c=s[0]===1&&s[2]===1;for(let g=0;g<t[i];g++){let p;if(c)p=r[g].toString();else{const m=[];for(let _=0;_<s[0];_++)for(let v=0;v<s[2];v++)m.push(l.get(_,g,v));p=m.join(",")}if(o[p]!==void 0)a[g]=o[p];else{const m=Object.keys(o).length;o[p]=m,a[g]=m,u.push(g)}}const h=s.slice();h[1]=Object.keys(o).length;const f=new vc(h,n);u.forEach((g,p)=>{for(let m=0;m<s[0];m++)for(let _=0;_<s[2];_++)f.set(l.get(m,g,_),m,p,_)});const d=t.slice();return d[i]=h[1],{outputValues:f.values,outputShape:d,indices:a}}});const{addImpl:A7,castImpl:I7,ceilImpl:C7,concatImpl:k7,equalImpl:N7,expImpl:R7,expm1Impl:P7,floorImpl:L7,gatherNdImpl:D7,gatherV2Impl:O7,greaterEqualImpl:F7,greaterImpl:$7,lessEqualImpl:z7,lessImpl:B7,logImpl:U7,maxImpl:V7,maximumImpl:W7,minimumImpl:G7,multiplyImpl:H7,negImpl:j7,notEqualImpl:q7,prodImpl:K7,rangeImpl:X7,rsqrtImpl:Y7,scatterImpl:Z7,simpleAbsImpl:Q7,sliceImpl:J7,stridedSliceImpl:eK,stringNGramsImpl:tK,subImpl:nK,tileImpl:rK,topKImpl:iK,transposeImpl:sK,uniqueImpl:PY}=M7,oK={kernelName:nS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ABS,cpuKernelImpl:Q7})},aK={kernelName:rS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ACOS})},lK={kernelName:iS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ACOSH})},uK={kernelName:_y,backendName:"webgpu",kernelFunc:Pn({opType:ct.ADD,cpuKernelImpl:A7,supportsComplex:!0})};class cK{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,n)=>"T"+n),this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(n=>{e.push(`let v${n} = get${n}ByOutputCoords(coords);`)});const t=this.variableNames.map(n=>"v"+n).join(" + ");return`
      ${Qe("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}const hK={kernelName:sS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,n=e;if(n.length===1)return Rr({inputs:{x:n[0]},backend:t});const i=n.map(a=>a.dtype).reduce((a,l)=>Ma(a,l)),s=n.map(a=>a.shape),o=new cK(s);return t.runWebGPUProgram(o,n,i)}};class fK{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){D(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Qe()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}class dK{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_"+t}getUserCode(){const e=On(this.outputShape.length),t=function(n){const i=n.length;if(i>6)throw Error(`Transpose for rank ${i} is not yet supported`);const s=new Array(i);for(let o=0;o<n.length;o++)s[n[o]]="resRC."+ks(o);return s.join()}(this.newDim);return`
      ${Qe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function zs(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{perm:s}=n,o=t,a=i.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=i.shape[s[c]];if(t.shouldExecuteOnCPU([i])){const c=o.tensorMap.get(i.dataId).values,h=sK(c,i.shape,i.dtype,s,l);return t.makeTensorInfo(l,i.dtype,h)}if(i.shape.length===2&&br(s,[1,0])){const c=new fK(i.shape,s);return o.runWebGPUProgram(c,[i],i.dtype)}const u=new dK(i.shape,s);return o.runWebGPUProgram(u,[i],i.dtype)}const pK={kernelName:Lh,backendName:"webgpu",kernelFunc:zs};class mK{constructor(e,t){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[n]=Hf(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_"+t}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${n}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Qe("index")} {
         let outputIndex = index / ${n};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${n}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${n}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}function Ua(r,e,t,n,i){const s=r.shape.length,o=[],a=Yr(e,r.shape);let l=a;const u=jf(l,s);let c=r;u!=null&&(c=zs({inputs:{x:r},attrs:{perm:u},backend:i}),l=qf(l.length,s),o.push(c)),Ay(n,l,s);const[h,f]=Hf(c.shape,l);let d,g=h;if(t&&(g=cu(h,a)),n!=="max"&&n!=="prod"||!i.shouldExecuteOnCPU([c])){const p=ze(f),m={windowSize:p,inSize:p,batchSize:ze(c.shape)/p,outSize:1},_=n==="mean"?"float32":dz(r.dtype),v=[{type:"int32",data:[p]}],b=new mK(m,n),x=i.runWebGPUProgram(b,[c],_,v);o.push(x),d=et({inputs:{x},attrs:{shape:g},backend:i})}else{const p=i.tensorMap.get(c.dataId).values;switch(n){case"max":const m=V7(p,ze(f),g,r.dtype);d=i.makeTensorInfo(g,r.dtype,m);break;case"prod":const{outVals:_,outShape:v,outDtype:b}=K7(c.shape,c.dtype,p,l);d=i.makeTensorInfo(v,b,_);break;default:throw new Error(n+" CPU implementation is not yet supported.")}}return o.forEach(p=>i.disposeData(p.dataId)),d}const gK={kernelName:oS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{keepDims:s,axis:o}=n;return Ua(i,o,s,"all",t)}},yK={kernelName:aS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{keepDims:s,axis:o}=n;return Ua(i,o,s,"any",t)}};class _M{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op=n==="min"?"<":">";const[s,o]=Hf(e,i);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=st(this.outputShape),ze(o)<32||ze(s)>1e3?(this.type="plain",this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Ze(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":"uniforms.xShape."+ks(this.inputShape.length-1),n=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let s=0;s<this.outputShape.length;s++)i+=`outputCoords.${ks(s)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Qe("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${n()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${n()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${n()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}const _K={kernelName:lS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s}=n;let o=Yr(s,i.shape);const a=jf(o,i.shape.length);let l=i;const u=[];a!=null&&(l=zs({inputs:{x:i},backend:t,attrs:{perm:a}}),u.push(l),o=qf(o.length,l.shape.length)),Ay("argMax",[o[0]],l.shape.length);const c=new _M(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=t.runWebGPUProgram(c,[l],"int32",h);return u.forEach(d=>t.disposeData(d.dataId)),f}},bK={kernelName:uS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s}=n;let o=Yr(s,i.shape);const a=jf(o,i.shape.length);let l=i;const u=[];a!=null&&(l=zs({inputs:{x:i},backend:t,attrs:{perm:a}}),u.push(l),o=qf(o.length,l.shape.length)),Ay("argMin",[o[0]],l.shape.length);const c=new _M(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=t.runWebGPUProgram(c,[l],"int32",h);return u.forEach(d=>t.disposeData(d.dataId)),f}},xK={kernelName:cS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ASIN})},vK={kernelName:hS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ASINH})},wK={kernelName:fS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ATAN})},SK={kernelName:pS,backendName:"webgpu",kernelFunc:Pn({opType:ct.ATAN2})},TK={kernelName:dS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ATANH})};class mv{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="pool2D_"+t,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputAtIndex(index, ${t});
        }
      }
    `}}class EK{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}function Xy(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{reductionIndices:s,keepDims:o}=n;return Ua(i,s,o,"max",t)}const MK={kernelName:mT,backendName:"webgpu",kernelFunc:Xy};function bM(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{keepDims:s,axis:o}=n;return Ua(i,o,s,"mean",t)}const AK={kernelName:_T,backendName:"webgpu",kernelFunc:bM};function xM(r,e,t,n){if(e.filterWidth===1&&e.filterHeight===1&&br(e.inShape,e.outShape))return Rr({inputs:{x:r},backend:n});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=r.shape.length,a=et({inputs:{x:r},backend:n,attrs:{shape:[r.shape[o-3]*r.shape[o-2],r.shape[o-1]]}});let l;t==="avg"?l=bM({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}}):(D(t==="max",()=>"Invalid pool type "+t),l=Xy({inputs:{x:a},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));const u=et({inputs:{x:l},backend:n,attrs:{shape:e.outShape}});return n.disposeData(a.dataId),n.disposeData(l.dataId),u}let i;const s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?i=new EK(e):(t==="avg"?i=new mv(e,"avg"):(D(t==="max",()=>"Invalid pool type "+t),i=new mv(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),n.runWebGPUProgram(i,[r],r.dtype,s)}const IK={kernelName:mS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=n;return xM(i,Vf(i.shape,s,o,1,a,l),"avg",t)}};class CK{constructor(e){this.variableNames=["dy"],this.uniforms=`stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}getUserCode(){return`
      ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}const kK={kernelName:v$,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{dy:i,input:s}=e,o=s;var a,l;a=[i,s],l="avgPoolGrad",Array.isArray(a)||(a=[a]),a.forEach(m=>{m!=null&&D(m.dtype!=="complex64",()=>l+" does not support complex64 tensors in the WebGPU backend.")});const{filterSize:u,strides:c,pad:h}=n,f=Vf(o.shape,u,c,1,h),d=new CK(f),g=1/(f.filterHeight*f.filterWidth),p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[g]}];return t.runWebGPUProgram(d,[i],o.dtype,p)}},NK={kernelName:gS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{a:i,b:s}=e,{transposeA:o,transposeB:a}=n;return gf({a:i,b:s,transposeA:o,transposeB:a,backend:t})}};class RK{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${On(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=On(this.rank),t=function(i){if(i===1)return"sourceLoc";if(i<=6)return Ip.slice(0,i).map(s=>"sourceLoc."+s).join(",");throw Error(`Slicing for rank ${i} is not yet supported`)}(this.rank);let n;return n=this.start.length===1?this.outputShape.map((i,s)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((i,s)=>`sourceLoc.${Ip[s]} = uniforms.start.${ks(s)} + coords.${Ip[s]};`),`
      ${Qe("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const Ip=["x","y","z","w","u","v"];function du(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{begin:s,size:o}=n,[a,l]=T5(i,s,o);if(x5(i,a,l),t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.tensorMap.get(i.dataId),f=J7(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,f)}if(ze(l)===0)return t.makeTensorInfo(l,i.dtype,[]);const u=new RK(a,l),c=[{type:"int32",data:a}];return t.runWebGPUProgram(u,[i],i.dtype,c)}const PK={kernelName:YT,backendName:"webgpu",kernelFunc:du},LK={kernelName:yS,backendName:"webgpu",kernelFunc:r=>{const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{blockShape:s,crops:o}=n;D(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=s.reduce((v,b)=>v*b),l=UE(i.shape,s,a),u=VE(l.length,s.length),c=WE(i.shape,s,a),h=P5(o,s.length),f=L5(c,o,s.length),d=[],g=et({inputs:{x:i},backend:t,attrs:{shape:l}}),p=zs({inputs:{x:g},backend:t,attrs:{perm:u}}),m=et({inputs:{x:p},backend:t,attrs:{shape:c}}),_=du({inputs:{x:m},backend:t,attrs:{begin:h,size:f}});return d.push(g),d.push(p),d.push(m),d.forEach(v=>t.disposeData(v.dataId)),_}},DK=`
  fn bincount_write(index: i32, value: f32) {
    ${jy("&result[index]","value","float32")}
  }
`;class vM{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`:DK}
  ${Qe("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}const OK={kernelName:_S,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,weights:s}=e,{size:o}=n,a=ze(i.shape),l=ze(s.shape)>0,u=[o],c=s.dtype,h=Gs({backend:t,attrs:{shape:u,value:0,dtype:c}}),f=new vM([a],l),d=[{type:"int32",data:[o]}],g=l?[i,s]:[i];return t.runWebGPUProgram(f,g,c,d,h)}},wM=Pn({opType:ct.NOT_EQUAL,dtype:"bool",cpuKernelImpl:q7}),FK={kernelName:ET,backendName:"webgpu",kernelFunc:wM};function Fc(r){const{inputs:e,backend:t}=r,{input:n}=e;return Rr({inputs:{x:t.tensorMap.get(n.dataId).complexTensorInfos.real},backend:t})}const $K={kernelName:OT,backendName:"webgpu",kernelFunc:Fc},zK={kernelName:by,backendName:"webgpu",kernelFunc:function r(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{dtype:o}=i;if(o==="complex64"){if(s.dtype==="complex64")return Rr({inputs:{x:s},backend:n});const a=Mo(s.shape),l=r({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=Ba({inputs:{real:l,imag:a},backend:n});return a.dispose(),n.disposeData(l.dataId),u}if(s.dtype==="complex64"){const a=Fc({inputs:{input:s},backend:n}),l=r({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeData(a.dataId),l}if(!c$(s.dtype,o)){const a=Rr({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const a=n.tensorMap.get(s.dataId).values,[l,u,c]=I7(a,s.shape,s.dtype,o);return n.makeTensorInfo(l,u,c)}if(o==="int32")return function(a,l){const u=new fu(a.shape,Re.TO_INT),c=l.runWebGPUProgram(u,[a],"int32");return{dataId:c.dataId,shape:c.shape,dtype:c.dtype}}(s,n);if(o==="bool"){const a=n.makeTensorInfo([],"bool",Es("bool",1)),l=wM({inputs:{a:s,b:a},backend:n});return n.disposeData(a.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},BK={kernelName:bS,backendName:"webgpu",kernelFunc:Pt({opType:Re.CEIL,cpuKernelImpl:C7})};class UK{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Qe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}class VK{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Qe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}const WK={kernelName:xS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{clipValueMin:s,clipValueMax:o}=n;let a;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return a=ze(i.shape)%4==0?new UK(i.shape):new VK(i.shape),t.runWebGPUProgram(a,[i],i.dtype,l)}};class GK{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=tc(e,1),this.variableNames=e.map((t,n)=>"T"+n),this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Qe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}function td(r){const{inputs:e,backend:t}=r,{input:n}=e;return Rr({inputs:{x:t.tensorMap.get(n.dataId).complexTensorInfos.imag},backend:t})}const HK={kernelName:tT,backendName:"webgpu",kernelFunc:td};function Gu(r,e,t){const n=r[0].dtype;if(n==="complex64"){const g=r.map(b=>Fc({inputs:{input:b},backend:t})),p=r.map(b=>td({inputs:{input:b},backend:t})),m=Gu(g,e,t),_=Gu(p,e,t),v=Ba({inputs:{real:m,imag:_},backend:t});return g.forEach(b=>t.disposeData(b.dataId)),p.forEach(b=>t.disposeData(b.dataId)),t.disposeData(m.dataId),t.disposeData(_.dataId),v}let i=t.shouldExecuteOnCPU(r);if(n==="string"&&(i=!0),i){const g=r.map(T=>{const I=ze(T.shape.slice(e));return et({inputs:{x:T},backend:t,attrs:{shape:[-1,I]}})}),p=g.map(T=>({vals:t.readSync(T.dataId),shape:T.shape})),m=tc(g.map(T=>T.shape),1),_=g[0].shape[0]===1,v=k7(p,m,n,_),b=tc(r.map(T=>T.shape),e),x=t.makeTensorInfo(b,n,v);return g.forEach(T=>t.disposeData(T.dataId)),x}const s=t.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){const g=[];for(let m=0;m<r.length;m+=s){const _=r.slice(m,m+s);g.push(Gu(_,e,t))}const p=Gu(g,e,t);for(const m of g)t.disposeData(m.dataId);return p}const{tensors2D:o,outShape:a}=function(g,p,m){const _=tc(g.map(v=>v.shape),p);return{tensors2D:g.map(v=>et({inputs:{x:v},backend:m,attrs:{shape:[ze(v.shape.slice(0,p)),ze(v.shape.slice(p))]}})),outShape:_}}(r,e,t),l=o.map(g=>g.shape),u=new GK(l),c=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],c.push({type:"int32",data:[h[0]]});for(let g=1;g<h.length;g++)h[g]=h[g-1]+l[g][1],c.push({type:"int32",data:[h[g]]})}const f=t.runWebGPUProgram(u,o,o[0].dtype,c);o.forEach(g=>t.disposeData(g.dataId));const d=et({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),d}function SM(r){const{inputs:e,backend:t,attrs:n}=r,{axis:i}=n,s=Yr(i,e[0].shape)[0],o=e.map(u=>u.shape);A5(o,s);const a=tc(e.map(u=>u.shape),s);if(ze(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>ze(u.shape)>0);return l.length===1?Rr({inputs:{x:l[0]},backend:t}):Gu(l,s,t)}const jK={kernelName:wS,backendName:"webgpu",kernelFunc:SM};class qK{constructor(e,t,n,i,s=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=fM(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=dM(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),a&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=s,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=i%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Jf(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):ed(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${function(n,i,s,o,a=!1,l=null,u=!1,c=4,h=4,f=4){const d=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=n?"uniforms.xShape[1]":"uniforms.xShape[2]",m=n?"uniforms.xShape[2]":"uniforms.xShape[3]",_=n?"row":"col",v=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${_} / outWidth;
      let outCol = ${_} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${v} % inChannels;
      var resData = ${Sn(c)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${m}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${(A=>{switch(A){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${A} is not supported.`)}})(c)}
      }
      return resData;`,x=n?i&&o?`
      let col = colIn * ${c};
      ${b}`:`
      let col = colIn * ${c};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Sn(c)}(0.0);`:o&&s?`
      let col = colIn * ${c};
      ${b}`:`
      let col = colIn * ${c};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Sn(c)}(0.0);`,T=""+(A=>{switch(A){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${A} is not supported.`)}})(h),I=Sn(f),C=Sn(n?c:h),S=Sn(n?h:c);return`
      ${Ws(l,u,f===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${C} {
        ${n?x:T}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${S} {
        ${n?T:x}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${I}) {
        let col = colIn * ${f};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${za(a,l)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}class KK{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Ws(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${za(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Qe("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}class XK{constructor(e,t){this.variableNames=["x"],this.uniforms=`pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Qe("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];
        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -
              uniforms.pad[1];
          let xCol = offsetX + uniforms.dilation[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}function wh(r,e){const t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function TM({x:r,filter:e,convInfo:t,backend:n,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=i!=null,u=s!=null,c=t.dataFormat==="channelsLast",h=c&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=it().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return function({x:I,filter:C,convInfo:S,backend:A,bias:R=null,preluActivationWeights:F=null,leakyreluAlpha:q=0,activation:O=null}){const z=S.dataFormat==="channelsLast",H=!z,Q=[];let Z,Y;if(z&&S.filterHeight===S.inHeight&&S.filterWidth===S.inWidth&&S.padInfo.type==="VALID"){const ve=S.inHeight*S.inWidth*S.inChannels;Z=et({inputs:{x:I},backend:A,attrs:{shape:[1,S.batchSize,ve]}}),Y=et({inputs:{x:C},backend:A,attrs:{shape:[1,ve,S.outChannels]}})}else Z=et({inputs:{x:I},backend:A,attrs:{shape:z?[S.batchSize,S.inHeight*S.inWidth,S.inChannels]:[S.batchSize,S.inChannels,S.inHeight*S.inWidth]}}),Y=et({inputs:{x:C},backend:A,attrs:{shape:[1,S.inChannels,S.outChannels]}});if(Q.push(Z),Q.push(Y),F!=null){const ve=wh(F.shape,z);ve!=null&&(F=et({inputs:{x:F},backend:A,attrs:{shape:ve}}),Q.push(F))}if(R!=null){const ve=wh(R.shape,z);ve!=null&&(R=et({inputs:{x:R},backend:A,attrs:{shape:ve}}),Q.push(R))}const fe=gf({a:z?Z:Y,b:z?Y:Z,transposeA:H,transposeB:!1,backend:A,bias:R,activation:O,preluActivationWeights:F,leakyreluAlpha:q}),le=et({inputs:{x:fe},backend:A,attrs:{shape:S.outShape}});Q.push(fe);for(const ve of Q)A.disposeData(ve.dataId);return le}({x:r,filter:e,convInfo:t,backend:n,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});const d=it().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),g=d>0?d:n.thresholdToIncreaseWorkgroups,p=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(it().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||p<=g)return function({x:I,filter:C,convInfo:S,backend:A,bias:R=null,preluActivationWeights:F=null,leakyreluAlpha:q=0,activation:O=null}){const{filterWidth:z,filterHeight:H,inChannels:Q,strideWidth:Z,strideHeight:Y,padInfo:fe,outWidth:le,outHeight:ve,dilationWidth:ee,dilationHeight:_e,dataFormat:Te}=S,ne=Te==="channelsLast",Le=z*H*Q,Ve=ve*le,He=ne?[S.batchSize,Ve,Le]:[S.batchSize,Le,Ve],We=new XK(He,ne),Je=[{type:"int32",data:[fe.top,fe.left]},{type:"int32",data:[Y,Z]},{type:"int32",data:[_e,ee]},{type:"int32",data:[le]},{type:"int32",data:[Q*z]},{type:"int32",data:[Q]}],nt=A.runWebGPUProgram(We,[I],I.dtype,Je),U=[];U.push(nt);const j=et({inputs:{x:C},backend:A,attrs:{shape:[1,Le,-1]}});if(U.push(j),F!=null){const de=wh(F.shape,ne);de!=null&&(F=et({inputs:{x:F},backend:A,attrs:{shape:de}}),U.push(F))}if(R!=null){const de=wh(R.shape,ne);de!=null&&(R=et({inputs:{x:R},backend:A,attrs:{shape:de}}),U.push(R))}const ae=gf({a:ne?nt:j,b:ne?j:nt,transposeA:!ne,transposeB:!1,backend:A,bias:R,activation:O,preluActivationWeights:F,leakyreluAlpha:q}),be=et({inputs:{x:ae},backend:A,attrs:{shape:S.outShape}});U.push(ae);for(const de of U)A.disposeData(de.dataId);return be}({x:r,filter:e,convInfo:t,backend:n,bias:i,preluActivationWeights:s,leakyreluAlpha:o,activation:a});let m;const _=[t.padInfo.top,t.padInfo.left],v=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[..._]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(f)m=new KK(t,l,a,u);else{const I=c?t.outHeight*t.outWidth:t.outChannels,C=c?t.outChannels:t.outHeight*t.outWidth,S=t.filterHeight*t.filterWidth*t.inChannels;v.push({type:"int32",data:[I]},{type:"int32",data:[C]},{type:"int32",data:[S]});const A=n.adapterInfo.isIntel();m=new qK(t,I,C,S,l,a,u,A)}const b=[],x=[r,e];l&&(c||i.shape.length!==1||(i=et({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}}),b.push(i)),x.push(i)),u&&(c||s.shape.length!==1||(s=et({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}}),b.push(s)),x.push(s)),a==="leakyrelu"&&(v.push({type:"float32",data:[o]}),m.uniforms+=" alpha : f32,");const T=n.runWebGPUProgram(m,x,r.dtype,v);for(const I of b)n.disposeData(I.dataId);return T}const YK={kernelName:SS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,attrs:t,backend:n}=r,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=t,h=uu(l);return TM({x:i,filter:s,convInfo:as(i.shape,s.shape,o,u,a,c,!1,h),backend:n})}};class ZK{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey="conv2DDerInput_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${Qe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class QK{constructor(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey="conv2DDerFilter_"+this.isChannelsLast}getUserCode(){return`
    ${Qe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}const JK={kernelName:TS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=n,h=uu(l),f=as(i.shape,c,o,1,a,u,!1,h),d=new QK(f),g=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return t.runWebGPUProgram(d,[i,s],i.dtype,g)}};class e9{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,D(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=fM(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=dM(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Jf(this.elementsPerThread,this.workgroupSize):ed(this.elementsPerThread,this.workgroupSize);return`
    ${function(t=4){const n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Sn(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Sn(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${Sn(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Sn(t)} {
    let col = colIn * ${t};
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Sn(t)} {
    let col = colIn * ${t};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${(i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}})(t)}
    }
    return ${Sn(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${Sn(t)}) {
    let col = colIn * ${t};
    if (row < uniforms.dimAOuter && (col + ${t-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}(this.isVec4?4:1)}
    ${e}
    `}}const t9={kernelName:ES,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{dy:i,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=n,h=uu(u),f=as(o,s.shape,a,1,l,c,!1,h),d=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let g;if(it().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&f.inChannels===1)g=new ZK(f);else{g=new e9(f);const p=f.inHeight*f.inWidth,m=f.inChannels,_=f.filterHeight*f.filterWidth*f.outChannels;d.push({type:"uint32",data:[p]},{type:"uint32",data:[m]},{type:"uint32",data:[_]})}return t.runWebGPUProgram(g,[i,s],"float32",d)}},n9={kernelName:MS,backendName:"webgpu",kernelFunc:Pt({opType:Re.COS})},r9={kernelName:AS,backendName:"webgpu",kernelFunc:Pt({opType:Re.COSH})};class i9{constructor(e,t,n,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,i,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+e],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+t];return`
    ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}const s9={kernelName:kS,backendName:"webgpu",kernelFunc:r=>{const{inputs:e,backend:t,attrs:n}=r,{image:i,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=n,c=new i9(i.shape[3],s.shape,a,l),h=[{type:"float32",data:[u]}];return t.runWebGPUProgram(c,[i,s,o],"float32",h)}};var kc;(function(r){r.Prod="*",r.Sum="+"})(kc||(kc={}));class gv{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===kc.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${yv(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let s="",o="";return this.exclusive?(s=this.reverse?"end != "+(i-1):"end != 0",o=this.reverse?"end + 1":"end - 1"):(s=this.reverse?"end + pow2 < "+i:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${Qe("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${_v(e,"coords",this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${o};
           ${_v(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${yv(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function yv(r,e,t){if(r===1)return""+e;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function _v(r,e,t){if(r===1)return""+e;if(r===2)return e+".y";if(r===3)return e+".z";if(r===4)return e+".w";throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function EM(r,e,t,n,i,s){const o=e.shape.length,a=jf([n],o);let l=e;a!=null&&(l=zs({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=qf(1,o)[0];if(u!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=`+n);const c=l.shape[u];let h=Rr({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){const d=new gv(r,l.shape,!1,s),g=h,p=[{type:"float32",data:[f]}];h=t.runWebGPUProgram(d,[h],h.dtype,p),t.disposeData(g.dataId)}if(i){const f=new gv(r,l.shape,i,s),d=h,g=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(f,[h],h.dtype,g),t.disposeData(d.dataId)}if(a!=null){const f=zs({inputs:{x:h},backend:t,attrs:{perm:n4(a)}});return t.disposeData(h.dataId),t.disposeData(l.dataId),f}return h}const o9={kernelName:IS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s,exclusive:o,reverse:a}=n;return EM(kc.Prod,i,t,s,o,a)}},a9={kernelName:CS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s,exclusive:o,reverse:a}=n;return EM(kc.Sum,i,t,s,o,a)}},l9={kernelName:NS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,weights:s}=e,{size:o,binaryOutput:a}=n,l=i.shape.length===1,u=ze(s.shape)>0,c=s.dtype,h=l?[i.shape[0]]:[i.shape[0],i.shape[1]],f=Gs({backend:t,attrs:{shape:l?[o]:[i.shape[0],o],value:0,dtype:c}}),d=new vM(h,u,a),g=[{type:"int32",data:[o]}],p=u?[i,s]:[i];return t.runWebGPUProgram(d,p,c,g,f)}};class u9{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_"+t,this.dataFormat=t}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const c9={kernelName:RS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{blockSize:s,dataFormat:o}=n,a=i.shape[0],l=(o==="NHWC"?i.shape[1]:i.shape[2])*s,u=(o==="NHWC"?i.shape[2]:i.shape[3])*s,c=(o==="NHWC"?i.shape[3]:i.shape[1])/(s*s),h=[{type:"int32",data:[s]}],f=new u9(o==="NHWC"?[a,l,u,c]:[a,c,l,u],o);return t.runWebGPUProgram(f,[i],i.dtype,h)}};class h9{constructor(e,t,n,i=!1,s=null,o=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=s,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Ws(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Qe()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${za(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}class MM{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),D(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`
      ${Ws(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Qe()} {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * ${this.workPerThread};
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${za(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}class AM{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Ws(this.activation,this.hasPreluActivation,!1,4)}

      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilation[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilation[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${za(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}const f9={kernelName:PS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=n,h=uu(l);let f=u;f==null&&(f=[1,1]);const d=as(i.shape,s.shape,o,f,a,c,!0,h),g=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],p=d.dataFormat==="channelsLast";let m;return!p&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?m=new h9(d.outShape,d.filterHeight,d.filterWidth):p&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4==0?m=new MM(d):(m=new AM(d),g.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(m,[i,s],i.dtype,g)}};class d9{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}const p9={kernelName:LS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{x:n}=e,i=[...n.shape,...n.shape],s=ze(n.shape),o=et({inputs:{x:n},backend:t,attrs:{shape:[s]}}),a=new d9(s),l=t.runWebGPUProgram(a,[o],o.dtype),u=et({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeData(o.dataId),t.disposeData(l.dataId),u}};class m9{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Qe("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilation[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilation[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}const g9={kernelName:DS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=n,u=IB(i.shape,s.shape,o,a,"NHWC",l),c=[u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]}],f=new m9(u);return t.runWebGPUProgram(f,[i,s],i.dtype,h)}},IM=Pn({opType:ct.MUL,cpuKernelImpl:H7,supportsComplex:!0}),y9={kernelName:ST,backendName:"webgpu",kernelFunc:IM};function Yy(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s,keepDims:o}=n;return Ua(i,s,o,"sum",t)}const _9={kernelName:r2,backendName:"webgpu",kernelFunc:Yy},b9={kernelName:FS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{equation:i}=n,s=e,{allDims:o,summedDims:a,idDims:l}=H5(i,s.length);q5(o.length,l,s);const{path:u,steps:c}=K5(a,l),h=c.length;let f=null,d=o.length;const g=[];for(let p=0;p<h;++p){for(const m of c[p]){const{permutationIndices:_,expandDims:v}=j5(d,l[m]);let b;X5(_)?b=s[m]:(b=zs({inputs:{x:s[m]},backend:t,attrs:{perm:_}}),g.push(b));const x=b.shape.slice();for(let T=0;T<v.length;++T)x.splice(v[T],0,1);br(b.shape,x)||(b=et({inputs:{x:b},backend:t,attrs:{shape:x}}),g.push(b)),f===null?f=b:(f=IM({inputs:{a:b,b:f},backend:t}),g.push(f))}p<h-1&&(u[p]>=0&&(f=Yy({inputs:{x:f},backend:t,attrs:{axis:u[p]-(o.length-d),keepDims:!1}}),g.push(f)),d--)}for(const p of g)p!==f&&t.disposeData(p.dataId);return f}},x9={kernelName:$S,backendName:"webgpu",kernelFunc:Pt({opType:Re.ELU})},v9={kernelName:BS,backendName:"webgpu",kernelFunc:Pn({opType:ct.EQUAL,dtype:"bool",cpuKernelImpl:N7})},w9={kernelName:zS,backendName:"webgpu",kernelFunc:Pt({opType:Re.ERF})},CM=Pt({opType:Re.EXP,cpuKernelImpl:R7,dtype:"float32"}),S9={kernelName:US,backendName:"webgpu",kernelFunc:CM};function mg(r){const{inputs:e,attrs:t,backend:n}=r,{dim:i}=t,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(D(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),et({inputs:{x:s},backend:n,attrs:{shape:a}})}const T9={kernelName:VS,backendName:"webgpu",kernelFunc:mg},E9={kernelName:WS,backendName:"webgpu",kernelFunc:Pt({opType:Re.EXPM1,cpuKernelImpl:P7})};class bv{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_"+e}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}function kM(r,e,t){const n=t.tensorMap.get(r.dataId),i=ze(r.shape),s=r.shape[r.shape.length-1],o=[],a=et({inputs:{x:r},backend:t,attrs:{shape:[i/s,s]}});o.push(a);const l=a.shape,u=new bv("real",l),c=new bv("imag",l),h=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],f=[{type:"float32",data:[e?2*Math.PI:-2*Math.PI]},{type:"float32",data:[e?l[1]:1]}],d=t.runWebGPUProgram(u,h,"float32",f);o.push(d);const g=t.runWebGPUProgram(c,h,"float32",f);o.push(g);const p=Ba({inputs:{real:d,imag:g},backend:t});o.push(p);const m=et({inputs:{x:p},backend:t,attrs:{shape:r.shape}});return o.forEach(_=>t.disposeData(_.dataId)),m}const M9={kernelName:GS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{input:n}=e;return kM(n,!1,t)}};class A9{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}const I9={kernelName:jS,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{const{image:t}=r,n=e,i=new A9(t.shape);return n.runWebGPUProgram(i,[t],t.dtype)}},C9={kernelName:qS,backendName:"webgpu",kernelFunc:Pt({opType:Re.FLOOR,cpuKernelImpl:L7})},k9={kernelName:KS,backendName:"webgpu",kernelFunc:Pn({opType:ct.INT_DIV,dtype:"int32"})};class N9{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_"+this.importVideo}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Qe("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}const R9={kernelName:Tm,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r;let{pixels:i}=e;const{numChannels:s}=n;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,u=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[c,h]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],f=[h,c,s],d=o||a;if(u||l||d){let _;{if(d){const F=it().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");ol!=null&&F===Cp||(Cp=F,ol=document.createElement("canvas").getContext("2d",{willReadFrequently:Cp})),ol.canvas.width=c,ol.canvas.height=h,ol.drawImage(i,0,0,c,h),i=ol.canvas}const S=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,A="rgba8unorm",R=t.textureManager.acquireTexture(f[1],f[0],A,S);t.queue.copyExternalImageToTexture({source:i},{texture:R},[f[1],f[0]]),_={width:c,height:h,format:A,usage:S,texture:R}}const v=ze(f),b=yr(f),x=new N9(f,s,!1),T=[{type:"uint32",data:[v]},{type:"uint32",data:[s]},{type:"uint32",data:[...b]}],I=t.makeTensorInfo([h,c],"int32");t.tensorMap.get(I.dataId).resourceInfo=_;const C=t.runWebGPUProgram(x,[I],"int32",T);return t.disposeData(I.dataId),C}const g=i.data;let p=g;if(s!=null&&s!==4){p=new Uint8Array(i.width*i.height*s);const _=g.length;let v=0;for(let b=0;b<_;b++)b%4<s&&(p[v++]=g[b])}const m=t.makeTensorInfo(f,"int32",new Int32Array(p));return t.uploadToGPU(m.dataId),m}};let ol,Cp=it().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class P9{constructor(e,t,n,i,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Zt(e,t),Zt(e,n),this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(Zt(e,i),this.variableNames.push("offset")),s!=null&&(Zt(e,s),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${Qe("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}const L9={kernelName:XS,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{const{x:n,scale:i,offset:s,mean:o,variance:a}=r,{varianceEpsilon:l}=e,u=t,c=[n,o,a];let h=null;s!=null&&(h=s.shape,c.push(s));let f=null;i!=null&&(f=i.shape,c.push(i));const d=new P9(n.shape,o.shape,a.shape,h,f),g=[{type:"float32",data:[l]}];return u.runWebGPUProgram(d,c,n.dtype,g)}},D9={kernelName:Mm,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:g}=n,p=uu(c);return TM({x:i,filter:s,convInfo:as(i.shape,s.shape,l,h,u,f,!1,p),backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:g,activation:d})}},O9={kernelName:Am,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=n;let g=c;g==null&&(g=[1,1]),D(Us(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const p=as(i.shape,s.shape,l,g,u,h,!0),m=[i,s],_=o!=null,v=a!=null;_&&m.push(o),v&&m.push(a);const b=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}];let x;return p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4==0?x=new MM(p,_,f,v):(x=new AM(p,_,f,v),b.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),f==="leakyrelu"&&(b.push({type:"float32",data:[d]}),x.uniforms+=" alpha : f32,"),t.runWebGPUProgram(x,m,"float32",b)}};class F9{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${On(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}const $9={kernelName:ZS,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{params:n,indices:i}=e,s=i.shape,o=s[s.length-1],a=ze(n.shape),[l,u,c,h]=_5(n,i),f=et({inputs:{x:i},backend:t,attrs:{shape:[u,o]}}),d=et({inputs:{x:n},backend:t,attrs:{shape:[ze(n.shape)/c,c]}});if(t.shouldExecuteOnCPU([n,i])||n.dtype==="string"){const v=t.readSync(i.dataId),b=t.bufferSync(n),x=D7(v,b,n.dtype,u,o,c,h,n.shape,a);return t.makeTensorInfo(l,n.dtype,x.values)}const g=new F9(o,[u,c]),p=[{type:"int32",data:[o]},{type:"int32",data:h}],m=t.runWebGPUProgram(g,[d,f],d.dtype,p),_=et({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(m.dataId),_}};class z9{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let s=0;s<t.length;s++)s===2?i.push("indexZ"):i.push(""+n[s]);return i.join()}(this.aShape);return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function NM(r){const{inputs:e,backend:t,attrs:n}=r,{x:i,indices:s}=e,{axis:o,batchDims:a}=n,l=Yr(o,i.shape)[0],u=u8(i,s,l,a),c=ze(s.shape),h=[],f=et({inputs:{x:i},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=et({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(f),h.push(d);const g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([i,s])){const v=t.tensorMap.get(d.dataId).values,b=rn(d.shape,d.dtype,v),x=t.tensorMap.get(f.dataId).values,T=rn(f.shape,f.dtype,x),I=O7(T,b,g);return h.forEach(C=>t.disposeData(C.dataId)),t.makeTensorInfo(u.outputShape,I.dtype,I.values)}const p=new z9(f.shape,g),m=t.runWebGPUProgram(p,[f,d],f.dtype);h.push(m);const _=et({inputs:{x:m},backend:t,attrs:{shape:u.outputShape}});return h.forEach(v=>t.disposeData(v.dataId)),_}const B9={kernelName:YS,backendName:"webgpu",kernelFunc:NM},U9={kernelName:QS,backendName:"webgpu",kernelFunc:Pn({opType:ct.GREATER,cpuKernelImpl:$7,dtype:"bool"})},V9={kernelName:JS,backendName:"webgpu",kernelFunc:Pn({opType:ct.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:F7})},W9={kernelName:eT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{input:n}=e;return kM(n,!0,t)}},G9={kernelName:nT,backendName:"webgpu",kernelFunc:Pt({opType:Re.IS_FINITE,dtype:"bool"})},H9={kernelName:rT,backendName:"webgpu",kernelFunc:Pt({opType:Re.IS_INF,dtype:"bool"})},j9={kernelName:iT,backendName:"webgpu",kernelFunc:Pt({opType:Re.IS_NAN,dtype:"bool"})},q9={kernelName:sT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{alpha:s}=n,o=[{type:"float32",data:[s]}],a=new fu(i.shape,Re.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[i],"float32",o)}},K9={kernelName:oT,backendName:"webgpu",kernelFunc:Pn({opType:ct.LESS,dtype:"bool",cpuKernelImpl:B7})},X9={kernelName:aT,backendName:"webgpu",kernelFunc:Pn({opType:ct.LESS_EQUAL,dtype:"bool",cpuKernelImpl:z7})};class Y9{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}const Z9={kernelName:lT,backendName:"webgpu",kernelFunc:function(r){const{backend:e,attrs:t}=r,{start:n,stop:i,num:s}=t,o=(i-n)/(s-1),a=new Y9(s),l=[{type:"float32",data:[n]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}},Q9={kernelName:uT,backendName:"webgpu",kernelFunc:Pt({opType:Re.LOG,cpuKernelImpl:U7})},J9={kernelName:cT,backendName:"webgpu",kernelFunc:Pt({opType:Re.LOG1P})},eX={kernelName:hT,backendName:"webgpu",kernelFunc:Pn({opType:ct.LOGICAL_AND,dtype:"bool"})},tX={kernelName:fT,backendName:"webgpu",kernelFunc:Pt({opType:Re.LOGICAL_NOT})},nX={kernelName:dT,backendName:"webgpu",kernelFunc:Pn({opType:ct.LOGICAL_OR})},RM=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class rX{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Qe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${RM}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class iX{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,D(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ze(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Qe()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${RM}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}const sX={kernelName:pT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=n;let u;u=s>16?new rX(i.shape):new iX(i.shape,s);const c=[{type:"int32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(u,[i],i.dtype,c)}},oX={kernelName:gT,backendName:"webgpu",kernelFunc:Pn({opType:ct.MAX,cpuKernelImpl:W7})},aX={kernelName:yT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=n;return xM(i,Vf(i.shape,s,o,1,a,l),"max",t)}},lX={kernelName:bT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s,keepDims:o}=n;return Ua(i,s,o,"min",t)}},uX={kernelName:xT,backendName:"webgpu",kernelFunc:Pn({opType:ct.MIN,cpuKernelImpl:G7})};class cX{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((i,s)=>i[0]+e[s]+i[1]),this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((i,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=n==="reflect"?0:1,this.shaderKey="mirrorPad_"+n}getUserCode(){const e=this.xShape.length,t=this.xShape.map((u,c)=>`uniforms.pad${c}[0]`).join(","),n=this.xShape.map((u,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),i=e===1?"start":"start[i]",s=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=On(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${i}) {
              ${o} = ${i} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${s}) {
              ${o} = (${s} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}const hX={kernelName:vT,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{const{x:n}=r,{paddings:i,mode:s}=e,o=t,a=i.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new cX(n.shape,i,s);return o.runWebGPUProgram(l,[n],n.dtype,a)}},fX={kernelName:wT,backendName:"webgpu",kernelFunc:Pn({opType:ct.MOD})},dX={kernelName:TT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){const s=t.tensorMap.get(n.dataId),[o,a]=j7(s.values,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,o)}const i=new fu(n.shape,Re.NEG);return t.runWebGPUProgram(i,[n],n.dtype)}},pX={kernelName:MT,backendName:"webgpu",kernelFunc:function(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=r,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=n,u=t.readSync(i.dataId),c=t.readSync(s.dataId),{selectedIndices:h}=NE(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}},mX={kernelName:AT,backendName:"webgpu",kernelFunc:function(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=r,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=n,c=t.readSync(i.dataId),h=t.readSync(s.dataId),f=o,d=a,g=l,p=u,{selectedIndices:m,selectedScores:_}=RE(c,h,f,d,g,p);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([_.length],"float32",new Float32Array(_))]}};class gX{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Qe("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}const yX={kernelName:CT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{indices:i}=e,{dtype:s,depth:o,onValue:a,offValue:l}=n,u=ze(i.shape),c=new gX(u,o),h=et({inputs:{x:i},backend:t,attrs:{shape:[u]}}),f=[{type:"float32",data:[a]},{type:"float32",data:[l]}],d=t.runWebGPUProgram(c,[h],s,f);t.disposeData(h.dataId);const g=et({inputs:{x:d},backend:t,attrs:{shape:[...i.shape,o]}});return t.disposeData(d.dataId),g}};function _f(r){const{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){const i=Fc({inputs:{input:n},backend:t}),s=_f({inputs:{x:i},backend:t}),o=td({inputs:{input:n},backend:t}),a=_f({inputs:{x:o},backend:t}),l=Ba({inputs:{real:s,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(s.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}return Gs({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}const _X={kernelName:y2,backendName:"webgpu",kernelFunc:_f},bX={kernelName:IT,backendName:"webgpu",kernelFunc:function r(e){const{inputs:t,backend:n}=e,{x:i}=t;if(i.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(i.dtype==="complex64"){const s=Fc({inputs:{input:i},backend:n}),o=r({inputs:{x:s},backend:n}),a=td({inputs:{input:i},backend:n}),l=_f({inputs:{x:a},backend:n}),u=Ba({inputs:{real:o,imag:l},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(a.dataId),n.disposeData(l.dataId),u}return Gs({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:n})}},xX={kernelName:kT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{axis:i}=n;if(e.length===1)return mg({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{Xr(s,u.shape,"All tensors passed to stack must have matching shapes"),D(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=SM({inputs:e.map(u=>{const c=mg({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(c),c}),backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeData(u.dataId)),l}};class vX{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((n,i)=>n[0]+e[i]+n[1]),this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((n,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=On(e),n=this.xShape.map((c,h)=>`uniforms.pad${h}[0]`).join(","),i=this.xShape.map((c,h)=>`uniforms.pad${h}[0] + uniforms.xShape${e>1?`[${h}]`:""}`).join(","),s=e>1?`${t}(${n})`:""+n,o=e>1?`${t}(${i})`:""+i,a=e>1?"any(outC < start)":"outC < start",l=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${o};
          let outC = getCoordsFromIndex(index);

          if (${a} || ${l}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${u}));
          }
        }
      }
    `}}const PM=r=>{const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{paddings:s,constantValue:o}=n;if(s.every(u=>br(u,[0,0])))return Rr({inputs:{x:i},backend:t});if(ze(i.shape)===0)return Gs({backend:t,attrs:{shape:s.map((u,c)=>u[0]+i.shape[c]+u[1]),value:o,dtype:i.dtype}});const a=[{type:"float32",data:[o]}];s.map(u=>a.push({type:"int32",data:[u[0],u[1]]}));const l=new vX(i.shape,s);return t.runWebGPUProgram(l,[i],i.dtype,a)},wX={kernelName:NT,backendName:"webgpu",kernelFunc:PM},SX={kernelName:RT,backendName:"webgpu",kernelFunc:Pn({opType:ct.POW})},TX={kernelName:PT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{x:n,alpha:i}=e,s=new pg(ct.PRELU,n.shape,i.shape);return t.runWebGPUProgram(s,[n,i],"float32")}},EX={kernelName:LT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{axis:s,keepDims:o}=n;return Ua(i,s,o,"prod",t)}},MX={kernelName:DT,backendName:"webgpu",kernelFunc:r=>{const{backend:e,attrs:t}=r,{start:n,stop:i,step:s,dtype:o}=t,a=X7(n,i,s,o);return e.makeTensorInfo([a.length],o,a)}},LM=Pn({opType:ct.DIV}),AX={kernelName:OS,backendName:"webgpu",kernelFunc:LM},IX={kernelName:FT,backendName:"webgpu",kernelFunc:Pt({opType:Re.RECIPROCAL})},CX={kernelName:$T,backendName:"webgpu",kernelFunc:Pt({opType:Re.RELU})},kX={kernelName:VT,backendName:"webgpu",kernelFunc:Pt({opType:Re.RELU6})};class NX{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Qe("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}const RX={kernelName:UT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{images:i}=e,{alignCorners:s,size:o,halfPixelCenters:a}=n,[l,u]=o,c=[{type:"float32",data:[s&&l>1?1:0,s&&u>1?1:0]},{type:"float32",data:[a?.5:0]}],h=new NX(i.shape,l,u);return t.runWebGPUProgram(h,[i],"float32",c)}};class PX{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey="resizeNearest_"+i}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}const LX={kernelName:BT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=n,[l,u]=a,c=[{type:"float32",data:[s&&l>1?1:0,s&&u>1?1:0]},{type:"float32",data:[s?.5:0]}],h=new PX(i.shape,l,u,o);return t.runWebGPUProgram(h,[i],i.dtype,c)}};class DX{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}const OX={kernelName:WT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{dims:s}=n,o=i.shape.length;if(o===0)return Rr({inputs:{x:i},backend:t});const a=i.shape,l=[1,1,1,1];a.forEach((m,_)=>{l[_+4-o]=m});const u=Yr(s,i.shape),c=[0,0,0,0];u.forEach(m=>{c[m+4-o]=1});const h=[{type:"int32",data:c}],f=et({inputs:{x:i},backend:t,attrs:{shape:l}}),d=new DX(l),g=t.runWebGPUProgram(d,[f],f.dtype,h);t.disposeData(f.dataId);const p=et({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),p}};class FX{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Qe("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}const $X={kernelName:b2,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{const{image:n}=r,{radians:i,fillValue:s,center:o}=e,a=t,l=new FX(n.shape,s),[u,c]=R5(o,n.shape[1],n.shape[2]),h=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof s=="number"?h.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):h.push({type:"float32",data:s}),a.runWebGPUProgram(l,[n],n.dtype,h)}},zX={kernelName:GT,backendName:"webgpu",kernelFunc:Pt({opType:Re.ROUND})},BX={kernelName:HT,backendName:"webgpu",kernelFunc:Pt({opType:Re.RSQRT,cpuKernelImpl:Y7})};class $h{constructor(e,t,n,i,s,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=st(e),this.dispatch=Ze(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${i}_${this.sliceDimGreaterThanOne}_${a}_${l}`;const u=On(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",s="";this.dispatchLayout.x.length===1?(i="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const o=`getUpdates(${Array.from({length:this.updatesRank},(a,l)=>`coords[${l}]`).join(", ")})`;return`
    ${s}
      ${Qe("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Vu(this.type,!1)}(${o});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?jy("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}const UX={kernelName:jT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{indices:i,updates:s}=e,{shape:o}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=AE(s,i,o),f=[h/u,u];if(h===0)return t.makeTensorInfo(o,i.dtype);const d=et({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=et({inputs:{x:s},backend:t,attrs:{shape:[l,u]}}),p=g.dtype,m=Gs({backend:t,attrs:{shape:f,value:0,dtype:p}}),_=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[ze(g.shape)]}],v=new $h(g.shape,a,d.shape.length,g.shape.length,c,f,p),b=t.runWebGPUProgram(v,[g,d],p,_,m),x=et({inputs:{x:b},backend:t,attrs:{shape:o}});return t.disposeData(d.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),x}};class VX{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_"+t}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Qe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}const WX={kernelName:qT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{sortedSequence:i,values:s}=e,{side:o}=n,a=new VX([s.shape[0],s.shape[1]],o),l=[{type:"int32",data:[i.shape[1]]}];return t.runWebGPUProgram(a,[i,s],"int32",l)}};class GX{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[];for(let o=0;o<this.outputShape.length;o++)s.push(""+n[o]),o<this.cRank&&i.push(""+n[o]);e=i.join(),t=s.join()}return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}const HX={kernelName:KT,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t}=r,{condition:n,t:i,e:s}=e,o=new GX(n.shape.length,i.shape,i.shape.length);return t.runWebGPUProgram(o,[n,i,s],Ma(i.dtype,s.dtype))}},jX={kernelName:XT,backendName:"webgpu",kernelFunc:Pt({opType:Re.SELU})},qX={kernelName:e2,backendName:"webgpu",kernelFunc:Pt({opType:Re.SIGMOID})},KX={kernelName:JT,backendName:"webgpu",kernelFunc:Pt({opType:Re.SIGN})},XX={kernelName:ZT,backendName:"webgpu",kernelFunc:Pt({opType:Re.SIN})},YX={kernelName:QT,backendName:"webgpu",kernelFunc:Pt({opType:Re.SINH})},DM=Pn({opType:ct.SUB,cpuKernelImpl:nK,supportsComplex:!0}),ZX={kernelName:h2,backendName:"webgpu",kernelFunc:DM},QX={kernelName:o2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{logits:i}=e,{dim:s}=n,o=Yr([s],i.shape),a=Xy({inputs:{x:i},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=cu(a.shape,o),u=et({inputs:{x:a},backend:t,attrs:{shape:l}}),c=DM({inputs:{a:i,b:u},backend:t}),h=CM({inputs:{x:c},backend:t}),f=Yy({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),d=et({inputs:{x:f},backend:t,attrs:{shape:l}}),g=LM({inputs:{a:h,b:d},backend:t});return t.disposeData(a.dataId),t.disposeData(u.dataId),t.disposeData(c.dataId),t.disposeData(h.dataId),t.disposeData(f.dataId),t.disposeData(d.dataId),g}},JX={kernelName:t2,backendName:"webgpu",kernelFunc:Pt({opType:Re.SOFTPLUS})},eY={kernelName:i2,backendName:"webgpu",kernelFunc:r=>{const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{blockShape:s,paddings:o}=n;D(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=s.reduce((_,v)=>_*v),l=[[0,0]];l.push(...o);for(let _=1+s.length;_<i.shape.length;++_)l.push([0,0]);const u=[],c=PM({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=UE(c.shape,s,a,!1),f=VE(h.length,s.length,!1),d=WE(c.shape,s,a,!1),g=et({inputs:{x:c},backend:t,attrs:{shape:h}}),p=zs({inputs:{x:g},backend:t,attrs:{perm:f}}),m=et({inputs:{x:p},backend:t,attrs:{shape:d}});return u.push(c),u.push(g),u.push(p),u.forEach(_=>t.disposeData(_.dataId)),m}};class tY{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(t,n=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${n}aShape)`;const i=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let o=0;o<t;o++)s.push(`(${i[o]} % ${n}aShape[${o}])`);return s.join()}(this.rank,"uniforms.");return`
      ${Qe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function OM(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{reps:s}=n;if(t.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const a=t.readSync(i.dataId),l=i.dtype==="string"?a.map(h=>ql(h)):a,u=rn(i.shape,i.dtype,l),c=rK(u,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const o=new tY(i.shape,s);return t.runWebGPUProgram(o,[i],i.dtype)}const nY={kernelName:vy,backendName:"webgpu",kernelFunc:OM},rY={kernelName:a2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{sparseIndices:i,sparseValues:s,defaultValue:o}=e,{outputShape:a}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:f}=AE(s,i,a);if(s.dtype==="string"){const I=t.bufferSync(i),C=t.bufferSync(s),S=ql(t.readSync(o.dataId)[0]),A=Z7(I,C,a,f,c,u,l,h,S,!1);return t.makeTensorInfo(a,A.dtype,A.values)}const d=[f/c,c],g=et({inputs:{x:i},backend:t,attrs:{shape:[u,l]}}),p=s.shape.length?et({inputs:{x:s},backend:t,attrs:{shape:[u,c]}}):Rr({inputs:{x:s},backend:t}),m=p.dtype,_=t.makeTensorInfo([],m,xs(1,m)),v=et({inputs:{x:o},backend:t,attrs:{shape:Array(d.length).fill(1)}}),b=OM({inputs:{x:v},backend:t,attrs:{reps:d}}),x=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[ze([u,c])]}];switch(u){case 0:break;case 1:{const I=new $h([u,c],l,g.shape.length,p.shape.length,h,d,m,!1);t.runWebGPUProgram(I,[p,g],m,x,b)}break;default:{const I=new $h([u,c],l,g.shape.length,_.shape.length,h,d,m,!1);t.runWebGPUProgram(I,[_,g],m,x,b)}{const I=new $h([u,c],l,g.shape.length,p.shape.length,h,d,m);t.runWebGPUProgram(I,[p,g],m,x,b)}}const T=et({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(p.dataId),t.disposeData(v.dataId),t.disposeData(_.dataId),t.disposeData(b.dataId),T}},iY={kernelName:s2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{numOrSizeSplits:s,axis:o}=n,a=Yr(o,i.shape)[0],l=Z5(i,s,a),u=i.shape.length,c=new Array(u).fill(0),h=i.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const g=du({inputs:{x:i},backend:t,attrs:{begin:c,size:d}});return c[a]+=f,g})}},sY={kernelName:n2,backendName:"webgpu",kernelFunc:Pt({opType:Re.SQRT})},oY={kernelName:B$,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{const{x:t}=r,n=e,i=new fu(t.shape,Re.SQUARE);return n.runWebGPUProgram(i,[t],t.dtype)}},aY={kernelName:l2,backendName:"webgpu",kernelFunc:Pn({opType:ct.SQUARED_DIFFERENCE})},lY={kernelName:_2,backendName:"webgpu",kernelFunc:function({inputs:r,attrs:e,backend:t}){const{x:n}=r,i=new fu(n.shape,Re.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(i,[n],n.dtype,s)}};class uY{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=On(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(this.outputShape.length===1)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map((n,i)=>(t++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${t-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Qe("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}}const cY={kernelName:u2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:f}=n,{finalShapeSparse:d,finalShape:g,isIdentity:p,sliceDim0:m,isSimpleSlice:_,begin:v,end:b,strides:x}=E5(i.shape,s,o,a,l,u,c,h,f);let T;if(p)T=et({inputs:{x:i},backend:t,attrs:{shape:g}});else if(m||_){D(i.shape.length>=1,()=>"Input must have rank at least 1, got: "+i.shape.length);const I=v5(v,b,x),C=du({inputs:{x:i},backend:t,attrs:{begin:v,size:I}});T=et({inputs:{x:C},backend:t,attrs:{shape:g}}),t.disposeData(C.dataId)}else if(t.shouldExecuteOnCPU([i])){const I=t.readSync(i.dataId),C=rn(i.shape,i.dtype,I),S=eK(d,C,x,v);T=t.makeTensorInfo(g,i.dtype,S.values)}else{const I=new uY(d),C=[{type:"int32",data:v},{type:"int32",data:x}],S=t.runWebGPUProgram(I,[i],i.dtype,C);T=et({inputs:{x:S},backend:t,attrs:{shape:g}}),t.disposeData(S.dataId)}return T}},hY={kernelName:c2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=n,{data:c,dataSplits:h}=e,f=t.readSync(c.dataId),d=t.readSync(h.dataId),[g,p]=tK(f,d,i,s,o,a,l,u);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(h.shape,"int32",p)]}},fY={kernelName:f2,backendName:"webgpu",kernelFunc:Pt({opType:Re.TAN})},dY={kernelName:d2,backendName:"webgpu",kernelFunc:Pt({opType:Re.TANH})};class pY{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Qe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class mY{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Qe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}function al(r,e){e!==null&&r.disposeData(e.dataId)}function xv(r){let e=1;for(;e<r;)e*=2;return e}const gY={kernelName:p2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{x:i}=e,{k:s,sorted:o}=n,a=i.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([i])){const x=t.readSync(i.dataId),[T,I]=iK(x,a,i.dtype,s,o);return[t.makeTensorInfo(T.shape,T.dtype,T.values),t.makeTensorInfo(I.shape,I.dtype,I.values)]}if(s===0)return a[a.length-1]=0,[t.makeTensorInfo(a,i.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[i,Gs({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=ze(a)/l,c=et({inputs:{x:i},attrs:{shape:[u,l]},backend:t}),h=xv(s),f=xv(l);let d=null;const g=()=>d===null?[c,c]:[c,d],p=(x,T,I)=>{const C=g(),S=new pY(I),A=[{type:"int32",data:[l]},{type:"int32",data:[d===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[x]},{type:"int32",data:[T]}],R=d;d=t.runWebGPUProgram(S,C,"int32",A),al(t,R)};for(let x=1;x<h;x*=2){const T=2*x;for(let I=x;I>=1;I/=2)p(T,I,[u,f])}for(let x=f;x>h;x/=2){const T=g(),I=new mY([u,x/2]),C=[{type:"int32",data:[l]},{type:"int32",data:[d===null?1:0]},{type:"int32",data:[h]}],S=d;d=t.runWebGPUProgram(I,T,"int32",C),al(t,S);const A=h/2,R=2*A;for(let F=A;F>=1;F/=2)p(R,F,d.shape)}let m=d;d=du({inputs:{x:d},backend:t,attrs:{begin:0,size:[u,s]}}),al(t,m);let _=NM({inputs:{x:c,indices:d},backend:t,attrs:{axis:1,batchDims:1}});al(t,c);const v=a.slice(0,-1);v.push(s),m=d,d=et({inputs:{x:d},attrs:{shape:v},backend:t}),al(t,m);const b=_;return _=et({inputs:{x:_},attrs:{shape:v},backend:t}),al(t,b),[_,d]}};class yY{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Qe("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}const _Y=[e7,oK,aK,lK,uK,hK,gK,yK,_K,bK,xK,vK,wK,SK,TK,IK,kK,NK,LK,OK,zK,BK,WK,n7,jK,YK,JK,t9,n9,r9,s9,o9,a9,l9,c9,f9,p9,g9,b9,x9,v9,w9,S9,T9,E9,M9,Qq,I9,R9,C9,k9,L9,D9,O9,$9,B9,U9,V9,t7,W9,HK,G9,H9,j9,q9,K9,X9,Z9,J9,Q9,eX,tX,nX,sX,MK,oX,aX,AK,lX,uX,hX,fX,y9,dX,pX,mX,FK,yX,bX,xX,wX,SX,TX,EX,MX,$K,AX,IX,CX,kX,Jq,RX,LX,OX,$X,zX,BX,UX,WX,HX,jX,qX,KX,XX,YX,PK,lY,cY,hY,QX,JX,eY,rY,iY,sY,oY,aY,ZX,_9,fY,dY,nY,gY,{kernelName:m2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{image:i,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=n,[c,h,f,d]=i.shape,[g,p]=u??[h,f],m=new yY([c,g,p,d]),_=o==="nearest"?1:2;let v;switch(a){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1}const b=[{type:"int32",data:[_]},{type:"int32",data:[v]},{type:"float32",data:[l]}];return t.runWebGPUProgram(m,[i,s],"float32",b)}},pK,{kernelName:g2,backendName:"webgpu",kernelFunc:function(r){const{inputs:e,backend:t,attrs:n}=r,{value:i}=e;let{axis:s}=n;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[s],u=new Array(a-1);let c=0;for(let p=0;p<a;p++)p!==s&&(u[c++]=o.shape[p]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[s]=1;const g=new Array(l);for(let p=0;p<g.length;p++){f[s]=p;const m=du({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),_=et({inputs:{x:m},backend:t,attrs:{shape:u}});g[p]=_,h.push(m)}return h.forEach(p=>t.disposeData(p.dataId)),g}},_X];for(const r of _Y)j$(r);function FM(){for(var r,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:r="fn main() ";break;case 1:r="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return r}var bY=function(){function r(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=st(this.outputShape),this.dispatch=Ze(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return r.prototype.getUserCode=function(){return`
        `.concat(FM("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},r}();function xY(r,e){if(wc()instanceof Jl)return function(t,n){var i=wc(),s=new bY(n.shape),o=i.runWebGPUProgram(s,[t,n],"float32");return Il().makeTensorFromTensorInfo(o)}(r,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var vY=function(){function r(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=st(t),this.dispatch=Ze(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return r.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(FM("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},r}();function wY(r,e){if(wc()instanceof Jl)return function(t,n){var i=wc(),s=new vY(t.shape),o=i.runWebGPUProgram(s,[t,n],"float32");return Il().makeTensorFromTensorInfo(o)}(r,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function $M(r){var e=r.shape,t=e[0],n=e[1],i=e[2];return ht(function(){var s,o,a=ye(r,[t*n,i]),l=j2(a,0),u=ci(bt(l,yt(n,"int32")),1),c=ci((s=l,o=n,ht(function(){var h=bt(s,yt(o,"int32"));return ft(s,Ce(h,yt(o,"int32")))})),1);return kn([u,c],1)})}function SY(r,e,t){return ht(function(){var n=function(i,s){for(var o=[],a=0;a<ss.length;a++){var l=i.get(a,0).valueOf(),u=i.get(a,1).valueOf(),c=TY(l,u,a,s),h=c.x,f=c.y;o.push(f),o.push(h)}return vi(o,[ss.length,2])}(r,t);return Ye(ln(Ce(r.toTensor(),yt(e,"int32")),"float32"),n)})}function TY(r,e,t,n){return{y:n.get(r,e,t),x:n.get(r,e,t+ss.length)}}function EY(r,e,t){return kt(this,void 0,void 0,function(){var n,i,s,o,a,l,u,c,h,f;return Nt(this,function(d){switch(d.label){case 0:return n=0,i=$M(r),[4,Promise.all([r.buffer(),e.buffer(),i.buffer()])];case 1:return s=d.sent(),o=s[0],a=s[1],l=s[2],[4,(u=SY(l,t,a)).buffer()];case 2:return c=d.sent(),h=Array.from(function(g,p){for(var m=p.shape[0],_=new Float32Array(m),v=0;v<m;v++){var b=p.get(v,0),x=p.get(v,1);_[v]=g.get(b,x,v)}return _}(o,l)),f=h.map(function(g,p){return n+=g,{y:c.get(p,0),x:c.get(p,1),score:g,name:ss[p]}}),i.dispose(),u.dispose(),[2,{keypoints:f,score:n/f.length}]}})})}function MY(r,e,t){return kt(this,void 0,void 0,function(){var n,i,s;return Nt(this,function(o){return n=$M(r),i=function(a,l,u){return ht(function(){var c=wY(a,u);return Ye(ln(Ce(a,yt(l,"int32")),"float32"),c)})}(n,t,e),s=xY(r,n),[2,[i,s]]})})}function vv(r,e){return(r-1)%e==0}var wv="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Sv="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Tv(r,e){return function(t,n){return(t-1)%n==0}(r,e)?r:Math.floor(r/e)*e+1}var Ev=function(){function r(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;D(n[1]===-1&&n[2]===-1,function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"});var i,s,o=(i=t.inputResolution,s=t.outputStride,{height:Tv(i.height,s),width:Tv(i.width,s)});(function(a){D(Sq.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,l){D(vv(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),D(vv(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return r.prototype.estimatePoses=function(e,t){return t===void 0&&(t=Xx),kt(this,void 0,void 0,function(){return Nt(this,function(n){return[2,this.estimatePosesGPU(e,t,!1)]})})},r.prototype.estimatePosesGPU=function(e,t,n){return t===void 0&&(t=Xx),n===void 0&&(n=!1),kt(this,void 0,void 0,function(){var i,s,o,a,l,u,c,h,f,d,g,p,m,_,v,b,x,T;return Nt(this,function(I){switch(I.label){case 0:return i=function(C){var S=C;if(S.maxPoses==null&&(S.maxPoses=1),S.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(S.maxPoses,". Should be > 0."));if(S.maxPoses>1){if((S=Ht(Ht({},Tq),S)).scoreThreshold<0||S.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(S.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(S.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(S.nmsRadius,"."))}return S}(t),e==null?[2,n?[[],[]]:[]]:(this.maxPoses=i.maxPoses,s=hg(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=s.imageTensor,a=s.padding,l=this.architecture==="ResNet50"?Ye(o,Eq):nM(o,[-1,1]),u=this.posenetModel.predict(l),this.architecture==="ResNet50"?(c=Vt(u[2],[0]),h=Vt(u[3],[0]),f=Vt(u[0],[0]),d=Vt(u[1],[0])):(c=Vt(u[0],[0]),h=Vt(u[1],[0]),f=Vt(u[2],[0]),d=Vt(u[3],[0])),g=Is(h),this.maxPoses!==1?[3,5]:n?[4,MY(g,c,this.outputStride)]:[3,2]);case 1:return m=I.sent(),v=m[0],_=m[1],p=[v,_],[3,4];case 2:return[4,EY(g,c,this.outputStride)];case 3:v=I.sent(),p=[v],I.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,Nq(g,c,f,d,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:p=I.sent(),I.label=7;case 7:if(n){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo(Ql(e),this.inputResolution,a)}else T=Ql(e),x=function(C,S,A,R){var F=S.height,q=S.width,O=F/(A.height*(1-R.top-R.bottom)),z=q/(A.width*(1-R.left-R.right)),H=-R.top*A.height,Q=-R.left*A.width;if(z===1&&O===1&&H===0&&Q===0)return C;for(var Z=0,Y=C;Z<Y.length;Z++)for(var fe=0,le=Y[Z].keypoints;fe<le.length;fe++){var ve=le[fe];ve.x=(ve.x+Q)*z,ve.y=(ve.y+H)*O}return C}(p,T,this.inputResolution,a),i.flipHorizontal&&(x=function(C,S){for(var A=0,R=C;A<R.length;A++)for(var F=0,q=R[A].keypoints;F<q.length;F++){var O=q[F];O.x=S.width-1-O.x}return C}(x,T));return o.dispose(),l.dispose(),zt(u),c.dispose(),h.dispose(),f.dispose(),d.dispose(),g.dispose(),[2,n?[p,b]:x]}})})},r.prototype.getCanvasInfo=function(e,t,n){var i=e.height,s=e.width,o=i/(t.height*(1-n.top-n.bottom)),a=s/(t.width*(1-n.left-n.right)),l=-n.top*t.height;return[-n.left*t.width,l,a,o,e.width,e.height]},r.prototype.dispose=function(){this.posenetModel.dispose()},r.prototype.reset=function(){},r}();function AY(r){return r===void 0&&(r=Gx),kt(this,void 0,void 0,function(){var e,t,n,i,s;return Nt(this,function(o){switch(o.label){case 0:return(e=function(c){var h=c||Gx;if(h.architecture==null&&(h.architecture="MobileNetV1"),Hx.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(Hx));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),jx[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(jx[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),qx[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(qx[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),Kx.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(Kx," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(r)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,u="model-stride".concat(a,".json"),t=l===4?Sv+"float/"+u:Sv+"quant".concat(l,"/")+u,[4,Zl(e.modelUrl||t)]);case 1:return n=o.sent(),[2,new Ev(n,e)];case 2:return i=function(c,h,f){var d={1:"100",.75:"075",.5:"050"},g="model-stride".concat(c,".json");return f===4?wv+"float/".concat(d[h],"/")+g:wv+"quant".concat(f,"/").concat(d[h],"/")+g}(e.outputStride,e.multiplier,e.quantBytes),[4,Zl(e.modelUrl||i)];case 3:return s=o.sent(),[2,new Ev(s,e)]}var a,l,u})})}function IY(r,e){return kt(this,void 0,void 0,function(){var t,n;return Nt(this,function(i){switch(r){case ns.PoseNet:return[2,AY(e)];case ns.BlazePose:if(n=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,mq(e)];if(t.runtime==="mediapipe")return[2,Uj(e)];n=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(n));case ns.MoveNet:return[2,wq(e)];default:throw new Error("".concat(r," is not a supported model name."))}})})}const CY=(r,e)=>{const t=r.__vccOpts||r;for(const[n,i]of e)t[n]=i;return t},kY=vI('<nav data-v-780bfddd><a href="/MetaMeApp" data-v-780bfddd> ARS MetaVerse </a><ul data-v-780bfddd><li data-v-780bfddd>Games</li><li data-v-780bfddd>About</li></ul></nav><div class="breeding-rhombus-spinner" id="loader" data-v-780bfddd><div class="rhombus child-1" data-v-780bfddd></div><div class="rhombus child-2" data-v-780bfddd></div><div class="rhombus child-3" data-v-780bfddd></div><div class="rhombus child-4" data-v-780bfddd></div><div class="rhombus child-5" data-v-780bfddd></div><div class="rhombus child-6" data-v-780bfddd></div><div class="rhombus child-7" data-v-780bfddd></div><div class="rhombus child-8" data-v-780bfddd></div><div class="rhombus big" data-v-780bfddd></div></div><p class="loadingText" id="loaderText" data-v-780bfddd> Loading AI and 3D model </p><div id="liveView" class="camView" data-v-780bfddd><video id="webcam" autoplay muted width="640" height="480" data-v-780bfddd></video></div><svg class="poseVisualization" width="40%" height="5%" data-v-780bfddd><rect y="10" width="100%" height="50%" rx="5" style="fill:rgb(255,255,255);" data-v-780bfddd></rect><rect id="midCapsule" x="-15" y="0" width="30" height="100%" fill="silver" stroke="black" stroke-width="5" ry="10" rx="20" data-v-780bfddd></rect><text id="midCapsuleText" x="-12" y="65%" class="font" data-v-780bfddd>33</text></svg><h1 id="fpsText" class="fps" data-v-780bfddd> X </h1>',6),NY={__name:"App",setup(r){function e(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}function t(le){const ve={video:!0};navigator.mediaDevices.getUserMedia(ve).then(function(ee){g.srcObject=ee,g.addEventListener("loadeddata",i)})}async function n(){const le=ns.BlazePose,ee=await IY(le,{runtime:"mediapipe",modelType:"lite",solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/pose/"});l=!0,console.log("Blaze pose loaded on mediapipe runtime..");var _e=document.getElementById("loader");u&&l&&(_e.style.display="none");var _e=document.getElementById("loaderText");u&&l&&(_e.style.display="none"),d=ee}function i(){d&&g&&d.estimatePoses(g).then(function(le){for(let _e=0;_e<T.length;_e++)p.removeChild(T[_e]);T.splice(0);var ve=0;if(le.length!=0){let Te=le[0].keypoints;for(let ne=0;ne<Te.length;ne++)if(Te[ne].score>.7&&(ve=ve+1,Te[ne].x>0&&Te[ne].y>0&&Te[ne].x<I.videoWidth&&Te[ne].y<I.videoHeight&&s(Te[ne].x,Te[ne].y),Te[ne].name=="nose")){var ee=Te[ne].x/I.videoWidth*100;ee<2?ee=2:ee>98&&(ee=98),m.style.transform=`translate(${ee}%, 0%)`,_.style.transform=`translate(${ee}%, 0%)`}console.log(ve),_.textContent=ve.toString()}window.requestAnimationFrame(i),b.stop(),b.getSeconds()>1?(x+=1,v.textContent="FPS: "+x.toString(),b.clear(),b.start(),x=0):x+=1})}function s(le,ve){const ee=document.createElement("div");ee.setAttribute("class","featureIndicator"),ee.style="left: "+le+"px;top: "+ve+"px;width: .5rem; height: .5rem;",p.appendChild(ee),T.push(ee)}function o(){var le,ve;this.start=function(){le=new Date},this.stop=function(){ve=new Date},this.clear=function(){le=null,ve=null},this.getSeconds=function(){return ve?Math.round((ve.getTime()-le.getTime())/1e3):0}}e()?console.log("Camera is up and functional.."):console.warn("getUserMedia() is not supported by your browser");let l,u,c,h,f,d,g,p,m,_,v;var b=new o;b.start();var x=0,T=[];const I={width:window.innerWidth,height:window.innerHeight,videoWidth:640,videoHeight:480},C=gm.timeline({defaults:{duration:1}});Lg(()=>{C.fromTo("nav",{y:"-100%",opacity:"0"},{y:"0%",opacity:"1"}),C.fromTo(".title",{opacity:"0"},{opacity:"1"}),g=document.getElementById("webcam"),p=document.getElementById("liveView"),m=document.getElementById("midCapsule"),_=document.getElementById("midCapsuleText"),v=document.getElementById("fpsText"),console.log(g),t()}),n();const S=new bD,A=new XD,R=new Zg(2,10,10),F=new Pf({color:65411});new Ur(R,F),new vF().load("./hypercasual/scene.gltf",function(le){u=!0;var ve=document.getElementById("loader");u&&l&&(ve.style.display="none");var ve=document.getElementById("loaderText");u&&l&&(ve.style.display="none"),c=le.scene,f=c.getObjectByName("mixamorigRightArm_00"),h=c.getObjectByName("mixamorigLeftArm_09"),console.log(c),le.scene.scale.set(.01,.01,.01),S.add(c),gm.timeline({defaults:{duration:1}}).fromTo(c.scale,{z:0,x:0,y:0},{z:.01,x:.01,y:.01});const _e=new oO(5);S.add(_e);const Te=10,ne=10,Le=new sO(Te,ne);S.add(Le),le.animations,le.scene,le.scenes,le.cameras,le.asset},function(le){console.log(le.loaded/le.total*100+"% loaded")},function(le){console.log("An error happened")});const O=new Yw(16777215,1,100);O.position.set(5,10,10),S.add(O);const z=new qD(4210752);S.add(z);const H=new dr(45,I.width/I.height,.1,100);H.position.z=10,H.position.y=5,H.position.x=-2,S.add(H);const Q=document.querySelector(".webgl"),Z=new jg({canvas:Q});Z.setSize(I.width,I.height),Z.setPixelRatio(2),Z.render(S,H);const Y=new JF(H,Q);Y.enableDamping=!0,Y.enablePan=!1,Y.enableZoom=!1,window.addEventListener("resize",()=>{I.width=window.innerWidth,I.height=window.innerHeight,H.aspect=I.width/I.height,H.updateProjectionMatrix(),Z.setSize(I.width,I.height)});const fe=()=>{if(c){if(f){const le=A.getElapsedTime();f.rotation.x+=Math.sin(le)*.005}if(h){const le=A.getElapsedTime();h.rotation.x+=Math.sin(le)*.005}}Y.update(),Z.render(S,H),window.requestAnimationFrame(fe)};return fe(),(le,ve)=>(pI(),yI(Ni,null,[kY,dw(" --> ")],64))}},RY=CY(NY,[["__scopeId","data-v-780bfddd"]]);nC(RY).mount("#app");
